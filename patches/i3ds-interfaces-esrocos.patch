diff --git a/.gitignore b/.gitignore
index 118592e..8550feb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,3 @@
-generated/
 build/
 *.tar

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e51932c..cace6a5 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,8 @@
-cmake_minimum_required(VERSION 3.8)
+cmake_minimum_required(VERSION 3.3)
+
+set(CMAKE_TRY_COMPILE_TARGET_TYPE "STATIC_LIBRARY")
+set (CMAKE_C_COMPILER_WORKS 1)
+set (CMAKE_CXX_COMPILER_WORKS 1)

 project (i3ds_asn1)

@@ -9,10 +13,11 @@ set (PROJECT_VERSION "1.0")
 set (PROJECT_SOVERSION "1")
 set (PROJECT_DESCRIPTION "i3ds ASN.1 bucket")

-option(BUILD_ASN1CC "Path to ASN.1 compiler" OFF)
+option(BUILD_ASN1CC "Path to ASN.1 compiler" ON)
 option(BUILD_EMBEDDED "Build for embedded systems" OFF)
 option(BUILD_DEBUG "Debug-builds" ON)

+
 if (BUILD_EMBEDDED)
   if(NOT DEFINED CMAKE_FIND_ROOT_PATH)
     MESSAGE(FATAL_ERROR "CMAKE_FIND_ROOT_PATH path must be set when compiling for embedded")
@@ -52,7 +57,7 @@ if (NOT CMAKE_CXX_FLAGS)

     SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wformat-nonliteral")
     SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Winline")
-    SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wmissing-declarations")
+    #SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wmissing-declarations")
     SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unused-parameter")
     SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wpointer-arith")
     SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wshadow")
@@ -92,6 +97,8 @@ set (GENPATH ${CMAKE_CURRENT_SOURCE_DIR}/generated)
 include_directories(BEFORE ${GENPATH}/include)
 file(GLOB SRCS ${GENPATH}/src/*.cpp)

+message(STATUS "Source Code ${SRCS}")
+
 add_library(i3ds_asn1 SHARED ${SRCS})

 set_target_properties (
@@ -102,7 +109,7 @@ set_target_properties (
 target_include_directories(i3ds_asn1 PRIVATE ${GENPATH}/src)

 install(TARGETS i3ds_asn1
-    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
+    LIBRARY DESTINATION lib
+    PUBLIC_HEADER DESTINATION include/i3ds_asn1)

 install (DIRECTORY ${GENPATH}/include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp")
diff --git a/generated/Analog.c b/generated/Analog.c
new file mode 100644
index 0000000..9f69a06
--- /dev/null
+++ b/generated/Analog.c
@@ -0,0 +1,171 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Analog.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SeriesCount_Initialize(SeriesCount* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt8_Initialize(pVal);
+}
+
+flag SeriesCount_IsConstraintValid(const SeriesCount* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_SERIESCOUNT;
+
+	return ret;
+}
+
+flag SeriesCount_Encode(const SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SeriesCount_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+
+    return ret;
+}
+
+flag SeriesCount_Decode(SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt8_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && SeriesCount_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void AnalogSeriesDescriptor_Initialize(AnalogSeriesDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set series_count */
+	T_UInt8_Initialize((&(pVal->series_count)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+}
+
+flag AnalogSeriesDescriptor_IsConstraintValid(const AnalogSeriesDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->series_count <= 255UL);
+        *pErrCode = ret ? 0 :  ERR_ANALOGSERIESDESCRIPTOR_SERIES_COUNT;
+        if (ret) {
+            ret = (pVal->batch_size <= 4294967295UL);
+            *pErrCode = ret ? 0 :  ERR_ANALOGSERIESDESCRIPTOR_BATCH_SIZE;
+        }
+    }
+
+	return ret;
+}
+
+flag AnalogSeriesDescriptor_Encode(const AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? AnalogSeriesDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode series_count */
+	        ret = SeriesCount_Encode((&(pVal->series_count)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode batch_size */
+	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag AnalogSeriesDescriptor_Decode(AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode series_count */
+	    ret = SeriesCount_Decode((&(pVal->series_count)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode batch_size */
+	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && AnalogSeriesDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Analog.h b/generated/Analog.h
new file mode 100644
index 0000000..f98b52a
--- /dev/null
+++ b/generated/Analog.h
@@ -0,0 +1,92 @@
+#ifndef GENERATED_ASN1SCC_Analog_H
+#define GENERATED_ASN1SCC_Analog_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Sensor.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_UInt8 SeriesCount;
+
+
+void SeriesCount_Initialize(SeriesCount* pVal);
+
+#define ERR_SERIESCOUNT		8344  /**/
+flag SeriesCount_IsConstraintValid(const SeriesCount* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SERIESCOUNT_2		8351  /**/
+#define SeriesCount_REQUIRED_BYTES_FOR_ENCODING       1
+#define SeriesCount_REQUIRED_BITS_FOR_ENCODING        8
+
+flag SeriesCount_Encode(const SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SERIESCOUNT_2		8352  /**/
+flag SeriesCount_Decode(SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- AnalogSeriesDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    T_UInt8 series_count;
+    T_UInt32 batch_size;
+
+} AnalogSeriesDescriptor;
+
+void AnalogSeriesDescriptor_Initialize(AnalogSeriesDescriptor* pVal);
+
+#define ERR_ANALOGSERIESDESCRIPTOR		8506  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES		8465  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_TIMESTAMP		8355  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_VALIDITY		8370  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		8458  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		8447  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		8381  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		8436  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		8392  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		8403  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		8414  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		8425  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_SERIES_COUNT		8476  /**/
+#define ERR_ANALOGSERIESDESCRIPTOR_BATCH_SIZE		8491  /**/
+flag AnalogSeriesDescriptor_IsConstraintValid(const AnalogSeriesDescriptor* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR		8507  /**/
+#define ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_2		8472  /**/
+#define ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR_SERIES_COUNT_2_2		8487  /**/
+#define ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR_BATCH_SIZE_2_2		8502  /**/
+#define AnalogSeriesDescriptor_REQUIRED_BYTES_FOR_ENCODING       71
+#define AnalogSeriesDescriptor_REQUIRED_BITS_FOR_ENCODING        565
+
+flag AnalogSeriesDescriptor_Encode(const AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR		8508  /**/
+#define ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_2		8473  /**/
+#define ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR_SERIES_COUNT_2_2		8488  /**/
+#define ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR_BATCH_SIZE_2_2		8503  /**/
+flag AnalogSeriesDescriptor_Decode(AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Camera.c b/generated/Camera.c
new file mode 100644
index 0000000..60c3417
--- /dev/null
+++ b/generated/Camera.c
@@ -0,0 +1,805 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Camera.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SensorGain_Initialize(SensorGain* pVal)
+{
+	(void)pVal;
+
+
+	T_Float_Initialize(pVal);
+}
+
+flag SensorGain_IsConstraintValid(const SensorGain* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_SENSORGAIN;
+
+	return ret;
+}
+
+flag SensorGain_Encode(const SensorGain* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorGain_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_Float_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorGain_Decode(SensorGain* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_Float_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && SensorGain_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PatternSequence_Initialize(PatternSequence* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt16_Initialize(pVal);
+}
+
+flag PatternSequence_IsConstraintValid(const PatternSequence* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_PATTERNSEQUENCE;
+
+	return ret;
+}
+
+flag PatternSequence_Encode(const PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PatternSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PatternSequence_Decode(PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt16_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && PatternSequence_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PatternID_Initialize(PatternID* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt16_Initialize(pVal);
+}
+
+flag PatternID_IsConstraintValid(const PatternID* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_PATTERNID;
+
+	return ret;
+}
+
+flag PatternID_Encode(const PatternID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PatternID_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PatternID_Decode(PatternID* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt16_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && PatternID_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void FlashStrength_Initialize(FlashStrength* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt8_Initialize(pVal);
+}
+
+flag FlashStrength_IsConstraintValid(const FlashStrength* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_FLASHSTRENGTH;
+
+	return ret;
+}
+
+flag FlashStrength_Encode(const FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? FlashStrength_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag FlashStrength_Decode(FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt8_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && FlashStrength_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ShutterTime_Initialize(ShutterTime* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag ShutterTime_IsConstraintValid(const ShutterTime* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_SHUTTERTIME;
+
+	return ret;
+}
+
+flag ShutterTime_Encode(const ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ShutterTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ShutterTime_Decode(ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && ShutterTime_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraExposure_Initialize(CameraExposure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set shutter */
+	T_UInt32_Initialize((&(pVal->shutter)));
+	/*set gain */
+	T_Float_Initialize((&(pVal->gain)));
+}
+
+flag CameraExposure_IsConstraintValid(const CameraExposure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->shutter <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_CAMERAEXPOSURE_SHUTTER;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->gain) && (pVal->gain <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_CAMERAEXPOSURE_GAIN;
+    }
+
+	return ret;
+}
+
+flag CameraExposure_Encode(const CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraExposure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode shutter */
+	    ret = ShutterTime_Encode((&(pVal->shutter)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode gain */
+	        ret = SensorGain_Encode((&(pVal->gain)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraExposure_Decode(CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode shutter */
+	ret = ShutterTime_Decode((&(pVal->shutter)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode gain */
+	    ret = SensorGain_Decode((&(pVal->gain)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraExposure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraAutoExposure_Initialize(CameraAutoExposure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set max_shutter */
+	T_UInt32_Initialize((&(pVal->max_shutter)));
+	/*set max_gain */
+	T_Float_Initialize((&(pVal->max_gain)));
+}
+
+flag CameraAutoExposure_IsConstraintValid(const CameraAutoExposure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->max_shutter <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_CAMERAAUTOEXPOSURE_MAX_SHUTTER;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->max_gain) && (pVal->max_gain <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_CAMERAAUTOEXPOSURE_MAX_GAIN;
+    }
+
+	return ret;
+}
+
+flag CameraAutoExposure_Encode(const CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraAutoExposure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode max_shutter */
+	        ret = ShutterTime_Encode((&(pVal->max_shutter)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode max_gain */
+	            ret = SensorGain_Encode((&(pVal->max_gain)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraAutoExposure_Decode(CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode max_shutter */
+	    ret = ShutterTime_Decode((&(pVal->max_shutter)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode max_gain */
+	        ret = SensorGain_Decode((&(pVal->max_gain)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && CameraAutoExposure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraFlash_Initialize(CameraFlash* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set strength */
+	T_UInt8_Initialize((&(pVal->strength)));
+}
+
+flag CameraFlash_IsConstraintValid(const CameraFlash* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->strength <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_CAMERAFLASH_STRENGTH;
+
+	return ret;
+}
+
+flag CameraFlash_Encode(const CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraFlash_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode strength */
+	        ret = FlashStrength_Encode((&(pVal->strength)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraFlash_Decode(CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode strength */
+	    ret = FlashStrength_Decode((&(pVal->strength)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraFlash_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraRegion_Initialize(CameraRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag CameraRegion_IsConstraintValid(const CameraRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_CAMERAREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_CAMERAREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_CAMERAREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_CAMERAREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag CameraRegion_Encode(const CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraRegion_Decode(CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraPattern_Initialize(CameraPattern* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set pattern_sequence */
+	T_UInt16_Initialize((&(pVal->pattern_sequence)));
+}
+
+flag CameraPattern_IsConstraintValid(const CameraPattern* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->pattern_sequence <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_CAMERAPATTERN_PATTERN_SEQUENCE;
+
+	return ret;
+}
+
+flag CameraPattern_Encode(const CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraPattern_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode pattern_sequence */
+	        ret = PatternSequence_Encode((&(pVal->pattern_sequence)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraPattern_Decode(CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode pattern_sequence */
+	    ret = PatternSequence_Decode((&(pVal->pattern_sequence)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraPattern_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraConfiguration_Initialize(CameraConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set shutter */
+	T_UInt32_Initialize((&(pVal->shutter)));
+	/*set gain */
+	T_Float_Initialize((&(pVal->gain)));
+	/*set auto_exposure_enabled */
+	T_Boolean_Initialize((&(pVal->auto_exposure_enabled)));
+	/*set max_shutter */
+	T_UInt32_Initialize((&(pVal->max_shutter)));
+	/*set max_gain */
+	T_Float_Initialize((&(pVal->max_gain)));
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+	/*set flash_enabled */
+	T_Boolean_Initialize((&(pVal->flash_enabled)));
+	/*set flash_strength */
+	T_UInt8_Initialize((&(pVal->flash_strength)));
+	/*set pattern_enabled */
+	T_Boolean_Initialize((&(pVal->pattern_enabled)));
+	/*set pattern_sequence */
+	T_UInt16_Initialize((&(pVal->pattern_sequence)));
+}
+
+flag CameraConfiguration_IsConstraintValid(const CameraConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->shutter <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_SHUTTER;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->gain) && (pVal->gain <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_GAIN;
+        if (ret) {
+            ret = (pVal->max_shutter <= 4294967295UL);
+            *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_MAX_SHUTTER;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->max_gain) && (pVal->max_gain <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_MAX_GAIN;
+                if (ret) {
+                    ret = (pVal->region.offset_x <= 65535UL);
+                    *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_REGION_OFFSET_X;
+                    if (ret) {
+                        ret = (pVal->region.offset_y <= 65535UL);
+                        *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_REGION_OFFSET_Y;
+                        if (ret) {
+                            ret = (pVal->region.size_x <= 65535UL);
+                            *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_REGION_SIZE_X;
+                            if (ret) {
+                                ret = (pVal->region.size_y <= 65535UL);
+                                *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_REGION_SIZE_Y;
+                            }
+                        }
+                    }
+                    if (ret) {
+                        ret = (pVal->flash_strength <= 255UL);
+                        *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_FLASH_STRENGTH;
+                        if (ret) {
+                            ret = (pVal->pattern_sequence <= 65535UL);
+                            *pErrCode = ret ? 0 :  ERR_CAMERACONFIGURATION_PATTERN_SEQUENCE;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag CameraConfiguration_Encode(const CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode shutter */
+	    ret = ShutterTime_Encode((&(pVal->shutter)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode gain */
+	        ret = SensorGain_Encode((&(pVal->gain)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode auto_exposure_enabled */
+	            ret = T_Boolean_Encode((&(pVal->auto_exposure_enabled)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode max_shutter */
+	                ret = ShutterTime_Encode((&(pVal->max_shutter)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode max_gain */
+	                    ret = SensorGain_Encode((&(pVal->max_gain)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode region_enabled */
+	                        ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode region */
+	                            ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode flash_enabled */
+	                                ret = T_Boolean_Encode((&(pVal->flash_enabled)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode flash_strength */
+	                                    ret = FlashStrength_Encode((&(pVal->flash_strength)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode pattern_enabled */
+	                                        ret = T_Boolean_Encode((&(pVal->pattern_enabled)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode pattern_sequence */
+	                                            ret = PatternSequence_Encode((&(pVal->pattern_sequence)), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraConfiguration_Decode(CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode shutter */
+	ret = ShutterTime_Decode((&(pVal->shutter)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode gain */
+	    ret = SensorGain_Decode((&(pVal->gain)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode auto_exposure_enabled */
+	        ret = T_Boolean_Decode((&(pVal->auto_exposure_enabled)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode max_shutter */
+	            ret = ShutterTime_Decode((&(pVal->max_shutter)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode max_gain */
+	                ret = SensorGain_Decode((&(pVal->max_gain)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode region_enabled */
+	                    ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode region */
+	                        ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode flash_enabled */
+	                            ret = T_Boolean_Decode((&(pVal->flash_enabled)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode flash_strength */
+	                                ret = FlashStrength_Decode((&(pVal->flash_strength)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode pattern_enabled */
+	                                    ret = T_Boolean_Decode((&(pVal->pattern_enabled)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode pattern_sequence */
+	                                        ret = PatternSequence_Decode((&(pVal->pattern_sequence)), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && CameraConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Camera.h b/generated/Camera.h
new file mode 100644
index 0000000..2d6563e
--- /dev/null
+++ b/generated/Camera.h
@@ -0,0 +1,320 @@
+#ifndef GENERATED_ASN1SCC_Camera_H
+#define GENERATED_ASN1SCC_Camera_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_Float SensorGain;
+
+
+void SensorGain_Initialize(SensorGain* pVal);
+
+#define ERR_SENSORGAIN		9445  /**/
+flag SensorGain_IsConstraintValid(const SensorGain* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SENSORGAIN_2		9452  /**/
+#define SensorGain_REQUIRED_BYTES_FOR_ENCODING       13
+#define SensorGain_REQUIRED_BITS_FOR_ENCODING        104
+
+flag SensorGain_Encode(const SensorGain* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SENSORGAIN_2		9453  /**/
+flag SensorGain_Decode(SensorGain* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt16 PatternSequence;
+
+
+void PatternSequence_Initialize(PatternSequence* pVal);
+
+#define ERR_PATTERNSEQUENCE		9658  /**/
+flag PatternSequence_IsConstraintValid(const PatternSequence* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_PATTERNSEQUENCE_2		9665  /**/
+#define PatternSequence_REQUIRED_BYTES_FOR_ENCODING       2
+#define PatternSequence_REQUIRED_BITS_FOR_ENCODING        16
+
+flag PatternSequence_Encode(const PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_PATTERNSEQUENCE_2		9666  /**/
+flag PatternSequence_Decode(PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt16 PatternID;
+
+
+void PatternID_Initialize(PatternID* pVal);
+
+#define ERR_PATTERNID		9669  /**/
+flag PatternID_IsConstraintValid(const PatternID* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_PATTERNID_2		9676  /**/
+#define PatternID_REQUIRED_BYTES_FOR_ENCODING       2
+#define PatternID_REQUIRED_BITS_FOR_ENCODING        16
+
+flag PatternID_Encode(const PatternID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_PATTERNID_2		9677  /**/
+flag PatternID_Decode(PatternID* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt8 FlashStrength;
+
+
+void FlashStrength_Initialize(FlashStrength* pVal);
+
+#define ERR_FLASHSTRENGTH		9541  /**/
+flag FlashStrength_IsConstraintValid(const FlashStrength* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_FLASHSTRENGTH_2		9548  /**/
+#define FlashStrength_REQUIRED_BYTES_FOR_ENCODING       1
+#define FlashStrength_REQUIRED_BITS_FOR_ENCODING        8
+
+flag FlashStrength_Encode(const FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_FLASHSTRENGTH_2		9549  /**/
+flag FlashStrength_Decode(FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt32 ShutterTime;
+
+
+void ShutterTime_Initialize(ShutterTime* pVal);
+
+#define ERR_SHUTTERTIME		9434  /**/
+flag ShutterTime_IsConstraintValid(const ShutterTime* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SHUTTERTIME_2		9441  /**/
+#define ShutterTime_REQUIRED_BYTES_FOR_ENCODING       4
+#define ShutterTime_REQUIRED_BITS_FOR_ENCODING        32
+
+flag ShutterTime_Encode(const ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SHUTTERTIME_2		9442  /**/
+flag ShutterTime_Decode(ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraExposure --------------------------------------------*/
+typedef struct {
+    T_UInt32 shutter;
+    T_Float gain;
+
+} CameraExposure;
+
+void CameraExposure_Initialize(CameraExposure* pVal);
+
+#define ERR_CAMERAEXPOSURE		9486  /**/
+#define ERR_CAMERAEXPOSURE_SHUTTER		9456  /**/
+#define ERR_CAMERAEXPOSURE_GAIN		9471  /**/
+flag CameraExposure_IsConstraintValid(const CameraExposure* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CAMERAEXPOSURE		9487  /**/
+#define ERR_UPER_ENCODE_CAMERAEXPOSURE_SHUTTER_2_2		9467  /**/
+#define ERR_UPER_ENCODE_CAMERAEXPOSURE_GAIN_2_2		9482  /**/
+#define CameraExposure_REQUIRED_BYTES_FOR_ENCODING       17
+#define CameraExposure_REQUIRED_BITS_FOR_ENCODING        136
+
+flag CameraExposure_Encode(const CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CAMERAEXPOSURE		9488  /**/
+#define ERR_UPER_DECODE_CAMERAEXPOSURE_SHUTTER_2_2		9468  /**/
+#define ERR_UPER_DECODE_CAMERAEXPOSURE_GAIN_2_2		9483  /**/
+flag CameraExposure_Decode(CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraAutoExposure --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    T_UInt32 max_shutter;
+    T_Float max_gain;
+
+} CameraAutoExposure;
+
+void CameraAutoExposure_Initialize(CameraAutoExposure* pVal);
+
+#define ERR_CAMERAAUTOEXPOSURE		9534  /**/
+#define ERR_CAMERAAUTOEXPOSURE_ENABLE		9493  /**/
+#define ERR_CAMERAAUTOEXPOSURE_MAX_SHUTTER		9504  /**/
+#define ERR_CAMERAAUTOEXPOSURE_MAX_GAIN		9519  /**/
+flag CameraAutoExposure_IsConstraintValid(const CameraAutoExposure* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE		9535  /**/
+#define ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE_ENABLE_2		9500  /**/
+#define ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE_MAX_SHUTTER_2_2		9515  /**/
+#define ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE_MAX_GAIN_2_2		9530  /**/
+#define CameraAutoExposure_REQUIRED_BYTES_FOR_ENCODING       18
+#define CameraAutoExposure_REQUIRED_BITS_FOR_ENCODING        137
+
+flag CameraAutoExposure_Encode(const CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CAMERAAUTOEXPOSURE		9536  /**/
+#define ERR_UPER_DECODE_CAMERAAUTOEXPOSURE_ENABLE_2		9501  /**/
+#define ERR_UPER_DECODE_CAMERAAUTOEXPOSURE_MAX_SHUTTER_2_2		9516  /**/
+#define ERR_UPER_DECODE_CAMERAAUTOEXPOSURE_MAX_GAIN_2_2		9531  /**/
+flag CameraAutoExposure_Decode(CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraFlash --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    T_UInt8 strength;
+
+} CameraFlash;
+
+void CameraFlash_Initialize(CameraFlash* pVal);
+
+#define ERR_CAMERAFLASH		9578  /**/
+#define ERR_CAMERAFLASH_ENABLE		9552  /**/
+#define ERR_CAMERAFLASH_STRENGTH		9563  /**/
+flag CameraFlash_IsConstraintValid(const CameraFlash* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CAMERAFLASH		9579  /**/
+#define ERR_UPER_ENCODE_CAMERAFLASH_ENABLE_2		9559  /**/
+#define ERR_UPER_ENCODE_CAMERAFLASH_STRENGTH_2_2		9574  /**/
+#define CameraFlash_REQUIRED_BYTES_FOR_ENCODING       2
+#define CameraFlash_REQUIRED_BITS_FOR_ENCODING        9
+
+flag CameraFlash_Encode(const CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CAMERAFLASH		9580  /**/
+#define ERR_UPER_DECODE_CAMERAFLASH_ENABLE_2		9560  /**/
+#define ERR_UPER_DECODE_CAMERAFLASH_STRENGTH_2_2		9575  /**/
+flag CameraFlash_Decode(CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PlanarRegion region;
+
+} CameraRegion;
+
+void CameraRegion_Initialize(CameraRegion* pVal);
+
+#define ERR_CAMERAREGION		9651  /**/
+#define ERR_CAMERAREGION_ENABLE		9585  /**/
+#define ERR_CAMERAREGION_REGION		9640  /**/
+#define ERR_CAMERAREGION_REGION_OFFSET_X		9596  /**/
+#define ERR_CAMERAREGION_REGION_OFFSET_Y		9607  /**/
+#define ERR_CAMERAREGION_REGION_SIZE_X		9618  /**/
+#define ERR_CAMERAREGION_REGION_SIZE_Y		9629  /**/
+flag CameraRegion_IsConstraintValid(const CameraRegion* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CAMERAREGION		9652  /**/
+#define ERR_UPER_ENCODE_CAMERAREGION_ENABLE_2		9592  /**/
+#define ERR_UPER_ENCODE_CAMERAREGION_REGION_2		9647  /**/
+#define CameraRegion_REQUIRED_BYTES_FOR_ENCODING       9
+#define CameraRegion_REQUIRED_BITS_FOR_ENCODING        65
+
+flag CameraRegion_Encode(const CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CAMERAREGION		9653  /**/
+#define ERR_UPER_DECODE_CAMERAREGION_ENABLE_2		9593  /**/
+#define ERR_UPER_DECODE_CAMERAREGION_REGION_2		9648  /**/
+flag CameraRegion_Decode(CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraPattern --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    T_UInt16 pattern_sequence;
+
+} CameraPattern;
+
+void CameraPattern_Initialize(CameraPattern* pVal);
+
+#define ERR_CAMERAPATTERN		9706  /**/
+#define ERR_CAMERAPATTERN_ENABLE		9680  /**/
+#define ERR_CAMERAPATTERN_PATTERN_SEQUENCE		9691  /**/
+flag CameraPattern_IsConstraintValid(const CameraPattern* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CAMERAPATTERN		9707  /**/
+#define ERR_UPER_ENCODE_CAMERAPATTERN_ENABLE_2		9687  /**/
+#define ERR_UPER_ENCODE_CAMERAPATTERN_PATTERN_SEQUENCE_2_2		9702  /**/
+#define CameraPattern_REQUIRED_BYTES_FOR_ENCODING       3
+#define CameraPattern_REQUIRED_BITS_FOR_ENCODING        17
+
+flag CameraPattern_Encode(const CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CAMERAPATTERN		9708  /**/
+#define ERR_UPER_DECODE_CAMERAPATTERN_ENABLE_2		9688  /**/
+#define ERR_UPER_DECODE_CAMERAPATTERN_PATTERN_SEQUENCE_2_2		9703  /**/
+flag CameraPattern_Decode(CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraConfiguration --------------------------------------------*/
+typedef struct {
+    T_UInt32 shutter;
+    T_Float gain;
+    T_Boolean auto_exposure_enabled;
+    T_UInt32 max_shutter;
+    T_Float max_gain;
+    T_Boolean region_enabled;
+    PlanarRegion region;
+    T_Boolean flash_enabled;
+    T_UInt8 flash_strength;
+    T_Boolean pattern_enabled;
+    T_UInt16 pattern_sequence;
+
+} CameraConfiguration;
+
+void CameraConfiguration_Initialize(CameraConfiguration* pVal);
+
+#define ERR_CAMERACONFIGURATION		9902  /**/
+#define ERR_CAMERACONFIGURATION_SHUTTER		9713  /**/
+#define ERR_CAMERACONFIGURATION_GAIN		9728  /**/
+#define ERR_CAMERACONFIGURATION_AUTO_EXPOSURE_ENABLED		9743  /**/
+#define ERR_CAMERACONFIGURATION_MAX_SHUTTER		9754  /**/
+#define ERR_CAMERACONFIGURATION_MAX_GAIN		9769  /**/
+#define ERR_CAMERACONFIGURATION_REGION_ENABLED		9784  /**/
+#define ERR_CAMERACONFIGURATION_REGION		9839  /**/
+#define ERR_CAMERACONFIGURATION_REGION_OFFSET_X		9795  /**/
+#define ERR_CAMERACONFIGURATION_REGION_OFFSET_Y		9806  /**/
+#define ERR_CAMERACONFIGURATION_REGION_SIZE_X		9817  /**/
+#define ERR_CAMERACONFIGURATION_REGION_SIZE_Y		9828  /**/
+#define ERR_CAMERACONFIGURATION_FLASH_ENABLED		9850  /**/
+#define ERR_CAMERACONFIGURATION_FLASH_STRENGTH		9861  /**/
+#define ERR_CAMERACONFIGURATION_PATTERN_ENABLED		9876  /**/
+#define ERR_CAMERACONFIGURATION_PATTERN_SEQUENCE		9887  /**/
+flag CameraConfiguration_IsConstraintValid(const CameraConfiguration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION		9903  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_SHUTTER_2_2		9724  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_GAIN_2_2		9739  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_AUTO_EXPOSURE_ENABLED_2		9750  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_MAX_SHUTTER_2_2		9765  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_MAX_GAIN_2_2		9780  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_REGION_ENABLED_2		9791  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_REGION_2		9846  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_FLASH_ENABLED_2		9857  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_FLASH_STRENGTH_2_2		9872  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_PATTERN_ENABLED_2		9883  /**/
+#define ERR_UPER_ENCODE_CAMERACONFIGURATION_PATTERN_SEQUENCE_2_2		9898  /**/
+#define CameraConfiguration_REQUIRED_BYTES_FOR_ENCODING       46
+#define CameraConfiguration_REQUIRED_BITS_FOR_ENCODING        364
+
+flag CameraConfiguration_Encode(const CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CAMERACONFIGURATION		9904  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_SHUTTER_2_2		9725  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_GAIN_2_2		9740  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_AUTO_EXPOSURE_ENABLED_2		9751  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_MAX_SHUTTER_2_2		9766  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_MAX_GAIN_2_2		9781  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_REGION_ENABLED_2		9792  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_REGION_2		9847  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_FLASH_ENABLED_2		9858  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_FLASH_STRENGTH_2_2		9873  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_PATTERN_ENABLED_2		9884  /**/
+#define ERR_UPER_DECODE_CAMERACONFIGURATION_PATTERN_SEQUENCE_2_2		9899  /**/
+flag CameraConfiguration_Decode(CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Common.c b/generated/Common.c
new file mode 100644
index 0000000..df5efa6
--- /dev/null
+++ b/generated/Common.c
@@ -0,0 +1,346 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Common.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Timepoint_Initialize(Timepoint* pVal)
+{
+	(void)pVal;
+
+
+	T_Int64_Initialize(pVal);
+}
+
+flag Timepoint_IsConstraintValid(const Timepoint* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag Timepoint_Encode(const Timepoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Timepoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_Int64_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Timepoint_Decode(Timepoint* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_Int64_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && Timepoint_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void NodeID_Initialize(NodeID* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag NodeID_IsConstraintValid(const NodeID* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 16777215UL);
+    *pErrCode = ret ? 0 :  ERR_NODEID;
+
+	return ret;
+}
+
+flag NodeID_Encode(const NodeID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? NodeID_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag NodeID_Decode(NodeID* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_NODEID;
+
+	return ret  && NodeID_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void EndpointID_Initialize(EndpointID* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag EndpointID_IsConstraintValid(const EndpointID* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_ENDPOINTID;
+
+	return ret;
+}
+
+flag EndpointID_Encode(const EndpointID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? EndpointID_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag EndpointID_Decode(EndpointID* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ENDPOINTID;
+
+	return ret  && EndpointID_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ResultCode_Initialize(ResultCode* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = success;
+}
+
+flag ResultCode_IsConstraintValid(const ResultCode* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((*(pVal)) == success)) || (((*(pVal)) == error_node_id)))) || (((*(pVal)) == error_endpoint_id)))) || (((*(pVal)) == error_unsupported)))) || (((*(pVal)) == error_state)))) || (((*(pVal)) == error_value)))) || (((*(pVal)) == error_other)));
+    *pErrCode = ret ? 0 :  ERR_RESULTCODE;
+
+	return ret;
+}
+
+flag ResultCode_Encode(const ResultCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ResultCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case success:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
+	        	break;
+	        case error_node_id:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
+	        	break;
+	        case error_endpoint_id:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
+	        	break;
+	        case error_unsupported:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
+	        	break;
+	        case error_state:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
+	        	break;
+	        case error_value:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
+	        	break;
+	        case error_other:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_RESULTCODE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ResultCode_Decode(ResultCode* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_RESULTCODE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = success;
+	                break;
+	            case 1:
+	                (*(pVal)) = error_node_id;
+	                break;
+	            case 2:
+	                (*(pVal)) = error_endpoint_id;
+	                break;
+	            case 3:
+	                (*(pVal)) = error_unsupported;
+	                break;
+	            case 4:
+	                (*(pVal)) = error_state;
+	                break;
+	            case 5:
+	                (*(pVal)) = error_value;
+	                break;
+	            case 6:
+	                (*(pVal)) = error_other;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_RESULTCODE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = success;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && ResultCode_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CommandResponse_Initialize(CommandResponse* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set result */
+	ResultCode_Initialize((&(pVal->result)));
+	/*set message */
+	T_String_Initialize((&(pVal->message)));
+}
+
+flag CommandResponse_IsConstraintValid(const CommandResponse* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (((((((((((((pVal->result == success)) || ((pVal->result == error_node_id)))) || ((pVal->result == error_endpoint_id)))) || ((pVal->result == error_unsupported)))) || ((pVal->result == error_state)))) || ((pVal->result == error_value)))) || ((pVal->result == error_other)));
+    *pErrCode = ret ? 0 :  ERR_COMMANDRESPONSE_RESULT;
+    if (ret) {
+        ret = (pVal->message.nCount <= 40);
+        *pErrCode = ret ? 0 :  ERR_COMMANDRESPONSE_MESSAGE;
+    }
+
+	return ret;
+}
+
+flag CommandResponse_Encode(const CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CommandResponse_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode result */
+	    ret = ResultCode_Encode((&(pVal->result)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode message */
+	        ret = T_String_Encode((&(pVal->message)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CommandResponse_Decode(CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode result */
+	ret = ResultCode_Decode((&(pVal->result)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode message */
+	    ret = T_String_Decode((&(pVal->message)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CommandResponse_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Common.h b/generated/Common.h
new file mode 100644
index 0000000..718f989
--- /dev/null
+++ b/generated/Common.h
@@ -0,0 +1,140 @@
+#ifndef GENERATED_ASN1SCC_Common_H
+#define GENERATED_ASN1SCC_Common_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_Int64 Timepoint;
+
+
+void Timepoint_Initialize(Timepoint* pVal);
+
+#define ERR_TIMEPOINT		8527  /**/
+flag Timepoint_IsConstraintValid(const Timepoint* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TIMEPOINT_2		8534  /**/
+#define Timepoint_REQUIRED_BYTES_FOR_ENCODING       8
+#define Timepoint_REQUIRED_BITS_FOR_ENCODING        64
+
+flag Timepoint_Encode(const Timepoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TIMEPOINT_2		8535  /**/
+flag Timepoint_Decode(Timepoint* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint NodeID;
+
+
+void NodeID_Initialize(NodeID* pVal);
+
+#define ERR_NODEID		8513  /**/
+flag NodeID_IsConstraintValid(const NodeID* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_NODEID		8514  /**/
+#define NodeID_REQUIRED_BYTES_FOR_ENCODING       3
+#define NodeID_REQUIRED_BITS_FOR_ENCODING        24
+
+flag NodeID_Encode(const NodeID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_NODEID		8515  /**/
+flag NodeID_Decode(NodeID* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint EndpointID;
+
+
+void EndpointID_Initialize(EndpointID* pVal);
+
+#define ERR_ENDPOINTID		8520  /**/
+flag EndpointID_IsConstraintValid(const EndpointID* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_ENDPOINTID		8521  /**/
+#define EndpointID_REQUIRED_BYTES_FOR_ENCODING       1
+#define EndpointID_REQUIRED_BITS_FOR_ENCODING        8
+
+flag EndpointID_Encode(const EndpointID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_ENDPOINTID		8522  /**/
+flag EndpointID_Decode(EndpointID* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    success = 0,
+    error_node_id = 1,
+    error_endpoint_id = 2,
+    error_unsupported = 3,
+    error_state = 4,
+    error_value = 5,
+    error_other = 6
+} ResultCode;
+
+// please use the following macros to avoid breaking code.
+#define ResultCode_success success
+#define ResultCode_error_node_id error_node_id
+#define ResultCode_error_endpoint_id error_endpoint_id
+#define ResultCode_error_unsupported error_unsupported
+#define ResultCode_error_state error_state
+#define ResultCode_error_value error_value
+#define ResultCode_error_other error_other
+
+void ResultCode_Initialize(ResultCode* pVal);
+
+#define ERR_RESULTCODE		8538  /**/
+flag ResultCode_IsConstraintValid(const ResultCode* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_RESULTCODE		8539  /**/
+#define ResultCode_REQUIRED_BYTES_FOR_ENCODING       1
+#define ResultCode_REQUIRED_BITS_FOR_ENCODING        3
+
+flag ResultCode_Encode(const ResultCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_RESULTCODE		8540  /**/
+flag ResultCode_Decode(ResultCode* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CommandResponse --------------------------------------------*/
+typedef struct {
+    ResultCode result;
+    T_String message;
+
+} CommandResponse;
+
+void CommandResponse_Initialize(CommandResponse* pVal);
+
+#define ERR_COMMANDRESPONSE		8567  /**/
+#define ERR_COMMANDRESPONSE_RESULT		8545  /**/
+#define ERR_COMMANDRESPONSE_MESSAGE		8556  /**/
+flag CommandResponse_IsConstraintValid(const CommandResponse* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_COMMANDRESPONSE		8568  /**/
+#define ERR_UPER_ENCODE_COMMANDRESPONSE_RESULT_2		8552  /**/
+#define ERR_UPER_ENCODE_COMMANDRESPONSE_MESSAGE_2		8563  /**/
+#define CommandResponse_REQUIRED_BYTES_FOR_ENCODING       42
+#define CommandResponse_REQUIRED_BITS_FOR_ENCODING        329
+
+flag CommandResponse_Encode(const CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_COMMANDRESPONSE		8569  /**/
+#define ERR_UPER_DECODE_COMMANDRESPONSE_RESULT_2		8553  /**/
+#define ERR_UPER_DECODE_COMMANDRESPONSE_MESSAGE_2		8564  /**/
+flag CommandResponse_Decode(CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/DepthMap.c b/generated/DepthMap.c
new file mode 100644
index 0000000..4680e4d
--- /dev/null
+++ b/generated/DepthMap.c
@@ -0,0 +1,224 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/DepthMap.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Depth_format_t_Initialize(Depth_format_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = depth_f;
+}
+
+flag Depth_format_t_IsConstraintValid(const Depth_format_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) == depth_f);
+    *pErrCode = ret ? 0 :  ERR_DEPTH_FORMAT_T;
+
+	return ret;
+}
+
+flag Depth_format_t_Encode(const Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Depth_format_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case depth_f:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_DEPTH_FORMAT_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Depth_format_t_Decode(Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DEPTH_FORMAT_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = depth_f;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_DEPTH_FORMAT_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = depth_f;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Depth_format_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void DepthMapDescriptor_Initialize(DepthMapDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set depth_format */
+	Depth_format_t_Initialize((&(pVal->depth_format)));
+	/*set depth_size */
+	T_UInt8_Initialize((&(pVal->depth_size)));
+	/*set width */
+	T_UInt16_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt16_Initialize((&(pVal->height)));
+}
+
+flag DepthMapDescriptor_IsConstraintValid(const DepthMapDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->depth_format == depth_f);
+        *pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT;
+        if (ret) {
+            ret = (pVal->depth_size <= 255UL);
+            *pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_DEPTH_SIZE;
+            if (ret) {
+                ret = (pVal->width <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_WIDTH;
+                if (ret) {
+                    ret = (pVal->height <= 65535UL);
+                    *pErrCode = ret ? 0 :  ERR_DEPTHMAPDESCRIPTOR_HEIGHT;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag DepthMapDescriptor_Encode(const DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? DepthMapDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode depth_format */
+	        ret = Depth_format_t_Encode((&(pVal->depth_format)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode depth_size */
+	            ret = T_UInt8_Encode((&(pVal->depth_size)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode width */
+	                ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode height */
+	                    ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag DepthMapDescriptor_Decode(DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode depth_format */
+	    ret = Depth_format_t_Decode((&(pVal->depth_format)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode depth_size */
+	        ret = T_UInt8_Decode((&(pVal->depth_size)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode width */
+	            ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode height */
+	                ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && DepthMapDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/DepthMap.h b/generated/DepthMap.h
new file mode 100644
index 0000000..171e1db
--- /dev/null
+++ b/generated/DepthMap.h
@@ -0,0 +1,105 @@
+#ifndef GENERATED_ASN1SCC_DepthMap_H
+#define GENERATED_ASN1SCC_DepthMap_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/Region.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    depth_f = 0
+} Depth_format_t;
+
+// please use the following macros to avoid breaking code.
+#define Depth_format_t_depth_f depth_f
+
+void Depth_format_t_Initialize(Depth_format_t* pVal);
+
+#define ERR_DEPTH_FORMAT_T		8874  /**/
+flag Depth_format_t_IsConstraintValid(const Depth_format_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_DEPTH_FORMAT_T		8875  /**/
+#define Depth_format_t_REQUIRED_BYTES_FOR_ENCODING       0
+#define Depth_format_t_REQUIRED_BITS_FOR_ENCODING        0
+
+flag Depth_format_t_Encode(const Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_DEPTH_FORMAT_T		8876  /**/
+flag Depth_format_t_Decode(Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- DepthMapDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Depth_format_t depth_format;
+    T_UInt8 depth_size;
+    T_UInt16 width;
+    T_UInt16 height;
+
+} DepthMapDescriptor;
+
+void DepthMapDescriptor_Initialize(DepthMapDescriptor* pVal);
+
+#define ERR_DEPTHMAPDESCRIPTOR		9046  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES		8991  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_TIMESTAMP		8881  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_VALIDITY		8896  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		8984  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		8973  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		8907  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		8962  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		8918  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		8929  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		8940  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		8951  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT		9002  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_DEPTH_SIZE		9013  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_WIDTH		9024  /**/
+#define ERR_DEPTHMAPDESCRIPTOR_HEIGHT		9035  /**/
+flag DepthMapDescriptor_IsConstraintValid(const DepthMapDescriptor* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR		9047  /**/
+#define ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_ATTRIBUTES_2		8998  /**/
+#define ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT_2		9009  /**/
+#define ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_DEPTH_SIZE_2		9020  /**/
+#define ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_WIDTH_2		9031  /**/
+#define ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_HEIGHT_2		9042  /**/
+#define DepthMapDescriptor_REQUIRED_BYTES_FOR_ENCODING       71
+#define DepthMapDescriptor_REQUIRED_BITS_FOR_ENCODING        565
+
+flag DepthMapDescriptor_Encode(const DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR		9048  /**/
+#define ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_ATTRIBUTES_2		8999  /**/
+#define ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT_2		9010  /**/
+#define ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_DEPTH_SIZE_2		9021  /**/
+#define ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_WIDTH_2		9032  /**/
+#define ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_HEIGHT_2		9043  /**/
+flag DepthMapDescriptor_Decode(DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Flash.c b/generated/Flash.c
new file mode 100644
index 0000000..e1729c8
--- /dev/null
+++ b/generated/Flash.c
@@ -0,0 +1,83 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Flash.hpp>
+namespace i3ds_asn1 {
+
+
+
+void FlashSetup_Initialize(FlashSetup* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set duration */
+	T_UInt32_Initialize((&(pVal->duration)));
+	/*set strength */
+	T_UInt8_Initialize((&(pVal->strength)));
+}
+
+flag FlashSetup_IsConstraintValid(const FlashSetup* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->duration <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_FLASHSETUP_DURATION;
+    if (ret) {
+        ret = (pVal->strength <= 255UL);
+        *pErrCode = ret ? 0 :  ERR_FLASHSETUP_STRENGTH;
+    }
+
+	return ret;
+}
+
+flag FlashSetup_Encode(const FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? FlashSetup_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode duration */
+	    ret = ShutterTime_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode strength */
+	        ret = FlashStrength_Encode((&(pVal->strength)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag FlashSetup_Decode(FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode duration */
+	ret = ShutterTime_Decode((&(pVal->duration)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode strength */
+	    ret = FlashStrength_Decode((&(pVal->strength)), pBitStrm, pErrCode);
+	}
+
+	return ret  && FlashSetup_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Flash.h b/generated/Flash.h
new file mode 100644
index 0000000..ca17944
--- /dev/null
+++ b/generated/Flash.h
@@ -0,0 +1,60 @@
+#ifndef GENERATED_ASN1SCC_Flash_H
+#define GENERATED_ASN1SCC_Flash_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Camera.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- FlashSetup --------------------------------------------*/
+typedef struct {
+    T_UInt32 duration;
+    T_UInt8 strength;
+
+} FlashSetup;
+
+void FlashSetup_Initialize(FlashSetup* pVal);
+
+#define ERR_FLASHSETUP		11709  /**/
+#define ERR_FLASHSETUP_DURATION		11679  /**/
+#define ERR_FLASHSETUP_STRENGTH		11694  /**/
+flag FlashSetup_IsConstraintValid(const FlashSetup* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_FLASHSETUP		11710  /**/
+#define ERR_UPER_ENCODE_FLASHSETUP_DURATION_2_2		11690  /**/
+#define ERR_UPER_ENCODE_FLASHSETUP_STRENGTH_2_2		11705  /**/
+#define FlashSetup_REQUIRED_BYTES_FOR_ENCODING       5
+#define FlashSetup_REQUIRED_BITS_FOR_ENCODING        40
+
+flag FlashSetup_Encode(const FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_FLASHSETUP		11711  /**/
+#define ERR_UPER_DECODE_FLASHSETUP_DURATION_2_2		11691  /**/
+#define ERR_UPER_DECODE_FLASHSETUP_STRENGTH_2_2		11706  /**/
+flag FlashSetup_Decode(FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Frame.c b/generated/Frame.c
new file mode 100644
index 0000000..1f8ab19
--- /dev/null
+++ b/generated/Frame.c
@@ -0,0 +1,328 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Frame.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Frame_mode_t_Initialize(Frame_mode_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = mode_undefined;
+}
+
+flag Frame_mode_t_IsConstraintValid(const Frame_mode_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((((((((((((((((*(pVal)) == mode_undefined)) || (((*(pVal)) == mode_mono)))) || (((*(pVal)) == mode_rgb)))) || (((*(pVal)) == mode_bgr)))) || (((*(pVal)) == mode_uyvy)))) || (((*(pVal)) == mode_rgba)))) || (((*(pVal)) == mode_bayer_rggb)))) || (((*(pVal)) == mode_bayer_grbg)))) || (((*(pVal)) == mode_bayer_bggr)))) || (((*(pVal)) == mode_bayer_gbrg)))) || (((*(pVal)) == mode_pjpg)))) || (((*(pVal)) == mode_jpeg)))) || (((*(pVal)) == mode_png)))) || (((*(pVal)) == mode_tiff)));
+    *pErrCode = ret ? 0 :  ERR_FRAME_MODE_T;
+
+	return ret;
+}
+
+flag Frame_mode_t_Encode(const Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case mode_undefined:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 13);
+	        	break;
+	        case mode_mono:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 13);
+	        	break;
+	        case mode_rgb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 13);
+	        	break;
+	        case mode_bgr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 13);
+	        	break;
+	        case mode_uyvy:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 13);
+	        	break;
+	        case mode_rgba:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 13);
+	        	break;
+	        case mode_bayer_rggb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 13);
+	        	break;
+	        case mode_bayer_grbg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 13);
+	        	break;
+	        case mode_bayer_bggr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 13);
+	        	break;
+	        case mode_bayer_gbrg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 13);
+	        	break;
+	        case mode_pjpg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 13);
+	        	break;
+	        case mode_jpeg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 13);
+	        	break;
+	        case mode_png:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 13);
+	        	break;
+	        case mode_tiff:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 13);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_FRAME_MODE_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Frame_mode_t_Decode(Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 13);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_FRAME_MODE_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = mode_undefined;
+	                break;
+	            case 1:
+	                (*(pVal)) = mode_mono;
+	                break;
+	            case 2:
+	                (*(pVal)) = mode_rgb;
+	                break;
+	            case 3:
+	                (*(pVal)) = mode_bgr;
+	                break;
+	            case 4:
+	                (*(pVal)) = mode_uyvy;
+	                break;
+	            case 5:
+	                (*(pVal)) = mode_rgba;
+	                break;
+	            case 6:
+	                (*(pVal)) = mode_bayer_rggb;
+	                break;
+	            case 7:
+	                (*(pVal)) = mode_bayer_grbg;
+	                break;
+	            case 8:
+	                (*(pVal)) = mode_bayer_bggr;
+	                break;
+	            case 9:
+	                (*(pVal)) = mode_bayer_gbrg;
+	                break;
+	            case 10:
+	                (*(pVal)) = mode_pjpg;
+	                break;
+	            case 11:
+	                (*(pVal)) = mode_jpeg;
+	                break;
+	            case 12:
+	                (*(pVal)) = mode_png;
+	                break;
+	            case 13:
+	                (*(pVal)) = mode_tiff;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_FRAME_MODE_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = mode_undefined;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Frame_mode_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void FrameDescriptor_Initialize(FrameDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set frame_mode */
+	Frame_mode_t_Initialize((&(pVal->frame_mode)));
+	/*set data_depth */
+	T_UInt8_Initialize((&(pVal->data_depth)));
+	/*set pixel_size */
+	T_UInt8_Initialize((&(pVal->pixel_size)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+	/*set image_count */
+	T_UInt8_Initialize((&(pVal->image_count)));
+}
+
+flag FrameDescriptor_IsConstraintValid(const FrameDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (((((((((((((((((((((((((((pVal->frame_mode == mode_undefined)) || ((pVal->frame_mode == mode_mono)))) || ((pVal->frame_mode == mode_rgb)))) || ((pVal->frame_mode == mode_bgr)))) || ((pVal->frame_mode == mode_uyvy)))) || ((pVal->frame_mode == mode_rgba)))) || ((pVal->frame_mode == mode_bayer_rggb)))) || ((pVal->frame_mode == mode_bayer_grbg)))) || ((pVal->frame_mode == mode_bayer_bggr)))) || ((pVal->frame_mode == mode_bayer_gbrg)))) || ((pVal->frame_mode == mode_pjpg)))) || ((pVal->frame_mode == mode_jpeg)))) || ((pVal->frame_mode == mode_png)))) || ((pVal->frame_mode == mode_tiff)));
+        *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_FRAME_MODE;
+        if (ret) {
+            ret = (pVal->data_depth <= 255UL);
+            *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_DATA_DEPTH;
+            if (ret) {
+                ret = (pVal->pixel_size <= 255UL);
+                *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_PIXEL_SIZE;
+                if (ret) {
+                    ret = (pVal->region.offset_x <= 65535UL);
+                    *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_REGION_OFFSET_X;
+                    if (ret) {
+                        ret = (pVal->region.offset_y <= 65535UL);
+                        *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_REGION_OFFSET_Y;
+                        if (ret) {
+                            ret = (pVal->region.size_x <= 65535UL);
+                            *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_REGION_SIZE_X;
+                            if (ret) {
+                                ret = (pVal->region.size_y <= 65535UL);
+                                *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_REGION_SIZE_Y;
+                            }
+                        }
+                    }
+                    if (ret) {
+                        ret = (pVal->image_count <= 255UL);
+                        *pErrCode = ret ? 0 :  ERR_FRAMEDESCRIPTOR_IMAGE_COUNT;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag FrameDescriptor_Encode(const FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? FrameDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode frame_mode */
+	        ret = Frame_mode_t_Encode((&(pVal->frame_mode)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode data_depth */
+	            ret = T_UInt8_Encode((&(pVal->data_depth)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode pixel_size */
+	                ret = T_UInt8_Encode((&(pVal->pixel_size)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode region */
+	                    ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode image_count */
+	                        ret = T_UInt8_Encode((&(pVal->image_count)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag FrameDescriptor_Decode(FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode frame_mode */
+	    ret = Frame_mode_t_Decode((&(pVal->frame_mode)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode data_depth */
+	        ret = T_UInt8_Decode((&(pVal->data_depth)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode pixel_size */
+	            ret = T_UInt8_Decode((&(pVal->pixel_size)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode region */
+	                ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode image_count */
+	                    ret = T_UInt8_Decode((&(pVal->image_count)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && FrameDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Frame.h b/generated/Frame.h
new file mode 100644
index 0000000..e6006fe
--- /dev/null
+++ b/generated/Frame.h
@@ -0,0 +1,139 @@
+#ifndef GENERATED_ASN1SCC_Frame_H
+#define GENERATED_ASN1SCC_Frame_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    mode_undefined = 0,
+    mode_mono = 1,
+    mode_rgb = 2,
+    mode_bgr = 3,
+    mode_uyvy = 4,
+    mode_rgba = 5,
+    mode_bayer_rggb = 6,
+    mode_bayer_grbg = 7,
+    mode_bayer_bggr = 8,
+    mode_bayer_gbrg = 9,
+    mode_pjpg = 10,
+    mode_jpeg = 11,
+    mode_png = 12,
+    mode_tiff = 13
+} Frame_mode_t;
+
+// please use the following macros to avoid breaking code.
+#define Frame_mode_t_mode_undefined mode_undefined
+#define Frame_mode_t_mode_mono mode_mono
+#define Frame_mode_t_mode_rgb mode_rgb
+#define Frame_mode_t_mode_bgr mode_bgr
+#define Frame_mode_t_mode_uyvy mode_uyvy
+#define Frame_mode_t_mode_rgba mode_rgba
+#define Frame_mode_t_mode_bayer_rggb mode_bayer_rggb
+#define Frame_mode_t_mode_bayer_grbg mode_bayer_grbg
+#define Frame_mode_t_mode_bayer_bggr mode_bayer_bggr
+#define Frame_mode_t_mode_bayer_gbrg mode_bayer_gbrg
+#define Frame_mode_t_mode_pjpg mode_pjpg
+#define Frame_mode_t_mode_jpeg mode_jpeg
+#define Frame_mode_t_mode_png mode_png
+#define Frame_mode_t_mode_tiff mode_tiff
+
+void Frame_mode_t_Initialize(Frame_mode_t* pVal);
+
+#define ERR_FRAME_MODE_T		9909  /**/
+flag Frame_mode_t_IsConstraintValid(const Frame_mode_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_FRAME_MODE_T		9910  /**/
+#define Frame_mode_t_REQUIRED_BYTES_FOR_ENCODING       1
+#define Frame_mode_t_REQUIRED_BITS_FOR_ENCODING        4
+
+flag Frame_mode_t_Encode(const Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_FRAME_MODE_T		9911  /**/
+flag Frame_mode_t_Decode(Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- FrameDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Frame_mode_t frame_mode;
+    T_UInt8 data_depth;
+    T_UInt8 pixel_size;
+    PlanarRegion region;
+    T_UInt8 image_count;
+
+} FrameDescriptor;
+
+void FrameDescriptor_Initialize(FrameDescriptor* pVal);
+
+#define ERR_FRAMEDESCRIPTOR		10136  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES		10026  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_TIMESTAMP		9916  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_VALIDITY		9931  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		10019  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		10008  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		9942  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		9997  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		9953  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		9964  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		9975  /**/
+#define ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		9986  /**/
+#define ERR_FRAMEDESCRIPTOR_FRAME_MODE		10037  /**/
+#define ERR_FRAMEDESCRIPTOR_DATA_DEPTH		10048  /**/
+#define ERR_FRAMEDESCRIPTOR_PIXEL_SIZE		10059  /**/
+#define ERR_FRAMEDESCRIPTOR_REGION		10114  /**/
+#define ERR_FRAMEDESCRIPTOR_REGION_OFFSET_X		10070  /**/
+#define ERR_FRAMEDESCRIPTOR_REGION_OFFSET_Y		10081  /**/
+#define ERR_FRAMEDESCRIPTOR_REGION_SIZE_X		10092  /**/
+#define ERR_FRAMEDESCRIPTOR_REGION_SIZE_Y		10103  /**/
+#define ERR_FRAMEDESCRIPTOR_IMAGE_COUNT		10125  /**/
+flag FrameDescriptor_IsConstraintValid(const FrameDescriptor* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_FRAMEDESCRIPTOR		10137  /**/
+#define ERR_UPER_ENCODE_FRAMEDESCRIPTOR_ATTRIBUTES_2		10033  /**/
+#define ERR_UPER_ENCODE_FRAMEDESCRIPTOR_FRAME_MODE_2		10044  /**/
+#define ERR_UPER_ENCODE_FRAMEDESCRIPTOR_DATA_DEPTH_2		10055  /**/
+#define ERR_UPER_ENCODE_FRAMEDESCRIPTOR_PIXEL_SIZE_2		10066  /**/
+#define ERR_UPER_ENCODE_FRAMEDESCRIPTOR_REGION_2		10121  /**/
+#define ERR_UPER_ENCODE_FRAMEDESCRIPTOR_IMAGE_COUNT_2		10132  /**/
+#define FrameDescriptor_REQUIRED_BYTES_FOR_ENCODING       78
+#define FrameDescriptor_REQUIRED_BITS_FOR_ENCODING        617
+
+flag FrameDescriptor_Encode(const FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_FRAMEDESCRIPTOR		10138  /**/
+#define ERR_UPER_DECODE_FRAMEDESCRIPTOR_ATTRIBUTES_2		10034  /**/
+#define ERR_UPER_DECODE_FRAMEDESCRIPTOR_FRAME_MODE_2		10045  /**/
+#define ERR_UPER_DECODE_FRAMEDESCRIPTOR_DATA_DEPTH_2		10056  /**/
+#define ERR_UPER_DECODE_FRAMEDESCRIPTOR_PIXEL_SIZE_2		10067  /**/
+#define ERR_UPER_DECODE_FRAMEDESCRIPTOR_REGION_2		10122  /**/
+#define ERR_UPER_DECODE_FRAMEDESCRIPTOR_IMAGE_COUNT_2		10133  /**/
+flag FrameDescriptor_Decode(FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/IMU.c b/generated/IMU.c
new file mode 100644
index 0000000..b899a7a
--- /dev/null
+++ b/generated/IMU.c
@@ -0,0 +1,300 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/IMU.hpp>
+namespace i3ds_asn1 {
+
+
+
+void IMUSample_Initialize(IMUSample* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set axis_x_rate */
+	T_Double_Initialize((&(pVal->axis_x_rate)));
+	/*set axis_x_acceleration */
+	T_Double_Initialize((&(pVal->axis_x_acceleration)));
+	/*set axis_y_rate */
+	T_Double_Initialize((&(pVal->axis_y_rate)));
+	/*set axis_y_acceleration */
+	T_Double_Initialize((&(pVal->axis_y_acceleration)));
+	/*set axis_z_rate */
+	T_Double_Initialize((&(pVal->axis_z_rate)));
+	/*set axis_z_acceleration */
+	T_Double_Initialize((&(pVal->axis_z_acceleration)));
+}
+
+flag IMUSample_IsConstraintValid(const IMUSample* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->axis_x_rate) && (pVal->axis_x_rate <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_X_RATE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->axis_x_acceleration) && (pVal->axis_x_acceleration <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_X_ACCELERATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->axis_y_rate) && (pVal->axis_y_rate <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Y_RATE;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->axis_y_acceleration) && (pVal->axis_y_acceleration <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Y_ACCELERATION;
+                if (ret) {
+                    ret = ((-1.79769313486231570000E+308 <= pVal->axis_z_rate) && (pVal->axis_z_rate <= 1.79769313486231570000E+308));
+                    *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Z_RATE;
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->axis_z_acceleration) && (pVal->axis_z_acceleration <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Z_ACCELERATION;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag IMUSample_Encode(const IMUSample* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? IMUSample_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode axis_x_rate */
+	    ret = T_Double_Encode((&(pVal->axis_x_rate)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode axis_x_acceleration */
+	        ret = T_Double_Encode((&(pVal->axis_x_acceleration)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode axis_y_rate */
+	            ret = T_Double_Encode((&(pVal->axis_y_rate)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode axis_y_acceleration */
+	                ret = T_Double_Encode((&(pVal->axis_y_acceleration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode axis_z_rate */
+	                    ret = T_Double_Encode((&(pVal->axis_z_rate)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode axis_z_acceleration */
+	                        ret = T_Double_Encode((&(pVal->axis_z_acceleration)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag IMUSample_Decode(IMUSample* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode axis_x_rate */
+	ret = T_Double_Decode((&(pVal->axis_x_rate)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode axis_x_acceleration */
+	    ret = T_Double_Decode((&(pVal->axis_x_acceleration)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode axis_y_rate */
+	        ret = T_Double_Decode((&(pVal->axis_y_rate)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode axis_y_acceleration */
+	            ret = T_Double_Decode((&(pVal->axis_y_acceleration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode axis_z_rate */
+	                ret = T_Double_Decode((&(pVal->axis_z_rate)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode axis_z_acceleration */
+	                    ret = T_Double_Decode((&(pVal->axis_z_acceleration)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && IMUSample_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void IMUMeasurement20_samples_Initialize(IMUMeasurement20_samples* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 20) {
+	    IMUSample_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 0;
+}
+void IMUMeasurement20_Initialize(IMUMeasurement20* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set samples */
+	IMUMeasurement20_samples_Initialize((&(pVal->samples)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+}
+
+flag IMUMeasurement20_IsConstraintValid(const IMUMeasurement20* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->samples.nCount <= 20);
+        *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->samples.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_x_rate) && (pVal->samples.arr[i1].axis_x_rate <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_RATE;
+            	if (ret) {
+            	    ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_x_acceleration) && (pVal->samples.arr[i1].axis_x_acceleration <= 1.79769313486231570000E+308));
+            	    *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_ACCELERATION;
+            	    if (ret) {
+            	        ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_y_rate) && (pVal->samples.arr[i1].axis_y_rate <= 1.79769313486231570000E+308));
+            	        *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_RATE;
+            	        if (ret) {
+            	            ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_y_acceleration) && (pVal->samples.arr[i1].axis_y_acceleration <= 1.79769313486231570000E+308));
+            	            *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_ACCELERATION;
+            	            if (ret) {
+            	                ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_z_rate) && (pVal->samples.arr[i1].axis_z_rate <= 1.79769313486231570000E+308));
+            	                *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_RATE;
+            	                if (ret) {
+            	                    ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_z_acceleration) && (pVal->samples.arr[i1].axis_z_acceleration <= 1.79769313486231570000E+308));
+            	                    *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_ACCELERATION;
+            	                }
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+        if (ret) {
+            ret = (pVal->batch_size <= 4294967295UL);
+            *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_BATCH_SIZE;
+        }
+    }
+
+	return ret;
+}
+
+flag IMUMeasurement20_Encode(const IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? IMUMeasurement20_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode samples */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->samples.nCount, 0, 20);
+	        	
+	        for(i1=0; (i1 < (int)pVal->samples.nCount) && ret; i1++)
+	        {
+	        	ret = IMUSample_Encode((&(pVal->samples.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode batch_size */
+	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag IMUMeasurement20_Decode(IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode samples */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 20);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_IMUMEASUREMENT20_SAMPLES;
+	    pVal->samples.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->samples.nCount) && ret; i1++)
+	    {
+	    	ret = IMUSample_Decode((&(pVal->samples.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode batch_size */
+	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && IMUMeasurement20_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/IMU.h b/generated/IMU.h
new file mode 100644
index 0000000..b0438af
--- /dev/null
+++ b/generated/IMU.h
@@ -0,0 +1,136 @@
+#ifndef GENERATED_ASN1SCC_IMU_H
+#define GENERATED_ASN1SCC_IMU_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Sensor.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- IMUSample --------------------------------------------*/
+typedef struct {
+    T_Double axis_x_rate;
+    T_Double axis_x_acceleration;
+    T_Double axis_y_rate;
+    T_Double axis_y_acceleration;
+    T_Double axis_z_rate;
+    T_Double axis_z_acceleration;
+
+} IMUSample;
+
+void IMUSample_Initialize(IMUSample* pVal);
+
+#define ERR_IMUSAMPLE		8640  /**/
+#define ERR_IMUSAMPLE_AXIS_X_RATE		8574  /**/
+#define ERR_IMUSAMPLE_AXIS_X_ACCELERATION		8585  /**/
+#define ERR_IMUSAMPLE_AXIS_Y_RATE		8596  /**/
+#define ERR_IMUSAMPLE_AXIS_Y_ACCELERATION		8607  /**/
+#define ERR_IMUSAMPLE_AXIS_Z_RATE		8618  /**/
+#define ERR_IMUSAMPLE_AXIS_Z_ACCELERATION		8629  /**/
+flag IMUSample_IsConstraintValid(const IMUSample* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_IMUSAMPLE		8641  /**/
+#define ERR_UPER_ENCODE_IMUSAMPLE_AXIS_X_RATE_2		8581  /**/
+#define ERR_UPER_ENCODE_IMUSAMPLE_AXIS_X_ACCELERATION_2		8592  /**/
+#define ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Y_RATE_2		8603  /**/
+#define ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Y_ACCELERATION_2		8614  /**/
+#define ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Z_RATE_2		8625  /**/
+#define ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Z_ACCELERATION_2		8636  /**/
+#define IMUSample_REQUIRED_BYTES_FOR_ENCODING       78
+#define IMUSample_REQUIRED_BITS_FOR_ENCODING        624
+
+flag IMUSample_Encode(const IMUSample* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_IMUSAMPLE		8642  /**/
+#define ERR_UPER_DECODE_IMUSAMPLE_AXIS_X_RATE_2		8582  /**/
+#define ERR_UPER_DECODE_IMUSAMPLE_AXIS_X_ACCELERATION_2		8593  /**/
+#define ERR_UPER_DECODE_IMUSAMPLE_AXIS_Y_RATE_2		8604  /**/
+#define ERR_UPER_DECODE_IMUSAMPLE_AXIS_Y_ACCELERATION_2		8615  /**/
+#define ERR_UPER_DECODE_IMUSAMPLE_AXIS_Z_RATE_2		8626  /**/
+#define ERR_UPER_DECODE_IMUSAMPLE_AXIS_Z_ACCELERATION_2		8637  /**/
+flag IMUSample_Decode(IMUSample* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- IMUMeasurement20 --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    IMUSample arr[20];
+} IMUMeasurement20_samples;
+typedef struct {
+    SampleAttributes attributes;
+    IMUMeasurement20_samples samples;
+    T_UInt32 batch_size;
+
+} IMUMeasurement20;
+
+void IMUMeasurement20_samples_Initialize(IMUMeasurement20_samples* pVal);
+void IMUMeasurement20_Initialize(IMUMeasurement20* pVal);
+
+#define ERR_IMUMEASUREMENT20		8867  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES		8757  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_TIMESTAMP		8647  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_VALIDITY		8662  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES		8750  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM		8739  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		8673  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		8728  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		8684  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		8695  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		8706  /**/
+#define ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		8717  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES		8845  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES_ELM		8834  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_RATE		8768  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_ACCELERATION		8779  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_RATE		8790  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_ACCELERATION		8801  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_RATE		8812  /**/
+#define ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_ACCELERATION		8823  /**/
+#define ERR_IMUMEASUREMENT20_BATCH_SIZE		8852  /**/
+flag IMUMeasurement20_IsConstraintValid(const IMUMeasurement20* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_IMUMEASUREMENT20		8868  /**/
+#define ERR_UPER_ENCODE_IMUMEASUREMENT20_ATTRIBUTES_2		8764  /**/
+#define ERR_UPER_ENCODE_IMUMEASUREMENT20_SAMPLES		8846  /**/
+#define ERR_UPER_ENCODE_IMUMEASUREMENT20_SAMPLES_ELM_2		8841  /**/
+#define ERR_UPER_ENCODE_IMUMEASUREMENT20_BATCH_SIZE_2_2		8863  /**/
+#define IMUMeasurement20_REQUIRED_BYTES_FOR_ENCODING       1631
+#define IMUMeasurement20_REQUIRED_BITS_FOR_ENCODING        13042
+
+flag IMUMeasurement20_Encode(const IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_IMUMEASUREMENT20		8869  /**/
+#define ERR_UPER_DECODE_IMUMEASUREMENT20_ATTRIBUTES_2		8765  /**/
+#define ERR_UPER_DECODE_IMUMEASUREMENT20_SAMPLES		8847  /**/
+#define ERR_UPER_DECODE_IMUMEASUREMENT20_SAMPLES_ELM_2		8842  /**/
+#define ERR_UPER_DECODE_IMUMEASUREMENT20_BATCH_SIZE_2_2		8864  /**/
+flag IMUMeasurement20_Decode(IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/LIDAR.c b/generated/LIDAR.c
new file mode 100644
index 0000000..a6367e9
--- /dev/null
+++ b/generated/LIDAR.c
@@ -0,0 +1,167 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/LIDAR.hpp>
+namespace i3ds_asn1 {
+
+
+
+void LIDARRegion_Initialize(LIDARRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PolarRegion_Initialize((&(pVal->region)));
+}
+
+flag LIDARRegion_IsConstraintValid(const LIDARRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_x) && (pVal->region.offset_x <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_y) && (pVal->region.offset_y <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->region.size_x) && (pVal->region.size_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->region.size_y) && (pVal->region.size_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag LIDARRegion_Encode(const LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? LIDARRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PolarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag LIDARRegion_Decode(LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PolarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && LIDARRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void LIDARConfiguration_Initialize(LIDARConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PolarRegion_Initialize((&(pVal->region)));
+}
+
+flag LIDARConfiguration_IsConstraintValid(const LIDARConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_x) && (pVal->region.offset_x <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_OFFSET_X;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_y) && (pVal->region.offset_y <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->region.size_x) && (pVal->region.size_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_SIZE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->region.size_y) && (pVal->region.size_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag LIDARConfiguration_Encode(const LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? LIDARConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode region_enabled */
+	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PolarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag LIDARConfiguration_Decode(LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode region_enabled */
+	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PolarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && LIDARConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/LIDAR.h b/generated/LIDAR.h
new file mode 100644
index 0000000..2a33c54
--- /dev/null
+++ b/generated/LIDAR.h
@@ -0,0 +1,95 @@
+#ifndef GENERATED_ASN1SCC_LIDAR_H
+#define GENERATED_ASN1SCC_LIDAR_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- LIDARRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PolarRegion region;
+
+} LIDARRegion;
+
+void LIDARRegion_Initialize(LIDARRegion* pVal);
+
+#define ERR_LIDARREGION		10209  /**/
+#define ERR_LIDARREGION_ENABLE		10143  /**/
+#define ERR_LIDARREGION_REGION		10198  /**/
+#define ERR_LIDARREGION_REGION_OFFSET_X		10154  /**/
+#define ERR_LIDARREGION_REGION_OFFSET_Y		10165  /**/
+#define ERR_LIDARREGION_REGION_SIZE_X		10176  /**/
+#define ERR_LIDARREGION_REGION_SIZE_Y		10187  /**/
+flag LIDARRegion_IsConstraintValid(const LIDARRegion* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_LIDARREGION		10210  /**/
+#define ERR_UPER_ENCODE_LIDARREGION_ENABLE_2		10150  /**/
+#define ERR_UPER_ENCODE_LIDARREGION_REGION_2		10205  /**/
+#define LIDARRegion_REQUIRED_BYTES_FOR_ENCODING       53
+#define LIDARRegion_REQUIRED_BITS_FOR_ENCODING        417
+
+flag LIDARRegion_Encode(const LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_LIDARREGION		10211  /**/
+#define ERR_UPER_DECODE_LIDARREGION_ENABLE_2		10151  /**/
+#define ERR_UPER_DECODE_LIDARREGION_REGION_2		10206  /**/
+flag LIDARRegion_Decode(LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- LIDARConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean region_enabled;
+    PolarRegion region;
+
+} LIDARConfiguration;
+
+void LIDARConfiguration_Initialize(LIDARConfiguration* pVal);
+
+#define ERR_LIDARCONFIGURATION		10282  /**/
+#define ERR_LIDARCONFIGURATION_REGION_ENABLED		10216  /**/
+#define ERR_LIDARCONFIGURATION_REGION		10271  /**/
+#define ERR_LIDARCONFIGURATION_REGION_OFFSET_X		10227  /**/
+#define ERR_LIDARCONFIGURATION_REGION_OFFSET_Y		10238  /**/
+#define ERR_LIDARCONFIGURATION_REGION_SIZE_X		10249  /**/
+#define ERR_LIDARCONFIGURATION_REGION_SIZE_Y		10260  /**/
+flag LIDARConfiguration_IsConstraintValid(const LIDARConfiguration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_LIDARCONFIGURATION		10283  /**/
+#define ERR_UPER_ENCODE_LIDARCONFIGURATION_REGION_ENABLED_2		10223  /**/
+#define ERR_UPER_ENCODE_LIDARCONFIGURATION_REGION_2		10278  /**/
+#define LIDARConfiguration_REQUIRED_BYTES_FOR_ENCODING       53
+#define LIDARConfiguration_REQUIRED_BITS_FOR_ENCODING        417
+
+flag LIDARConfiguration_Encode(const LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_LIDARCONFIGURATION		10284  /**/
+#define ERR_UPER_DECODE_LIDARCONFIGURATION_REGION_ENABLED_2		10224  /**/
+#define ERR_UPER_DECODE_LIDARCONFIGURATION_REGION_2		10279  /**/
+flag LIDARConfiguration_Decode(LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/PointCloud.c b/generated/PointCloud.c
new file mode 100644
index 0000000..2287320
--- /dev/null
+++ b/generated/PointCloud.c
@@ -0,0 +1,224 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/PointCloud.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Point_format_t_Initialize(Point_format_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = fields_xyz_f;
+}
+
+flag Point_format_t_IsConstraintValid(const Point_format_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) == fields_xyz_f);
+    *pErrCode = ret ? 0 :  ERR_POINT_FORMAT_T;
+
+	return ret;
+}
+
+flag Point_format_t_Encode(const Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Point_format_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case fields_xyz_f:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_POINT_FORMAT_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Point_format_t_Decode(Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_POINT_FORMAT_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = fields_xyz_f;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_POINT_FORMAT_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = fields_xyz_f;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Point_format_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PointCloudDescriptor_Initialize(PointCloudDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set point_format */
+	Point_format_t_Initialize((&(pVal->point_format)));
+	/*set point_size */
+	T_UInt16_Initialize((&(pVal->point_size)));
+	/*set width */
+	T_UInt32_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt32_Initialize((&(pVal->height)));
+}
+
+flag PointCloudDescriptor_IsConstraintValid(const PointCloudDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->point_format == fields_xyz_f);
+        *pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_POINT_FORMAT;
+        if (ret) {
+            ret = (pVal->point_size <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_POINT_SIZE;
+            if (ret) {
+                ret = (pVal->width <= 4294967295UL);
+                *pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_WIDTH;
+                if (ret) {
+                    ret = (pVal->height <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  ERR_POINTCLOUDDESCRIPTOR_HEIGHT;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PointCloudDescriptor_Encode(const PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PointCloudDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode point_format */
+	        ret = Point_format_t_Encode((&(pVal->point_format)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode point_size */
+	            ret = T_UInt16_Encode((&(pVal->point_size)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode width */
+	                ret = T_UInt32_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode height */
+	                    ret = T_UInt32_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PointCloudDescriptor_Decode(PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode point_format */
+	    ret = Point_format_t_Decode((&(pVal->point_format)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode point_size */
+	        ret = T_UInt16_Decode((&(pVal->point_size)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode width */
+	            ret = T_UInt32_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode height */
+	                ret = T_UInt32_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && PointCloudDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/PointCloud.h b/generated/PointCloud.h
new file mode 100644
index 0000000..6aec9df
--- /dev/null
+++ b/generated/PointCloud.h
@@ -0,0 +1,105 @@
+#ifndef GENERATED_ASN1SCC_PointCloud_H
+#define GENERATED_ASN1SCC_PointCloud_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/Region.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    fields_xyz_f = 0
+} Point_format_t;
+
+// please use the following macros to avoid breaking code.
+#define Point_format_t_fields_xyz_f fields_xyz_f
+
+void Point_format_t_Initialize(Point_format_t* pVal);
+
+#define ERR_POINT_FORMAT_T		9053  /**/
+flag Point_format_t_IsConstraintValid(const Point_format_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POINT_FORMAT_T		9054  /**/
+#define Point_format_t_REQUIRED_BYTES_FOR_ENCODING       0
+#define Point_format_t_REQUIRED_BITS_FOR_ENCODING        0
+
+flag Point_format_t_Encode(const Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POINT_FORMAT_T		9055  /**/
+flag Point_format_t_Decode(Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PointCloudDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Point_format_t point_format;
+    T_UInt16 point_size;
+    T_UInt32 width;
+    T_UInt32 height;
+
+} PointCloudDescriptor;
+
+void PointCloudDescriptor_Initialize(PointCloudDescriptor* pVal);
+
+#define ERR_POINTCLOUDDESCRIPTOR		9225  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES		9170  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_TIMESTAMP		9060  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_VALIDITY		9075  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		9163  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		9152  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		9086  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		9141  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		9097  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		9108  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		9119  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		9130  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_POINT_FORMAT		9181  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_POINT_SIZE		9192  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_WIDTH		9203  /**/
+#define ERR_POINTCLOUDDESCRIPTOR_HEIGHT		9214  /**/
+flag PointCloudDescriptor_IsConstraintValid(const PointCloudDescriptor* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR		9226  /**/
+#define ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_ATTRIBUTES_2		9177  /**/
+#define ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_POINT_FORMAT_2		9188  /**/
+#define ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_POINT_SIZE_2		9199  /**/
+#define ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_WIDTH_2		9210  /**/
+#define ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_HEIGHT_2		9221  /**/
+#define PointCloudDescriptor_REQUIRED_BYTES_FOR_ENCODING       76
+#define PointCloudDescriptor_REQUIRED_BITS_FOR_ENCODING        605
+
+flag PointCloudDescriptor_Encode(const PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR		9227  /**/
+#define ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_ATTRIBUTES_2		9178  /**/
+#define ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_POINT_FORMAT_2		9189  /**/
+#define ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_POINT_SIZE_2		9200  /**/
+#define ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_WIDTH_2		9211  /**/
+#define ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_HEIGHT_2		9222  /**/
+flag PointCloudDescriptor_Decode(PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/PoseEstimator.c b/generated/PoseEstimator.c
new file mode 100644
index 0000000..f061966
--- /dev/null
+++ b/generated/PoseEstimator.c
@@ -0,0 +1,301 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/PoseEstimator.hpp>
+namespace i3ds_asn1 {
+
+
+
+void PoseEstimatorMeasurement_Initialize(PoseEstimatorMeasurement* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set estimated_pose */
+	Base_Pose_Initialize((&(pVal->estimated_pose)));
+}
+
+flag PoseEstimatorMeasurement_IsConstraintValid(const PoseEstimatorMeasurement* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->estimated_pose.position.data.nCount) && (pVal->estimated_pose.position.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->estimated_pose.position.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->estimated_pose.position.data.arr[i1]) && (pVal->estimated_pose.position.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->estimated_pose.orientation.im.nCount) && (pVal->estimated_pose.orientation.im.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->estimated_pose.orientation.im.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->estimated_pose.orientation.im.arr[i1]) && (pVal->estimated_pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->estimated_pose.orientation.re) && (pVal->estimated_pose.orientation.re <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_RE;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PoseEstimatorMeasurement_Encode(const PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorMeasurement_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode estimated_pose */
+	        ret = Base_Pose_Encode((&(pVal->estimated_pose)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorMeasurement_Decode(PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode estimated_pose */
+	    ret = Base_Pose_Decode((&(pVal->estimated_pose)), pBitStrm, pErrCode);
+	}
+
+	return ret  && PoseEstimatorMeasurement_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PoseEstimatorImagingMode_Initialize(PoseEstimatorImagingMode* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set imaging_mode */
+	T_Boolean_Initialize((&(pVal->imaging_mode)));
+}
+
+flag PoseEstimatorImagingMode_IsConstraintValid(const PoseEstimatorImagingMode* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag PoseEstimatorImagingMode_Encode(const PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorImagingMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode imaging_mode */
+	    ret = T_Boolean_Encode((&(pVal->imaging_mode)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorImagingMode_Decode(PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode imaging_mode */
+	ret = T_Boolean_Decode((&(pVal->imaging_mode)), pBitStrm, pErrCode);
+
+	return ret  && PoseEstimatorImagingMode_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PoseEstimatorCameraSelect_Initialize(PoseEstimatorCameraSelect* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set camera_select */
+	T_UInt8_Initialize((&(pVal->camera_select)));
+}
+
+flag PoseEstimatorCameraSelect_IsConstraintValid(const PoseEstimatorCameraSelect* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->camera_select <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_POSEESTIMATORCAMERASELECT_CAMERA_SELECT;
+
+	return ret;
+}
+
+flag PoseEstimatorCameraSelect_Encode(const PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorCameraSelect_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode camera_select */
+	    ret = T_UInt8_Encode((&(pVal->camera_select)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorCameraSelect_Decode(PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode camera_select */
+	ret = T_UInt8_Decode((&(pVal->camera_select)), pBitStrm, pErrCode);
+
+	return ret  && PoseEstimatorCameraSelect_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PoseEstimatorConfiguration_Initialize(PoseEstimatorConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set imaging_mode */
+	T_Boolean_Initialize((&(pVal->imaging_mode)));
+	/*set camera_select */
+	T_UInt8_Initialize((&(pVal->camera_select)));
+}
+
+flag PoseEstimatorConfiguration_IsConstraintValid(const PoseEstimatorConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->camera_select <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_POSEESTIMATORCONFIGURATION_CAMERA_SELECT;
+
+	return ret;
+}
+
+flag PoseEstimatorConfiguration_Encode(const PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode imaging_mode */
+	    ret = T_Boolean_Encode((&(pVal->imaging_mode)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode camera_select */
+	        ret = T_UInt8_Encode((&(pVal->camera_select)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorConfiguration_Decode(PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode imaging_mode */
+	ret = T_Boolean_Decode((&(pVal->imaging_mode)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode camera_select */
+	    ret = T_UInt8_Decode((&(pVal->camera_select)), pBitStrm, pErrCode);
+	}
+
+	return ret  && PoseEstimatorConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/PoseEstimator.h b/generated/PoseEstimator.h
new file mode 100644
index 0000000..69528ce
--- /dev/null
+++ b/generated/PoseEstimator.h
@@ -0,0 +1,149 @@
+#ifndef GENERATED_ASN1SCC_PoseEstimator_H
+#define GENERATED_ASN1SCC_PoseEstimator_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/base.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- PoseEstimatorMeasurement --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Base_Pose estimated_pose;
+
+} PoseEstimatorMeasurement;
+
+void PoseEstimatorMeasurement_Initialize(PoseEstimatorMeasurement* pVal);
+
+#define ERR_POSEESTIMATORMEASUREMENT		10555  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES		10464  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_TIMESTAMP		10354  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_VALIDITY		10369  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES		10457  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM		10446  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		10380  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		10435  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		10391  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		10402  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		10413  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		10424  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE		10544  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION		10493  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA		10486  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA_ELM		10475  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION		10533  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM		10515  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM_ELM		10504  /**/
+#define ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_RE		10522  /**/
+flag PoseEstimatorMeasurement_IsConstraintValid(const PoseEstimatorMeasurement* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POSEESTIMATORMEASUREMENT		10556  /**/
+#define ERR_UPER_ENCODE_POSEESTIMATORMEASUREMENT_ATTRIBUTES_2		10471  /**/
+#define ERR_UPER_ENCODE_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_2		10551  /**/
+#define PoseEstimatorMeasurement_REQUIRED_BYTES_FOR_ENCODING       158
+#define PoseEstimatorMeasurement_REQUIRED_BITS_FOR_ENCODING        1257
+
+flag PoseEstimatorMeasurement_Encode(const PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POSEESTIMATORMEASUREMENT		10557  /**/
+#define ERR_UPER_DECODE_POSEESTIMATORMEASUREMENT_ATTRIBUTES_2		10472  /**/
+#define ERR_UPER_DECODE_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_2		10552  /**/
+flag PoseEstimatorMeasurement_Decode(PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PoseEstimatorImagingMode --------------------------------------------*/
+typedef struct {
+    T_Boolean imaging_mode;
+
+} PoseEstimatorImagingMode;
+
+void PoseEstimatorImagingMode_Initialize(PoseEstimatorImagingMode* pVal);
+
+#define ERR_POSEESTIMATORIMAGINGMODE		10300  /**/
+#define ERR_POSEESTIMATORIMAGINGMODE_IMAGING_MODE		10289  /**/
+flag PoseEstimatorImagingMode_IsConstraintValid(const PoseEstimatorImagingMode* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POSEESTIMATORIMAGINGMODE		10301  /**/
+#define ERR_UPER_ENCODE_POSEESTIMATORIMAGINGMODE_IMAGING_MODE_2		10296  /**/
+#define PoseEstimatorImagingMode_REQUIRED_BYTES_FOR_ENCODING       1
+#define PoseEstimatorImagingMode_REQUIRED_BITS_FOR_ENCODING        1
+
+flag PoseEstimatorImagingMode_Encode(const PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POSEESTIMATORIMAGINGMODE		10302  /**/
+#define ERR_UPER_DECODE_POSEESTIMATORIMAGINGMODE_IMAGING_MODE_2		10297  /**/
+flag PoseEstimatorImagingMode_Decode(PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PoseEstimatorCameraSelect --------------------------------------------*/
+typedef struct {
+    T_UInt8 camera_select;
+
+} PoseEstimatorCameraSelect;
+
+void PoseEstimatorCameraSelect_Initialize(PoseEstimatorCameraSelect* pVal);
+
+#define ERR_POSEESTIMATORCAMERASELECT		10318  /**/
+#define ERR_POSEESTIMATORCAMERASELECT_CAMERA_SELECT		10307  /**/
+flag PoseEstimatorCameraSelect_IsConstraintValid(const PoseEstimatorCameraSelect* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POSEESTIMATORCAMERASELECT		10319  /**/
+#define ERR_UPER_ENCODE_POSEESTIMATORCAMERASELECT_CAMERA_SELECT_2		10314  /**/
+#define PoseEstimatorCameraSelect_REQUIRED_BYTES_FOR_ENCODING       1
+#define PoseEstimatorCameraSelect_REQUIRED_BITS_FOR_ENCODING        8
+
+flag PoseEstimatorCameraSelect_Encode(const PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POSEESTIMATORCAMERASELECT		10320  /**/
+#define ERR_UPER_DECODE_POSEESTIMATORCAMERASELECT_CAMERA_SELECT_2		10315  /**/
+flag PoseEstimatorCameraSelect_Decode(PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PoseEstimatorConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean imaging_mode;
+    T_UInt8 camera_select;
+
+} PoseEstimatorConfiguration;
+
+void PoseEstimatorConfiguration_Initialize(PoseEstimatorConfiguration* pVal);
+
+#define ERR_POSEESTIMATORCONFIGURATION		10347  /**/
+#define ERR_POSEESTIMATORCONFIGURATION_IMAGING_MODE		10325  /**/
+#define ERR_POSEESTIMATORCONFIGURATION_CAMERA_SELECT		10336  /**/
+flag PoseEstimatorConfiguration_IsConstraintValid(const PoseEstimatorConfiguration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POSEESTIMATORCONFIGURATION		10348  /**/
+#define ERR_UPER_ENCODE_POSEESTIMATORCONFIGURATION_IMAGING_MODE_2		10332  /**/
+#define ERR_UPER_ENCODE_POSEESTIMATORCONFIGURATION_CAMERA_SELECT_2		10343  /**/
+#define PoseEstimatorConfiguration_REQUIRED_BYTES_FOR_ENCODING       2
+#define PoseEstimatorConfiguration_REQUIRED_BITS_FOR_ENCODING        9
+
+flag PoseEstimatorConfiguration_Encode(const PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POSEESTIMATORCONFIGURATION		10349  /**/
+#define ERR_UPER_DECODE_POSEESTIMATORCONFIGURATION_IMAGING_MODE_2		10333  /**/
+#define ERR_UPER_DECODE_POSEESTIMATORCONFIGURATION_CAMERA_SELECT_2		10344  /**/
+flag PoseEstimatorConfiguration_Decode(PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Power.c b/generated/Power.c
new file mode 100644
index 0000000..8621a4c
--- /dev/null
+++ b/generated/Power.c
@@ -0,0 +1,132 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Power.hpp>
+namespace i3ds_asn1 {
+
+
+
+void PowerMask_Initialize(PowerMask* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 16) {
+	    T_Boolean_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+
+}
+
+flag PowerMask_IsConstraintValid(const PowerMask* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag PowerMask_Encode(const PowerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? PowerMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    	
+	    for(i1=0; (i1 < (int)16) && ret; i1++)
+	    {
+	    	ret = T_Boolean_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PowerMask_Decode(PowerMask* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+
+		
+	for(i1=0; (i1 < (int)16) && ret; i1++)
+	{
+		ret = T_Boolean_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && PowerMask_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PowerOutput_Initialize(PowerOutput* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag PowerOutput_IsConstraintValid(const PowerOutput* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 16UL));
+    *pErrCode = ret ? 0 :  ERR_POWEROUTPUT;
+
+	return ret;
+}
+
+flag PowerOutput_Encode(const PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PowerOutput_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 16);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PowerOutput_Decode(PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 16);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_POWEROUTPUT;
+
+	return ret  && PowerOutput_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Power.h b/generated/Power.h
new file mode 100644
index 0000000..8d7b882
--- /dev/null
+++ b/generated/Power.h
@@ -0,0 +1,73 @@
+#ifndef GENERATED_ASN1SCC_Power_H
+#define GENERATED_ASN1SCC_Power_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+
+
+typedef struct {
+
+    T_Boolean arr[16];
+} PowerMask;
+
+void PowerMask_Initialize(PowerMask* pVal);
+
+#define ERR_POWERMASK		11672  /**/
+#define ERR_POWERMASK_ELM		11661  /**/
+flag PowerMask_IsConstraintValid(const PowerMask* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POWERMASK		11673  /**/
+#define ERR_UPER_ENCODE_POWERMASK_ELM_2		11668  /**/
+#define PowerMask_REQUIRED_BYTES_FOR_ENCODING       2
+#define PowerMask_REQUIRED_BITS_FOR_ENCODING        16
+
+flag PowerMask_Encode(const PowerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POWERMASK		11674  /**/
+#define ERR_UPER_DECODE_POWERMASK_ELM_2		11669  /**/
+flag PowerMask_Decode(PowerMask* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint PowerOutput;
+
+
+void PowerOutput_Initialize(PowerOutput* pVal);
+
+#define ERR_POWEROUTPUT		11654  /**/
+flag PowerOutput_IsConstraintValid(const PowerOutput* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POWEROUTPUT		11655  /**/
+#define PowerOutput_REQUIRED_BYTES_FOR_ENCODING       1
+#define PowerOutput_REQUIRED_BITS_FOR_ENCODING        4
+
+flag PowerOutput_Encode(const PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POWEROUTPUT		11656  /**/
+flag PowerOutput_Decode(PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Radar.c b/generated/Radar.c
new file mode 100644
index 0000000..461a8f2
--- /dev/null
+++ b/generated/Radar.c
@@ -0,0 +1,167 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Radar.hpp>
+namespace i3ds_asn1 {
+
+
+
+void RadarRegion_Initialize(RadarRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag RadarRegion_IsConstraintValid(const RadarRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_RADARREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_RADARREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_RADARREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_RADARREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag RadarRegion_Encode(const RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? RadarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag RadarRegion_Decode(RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && RadarRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void RadarConfiguration_Initialize(RadarConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag RadarConfiguration_IsConstraintValid(const RadarConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_RADARCONFIGURATION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_RADARCONFIGURATION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_RADARCONFIGURATION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_RADARCONFIGURATION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag RadarConfiguration_Encode(const RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? RadarConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode region_enabled */
+	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag RadarConfiguration_Decode(RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode region_enabled */
+	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && RadarConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Radar.h b/generated/Radar.h
new file mode 100644
index 0000000..e9e689b
--- /dev/null
+++ b/generated/Radar.h
@@ -0,0 +1,95 @@
+#ifndef GENERATED_ASN1SCC_Radar_H
+#define GENERATED_ASN1SCC_Radar_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- RadarRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PlanarRegion region;
+
+} RadarRegion;
+
+void RadarRegion_Initialize(RadarRegion* pVal);
+
+#define ERR_RADARREGION		10628  /**/
+#define ERR_RADARREGION_ENABLE		10562  /**/
+#define ERR_RADARREGION_REGION		10617  /**/
+#define ERR_RADARREGION_REGION_OFFSET_X		10573  /**/
+#define ERR_RADARREGION_REGION_OFFSET_Y		10584  /**/
+#define ERR_RADARREGION_REGION_SIZE_X		10595  /**/
+#define ERR_RADARREGION_REGION_SIZE_Y		10606  /**/
+flag RadarRegion_IsConstraintValid(const RadarRegion* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_RADARREGION		10629  /**/
+#define ERR_UPER_ENCODE_RADARREGION_ENABLE_2		10569  /**/
+#define ERR_UPER_ENCODE_RADARREGION_REGION_2		10624  /**/
+#define RadarRegion_REQUIRED_BYTES_FOR_ENCODING       9
+#define RadarRegion_REQUIRED_BITS_FOR_ENCODING        65
+
+flag RadarRegion_Encode(const RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_RADARREGION		10630  /**/
+#define ERR_UPER_DECODE_RADARREGION_ENABLE_2		10570  /**/
+#define ERR_UPER_DECODE_RADARREGION_REGION_2		10625  /**/
+flag RadarRegion_Decode(RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- RadarConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean region_enabled;
+    PlanarRegion region;
+
+} RadarConfiguration;
+
+void RadarConfiguration_Initialize(RadarConfiguration* pVal);
+
+#define ERR_RADARCONFIGURATION		10701  /**/
+#define ERR_RADARCONFIGURATION_REGION_ENABLED		10635  /**/
+#define ERR_RADARCONFIGURATION_REGION		10690  /**/
+#define ERR_RADARCONFIGURATION_REGION_OFFSET_X		10646  /**/
+#define ERR_RADARCONFIGURATION_REGION_OFFSET_Y		10657  /**/
+#define ERR_RADARCONFIGURATION_REGION_SIZE_X		10668  /**/
+#define ERR_RADARCONFIGURATION_REGION_SIZE_Y		10679  /**/
+flag RadarConfiguration_IsConstraintValid(const RadarConfiguration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_RADARCONFIGURATION		10702  /**/
+#define ERR_UPER_ENCODE_RADARCONFIGURATION_REGION_ENABLED_2		10642  /**/
+#define ERR_UPER_ENCODE_RADARCONFIGURATION_REGION_2		10697  /**/
+#define RadarConfiguration_REQUIRED_BYTES_FOR_ENCODING       9
+#define RadarConfiguration_REQUIRED_BITS_FOR_ENCODING        65
+
+flag RadarConfiguration_Encode(const RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_RADARCONFIGURATION		10703  /**/
+#define ERR_UPER_DECODE_RADARCONFIGURATION_REGION_ENABLED_2		10643  /**/
+#define ERR_UPER_DECODE_RADARCONFIGURATION_REGION_2		10698  /**/
+flag RadarConfiguration_Decode(RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Region.c b/generated/Region.c
new file mode 100644
index 0000000..1d2f3fe
--- /dev/null
+++ b/generated/Region.c
@@ -0,0 +1,207 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+namespace i3ds_asn1 {
+
+
+
+void PlanarRegion_Initialize(PlanarRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set offset_x */
+	T_UInt16_Initialize((&(pVal->offset_x)));
+	/*set offset_y */
+	T_UInt16_Initialize((&(pVal->offset_y)));
+	/*set size_x */
+	T_UInt16_Initialize((&(pVal->size_x)));
+	/*set size_y */
+	T_UInt16_Initialize((&(pVal->size_y)));
+}
+
+flag PlanarRegion_IsConstraintValid(const PlanarRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_PLANARREGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_PLANARREGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_PLANARREGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_PLANARREGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PlanarRegion_Encode(const PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PlanarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode offset_x */
+	    ret = T_UInt16_Encode((&(pVal->offset_x)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode offset_y */
+	        ret = T_UInt16_Encode((&(pVal->offset_y)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode size_x */
+	            ret = T_UInt16_Encode((&(pVal->size_x)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode size_y */
+	                ret = T_UInt16_Encode((&(pVal->size_y)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PlanarRegion_Decode(PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode offset_x */
+	ret = T_UInt16_Decode((&(pVal->offset_x)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode offset_y */
+	    ret = T_UInt16_Decode((&(pVal->offset_y)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode size_x */
+	        ret = T_UInt16_Decode((&(pVal->size_x)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode size_y */
+	            ret = T_UInt16_Decode((&(pVal->size_y)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && PlanarRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PolarRegion_Initialize(PolarRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set offset_x */
+	T_Float_Initialize((&(pVal->offset_x)));
+	/*set offset_y */
+	T_Float_Initialize((&(pVal->offset_y)));
+	/*set size_x */
+	T_Float_Initialize((&(pVal->size_x)));
+	/*set size_y */
+	T_Float_Initialize((&(pVal->size_y)));
+}
+
+flag PolarRegion_IsConstraintValid(const PolarRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->offset_x) && (pVal->offset_x <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_POLARREGION_OFFSET_X;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->offset_y) && (pVal->offset_y <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_POLARREGION_OFFSET_Y;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->size_x) && (pVal->size_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_POLARREGION_SIZE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->size_y) && (pVal->size_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_POLARREGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PolarRegion_Encode(const PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PolarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode offset_x */
+	    ret = T_Float_Encode((&(pVal->offset_x)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode offset_y */
+	        ret = T_Float_Encode((&(pVal->offset_y)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode size_x */
+	            ret = T_Float_Encode((&(pVal->size_x)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode size_y */
+	                ret = T_Float_Encode((&(pVal->size_y)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PolarRegion_Decode(PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode offset_x */
+	ret = T_Float_Decode((&(pVal->offset_x)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode offset_y */
+	    ret = T_Float_Decode((&(pVal->offset_y)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode size_x */
+	        ret = T_Float_Decode((&(pVal->size_x)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode size_y */
+	            ret = T_Float_Decode((&(pVal->size_y)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && PolarRegion_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Region.h b/generated/Region.h
new file mode 100644
index 0000000..5251e55
--- /dev/null
+++ b/generated/Region.h
@@ -0,0 +1,102 @@
+#ifndef GENERATED_ASN1SCC_Region_H
+#define GENERATED_ASN1SCC_Region_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- PlanarRegion --------------------------------------------*/
+typedef struct {
+    T_UInt16 offset_x;
+    T_UInt16 offset_y;
+    T_UInt16 size_x;
+    T_UInt16 size_y;
+
+} PlanarRegion;
+
+void PlanarRegion_Initialize(PlanarRegion* pVal);
+
+#define ERR_PLANARREGION		10752  /**/
+#define ERR_PLANARREGION_OFFSET_X		10708  /**/
+#define ERR_PLANARREGION_OFFSET_Y		10719  /**/
+#define ERR_PLANARREGION_SIZE_X		10730  /**/
+#define ERR_PLANARREGION_SIZE_Y		10741  /**/
+flag PlanarRegion_IsConstraintValid(const PlanarRegion* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_PLANARREGION		10753  /**/
+#define ERR_UPER_ENCODE_PLANARREGION_OFFSET_X_2		10715  /**/
+#define ERR_UPER_ENCODE_PLANARREGION_OFFSET_Y_2		10726  /**/
+#define ERR_UPER_ENCODE_PLANARREGION_SIZE_X_2		10737  /**/
+#define ERR_UPER_ENCODE_PLANARREGION_SIZE_Y_2		10748  /**/
+#define PlanarRegion_REQUIRED_BYTES_FOR_ENCODING       8
+#define PlanarRegion_REQUIRED_BITS_FOR_ENCODING        64
+
+flag PlanarRegion_Encode(const PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_PLANARREGION		10754  /**/
+#define ERR_UPER_DECODE_PLANARREGION_OFFSET_X_2		10716  /**/
+#define ERR_UPER_DECODE_PLANARREGION_OFFSET_Y_2		10727  /**/
+#define ERR_UPER_DECODE_PLANARREGION_SIZE_X_2		10738  /**/
+#define ERR_UPER_DECODE_PLANARREGION_SIZE_Y_2		10749  /**/
+flag PlanarRegion_Decode(PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PolarRegion --------------------------------------------*/
+typedef struct {
+    T_Float offset_x;
+    T_Float offset_y;
+    T_Float size_x;
+    T_Float size_y;
+
+} PolarRegion;
+
+void PolarRegion_Initialize(PolarRegion* pVal);
+
+#define ERR_POLARREGION		10803  /**/
+#define ERR_POLARREGION_OFFSET_X		10759  /**/
+#define ERR_POLARREGION_OFFSET_Y		10770  /**/
+#define ERR_POLARREGION_SIZE_X		10781  /**/
+#define ERR_POLARREGION_SIZE_Y		10792  /**/
+flag PolarRegion_IsConstraintValid(const PolarRegion* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_POLARREGION		10804  /**/
+#define ERR_UPER_ENCODE_POLARREGION_OFFSET_X_2		10766  /**/
+#define ERR_UPER_ENCODE_POLARREGION_OFFSET_Y_2		10777  /**/
+#define ERR_UPER_ENCODE_POLARREGION_SIZE_X_2		10788  /**/
+#define ERR_UPER_ENCODE_POLARREGION_SIZE_Y_2		10799  /**/
+#define PolarRegion_REQUIRED_BYTES_FOR_ENCODING       52
+#define PolarRegion_REQUIRED_BITS_FOR_ENCODING        416
+
+flag PolarRegion_Encode(const PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_POLARREGION		10805  /**/
+#define ERR_UPER_DECODE_POLARREGION_OFFSET_X_2		10767  /**/
+#define ERR_UPER_DECODE_POLARREGION_OFFSET_Y_2		10778  /**/
+#define ERR_UPER_DECODE_POLARREGION_SIZE_X_2		10789  /**/
+#define ERR_UPER_DECODE_POLARREGION_SIZE_Y_2		10800  /**/
+flag PolarRegion_Decode(PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/SampleAttribute.c b/generated/SampleAttribute.c
new file mode 100644
index 0000000..55d6822
--- /dev/null
+++ b/generated/SampleAttribute.c
@@ -0,0 +1,479 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/SampleAttribute.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SampleValidity_Initialize(SampleValidity* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = sample_empty;
+}
+
+flag SampleValidity_IsConstraintValid(const SampleValidity* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == sample_empty)) || (((*(pVal)) == sample_valid)))) || (((*(pVal)) == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_SAMPLEVALIDITY;
+
+	return ret;
+}
+
+flag SampleValidity_Encode(const SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SampleValidity_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case sample_empty:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case sample_valid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case sample_invalid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_SAMPLEVALIDITY; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SampleValidity_Decode(SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SAMPLEVALIDITY;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = sample_empty;
+	                break;
+	            case 1:
+	                (*(pVal)) = sample_valid;
+	                break;
+	            case 2:
+	                (*(pVal)) = sample_invalid;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_SAMPLEVALIDITY;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = sample_empty;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && SampleValidity_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_String8_Initialize(T_String8* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 8);
+	pVal->nCount = 0;
+
+}
+
+flag T_String8_IsConstraintValid(const T_String8* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->nCount <= 8);
+    *pErrCode = ret ? 0 :  ERR_T_STRING8;
+
+	return ret;
+}
+
+flag T_String8_Encode(const T_String8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? T_String8_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 8);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_String8_Decode(T_String8* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 8);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING8;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1]));
+		*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING8;
+	}
+
+	return ret  && T_String8_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Attribute_value_t_Initialize(Attribute_value_t* pVal)
+{
+	(void)pVal;
+
+
+	/*set boolean_value*/
+	pVal->kind = boolean_value_PRESENT;
+	T_Boolean_Initialize((&(pVal->u.boolean_value)));
+}
+
+flag Attribute_value_t_IsConstraintValid(const Attribute_value_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    if (pVal->kind == real_value_PRESENT) {
+    	ret = ((-1.79769313486231570000E+308 <= pVal->u.real_value) && (pVal->u.real_value <= 1.79769313486231570000E+308));
+    	*pErrCode = ret ? 0 :  ERR_ATTRIBUTE_VALUE_T_REAL_VALUE;
+    }
+    if (ret) {
+        if (pVal->kind == string_value_PRESENT) {
+        	ret = (pVal->u.string_value.nCount <= 8);
+        	*pErrCode = ret ? 0 :  ERR_ATTRIBUTE_VALUE_T_STRING_VALUE;
+        }
+    }
+
+	return ret;
+}
+
+flag Attribute_value_t_Encode(const Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Attribute_value_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch(pVal->kind)
+	    {
+	    case boolean_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	    	ret = T_Boolean_Encode((&(pVal->u.boolean_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    case discrete_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	    	ret = T_Int64_Encode((&(pVal->u.discrete_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    case real_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	    	ret = T_Double_Encode((&(pVal->u.real_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    case string_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	    	ret = T_String8_Encode((&(pVal->u.string_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    default:                            /*COVERAGE_IGNORE*/
+	        *pErrCode = ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T;         /*COVERAGE_IGNORE*/
+	        ret = FALSE;                    /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Attribute_value_t_Decode(Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	asn1SccSint Attribute_value_t_index_tmp;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &Attribute_value_t_index_tmp, 0, 3);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ATTRIBUTE_VALUE_T;
+	if (ret) {
+	    switch(Attribute_value_t_index_tmp)
+	    {
+	    case 0:
+	    	pVal->kind = boolean_value_PRESENT;
+	    	ret = T_Boolean_Decode((&(pVal->u.boolean_value)), pBitStrm, pErrCode);
+	    	break;
+	    case 1:
+	    	pVal->kind = discrete_value_PRESENT;
+	    	ret = T_Int64_Decode((&(pVal->u.discrete_value)), pBitStrm, pErrCode);
+	    	break;
+	    case 2:
+	    	pVal->kind = real_value_PRESENT;
+	    	ret = T_Double_Decode((&(pVal->u.real_value)), pBitStrm, pErrCode);
+	    	break;
+	    case 3:
+	    	pVal->kind = string_value_PRESENT;
+	    	ret = T_String8_Decode((&(pVal->u.string_value)), pBitStrm, pErrCode);
+	    	break;
+	    default:                        /*COVERAGE_IGNORE*/
+	        *pErrCode = ERR_UPER_DECODE_ATTRIBUTE_VALUE_T;     /*COVERAGE_IGNORE*/
+	        ret = FALSE;                /*COVERAGE_IGNORE*/
+	    }
+	}  /*COVERAGE_IGNORE*/
+
+	return ret  && Attribute_value_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Sample_attribute_t_Initialize(Sample_attribute_t* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attribute_key */
+	T_UInt8_Initialize((&(pVal->attribute_key)));
+	/*set attribute_value */
+	Attribute_value_t_Initialize((&(pVal->attribute_value)));
+}
+
+flag Sample_attribute_t_IsConstraintValid(const Sample_attribute_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->attribute_key <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY;
+    if (ret) {
+        if (pVal->attribute_value.kind == real_value_PRESENT) {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->attribute_value.u.real_value) && (pVal->attribute_value.u.real_value <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_REAL_VALUE;
+        }
+        if (ret) {
+            if (pVal->attribute_value.kind == string_value_PRESENT) {
+            	ret = (pVal->attribute_value.u.string_value.nCount <= 8);
+            	*pErrCode = ret ? 0 :  ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_STRING_VALUE;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Sample_attribute_t_Encode(const Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Sample_attribute_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attribute_key */
+	    ret = T_UInt8_Encode((&(pVal->attribute_key)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode attribute_value */
+	        ret = Attribute_value_t_Encode((&(pVal->attribute_value)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Sample_attribute_t_Decode(Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attribute_key */
+	ret = T_UInt8_Decode((&(pVal->attribute_key)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode attribute_value */
+	    ret = Attribute_value_t_Decode((&(pVal->attribute_value)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Sample_attribute_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SampleAttributes_attributes_Initialize(SampleAttributes_attributes* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 4) {
+	    Sample_attribute_t_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 0;
+}
+void SampleAttributes_Initialize(SampleAttributes* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set timestamp */
+	T_Int64_Initialize((&(pVal->timestamp)));
+	/*set validity */
+	SampleValidity_Initialize((&(pVal->validity)));
+	/*set attributes */
+	SampleAttributes_attributes_Initialize((&(pVal->attributes)));
+}
+
+flag SampleAttributes_IsConstraintValid(const SampleAttributes* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->validity == sample_empty)) || ((pVal->validity == sample_valid)))) || ((pVal->validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag SampleAttributes_Encode(const SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? SampleAttributes_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode timestamp */
+	    ret = Timepoint_Encode((&(pVal->timestamp)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode validity */
+	        ret = SampleValidity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode attributes */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 0, 4);
+	            	
+	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	            {
+	            	ret = Sample_attribute_t_Encode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SampleAttributes_Decode(SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode timestamp */
+	ret = Timepoint_Decode((&(pVal->timestamp)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode validity */
+	    ret = SampleValidity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode attributes */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 4);
+	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_SAMPLEATTRIBUTES_ATTRIBUTES;
+	        pVal->attributes.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	        {
+	        	ret = Sample_attribute_t_Decode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && SampleAttributes_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/SampleAttribute.h b/generated/SampleAttribute.h
new file mode 100644
index 0000000..8e3dc28
--- /dev/null
+++ b/generated/SampleAttribute.h
@@ -0,0 +1,204 @@
+#ifndef GENERATED_ASN1SCC_SampleAttribute_H
+#define GENERATED_ASN1SCC_SampleAttribute_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Common.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    sample_empty = 0,
+    sample_valid = 1,
+    sample_invalid = 2
+} SampleValidity;
+
+// please use the following macros to avoid breaking code.
+#define SampleValidity_sample_empty sample_empty
+#define SampleValidity_sample_valid sample_valid
+#define SampleValidity_sample_invalid sample_invalid
+
+void SampleValidity_Initialize(SampleValidity* pVal);
+
+#define ERR_SAMPLEVALIDITY		10810  /**/
+flag SampleValidity_IsConstraintValid(const SampleValidity* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SAMPLEVALIDITY		10811  /**/
+#define SampleValidity_REQUIRED_BYTES_FOR_ENCODING       1
+#define SampleValidity_REQUIRED_BITS_FOR_ENCODING        2
+
+flag SampleValidity_Encode(const SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SAMPLEVALIDITY		10812  /**/
+flag SampleValidity_Decode(SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef struct {
+    int nCount;
+
+    byte arr[8];
+} T_String8;
+
+
+void T_String8_Initialize(T_String8* pVal);
+
+#define ERR_T_STRING8		10817  /**/
+flag T_String8_IsConstraintValid(const T_String8* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_STRING8		10818  /**/
+#define T_String8_REQUIRED_BYTES_FOR_ENCODING       9
+#define T_String8_REQUIRED_BITS_FOR_ENCODING        68
+
+flag T_String8_Encode(const T_String8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_STRING8		10819  /**/
+flag T_String8_Decode(T_String8* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Attribute_value_t --------------------------------------------*/
+
+typedef enum {
+    Attribute_value_t_NONE,
+    boolean_value_PRESENT,
+    discrete_value_PRESENT,
+    real_value_PRESENT,
+    string_value_PRESENT
+} Attribute_value_t_selection;
+
+
+typedef struct {
+    Attribute_value_t_selection kind;
+
+    union {
+        T_Boolean boolean_value;
+        T_Int64 discrete_value;
+        T_Double real_value;
+        T_String8 string_value;
+    } u;
+} Attribute_value_t;
+
+void Attribute_value_t_Initialize(Attribute_value_t* pVal);
+
+#define ERR_ATTRIBUTE_VALUE_T		10868  /**/
+#define ERR_ATTRIBUTE_VALUE_T_BOOLEAN_VALUE		10824  /**/
+#define ERR_ATTRIBUTE_VALUE_T_DISCRETE_VALUE		10835  /**/
+#define ERR_ATTRIBUTE_VALUE_T_REAL_VALUE		10846  /**/
+#define ERR_ATTRIBUTE_VALUE_T_STRING_VALUE		10857  /**/
+flag Attribute_value_t_IsConstraintValid(const Attribute_value_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T		10869  /**/
+#define ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_BOOLEAN_VALUE_2		10831  /**/
+#define ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_DISCRETE_VALUE_2		10842  /**/
+#define ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_REAL_VALUE_2		10853  /**/
+#define ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_STRING_VALUE_2		10864  /**/
+#define Attribute_value_t_REQUIRED_BYTES_FOR_ENCODING       14
+#define Attribute_value_t_REQUIRED_BITS_FOR_ENCODING        106
+
+flag Attribute_value_t_Encode(const Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_ATTRIBUTE_VALUE_T		10870  /**/
+#define ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_BOOLEAN_VALUE_2		10832  /**/
+#define ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_DISCRETE_VALUE_2		10843  /**/
+#define ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_REAL_VALUE_2		10854  /**/
+#define ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_STRING_VALUE_2		10865  /**/
+flag Attribute_value_t_Decode(Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Sample_attribute_t --------------------------------------------*/
+typedef struct {
+    T_UInt8 attribute_key;
+    Attribute_value_t attribute_value;
+
+} Sample_attribute_t;
+
+void Sample_attribute_t_Initialize(Sample_attribute_t* pVal);
+
+#define ERR_SAMPLE_ATTRIBUTE_T		10941  /**/
+#define ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY		10875  /**/
+#define ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE		10930  /**/
+#define ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_BOOLEAN_VALUE		10886  /**/
+#define ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_DISCRETE_VALUE		10897  /**/
+#define ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_REAL_VALUE		10908  /**/
+#define ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_STRING_VALUE		10919  /**/
+flag Sample_attribute_t_IsConstraintValid(const Sample_attribute_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SAMPLE_ATTRIBUTE_T		10942  /**/
+#define ERR_UPER_ENCODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY_2		10882  /**/
+#define ERR_UPER_ENCODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_2		10937  /**/
+#define Sample_attribute_t_REQUIRED_BYTES_FOR_ENCODING       15
+#define Sample_attribute_t_REQUIRED_BITS_FOR_ENCODING        114
+
+flag Sample_attribute_t_Encode(const Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SAMPLE_ATTRIBUTE_T		10943  /**/
+#define ERR_UPER_DECODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY_2		10883  /**/
+#define ERR_UPER_DECODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_2		10938  /**/
+flag Sample_attribute_t_Decode(Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SampleAttributes --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Sample_attribute_t arr[4];
+} SampleAttributes_attributes;
+typedef struct {
+    T_Int64 timestamp;
+    SampleValidity validity;
+    SampleAttributes_attributes attributes;
+
+} SampleAttributes;
+
+void SampleAttributes_attributes_Initialize(SampleAttributes_attributes* pVal);
+void SampleAttributes_Initialize(SampleAttributes* pVal);
+
+#define ERR_SAMPLEATTRIBUTES		11058  /**/
+#define ERR_SAMPLEATTRIBUTES_TIMESTAMP		10948  /**/
+#define ERR_SAMPLEATTRIBUTES_VALIDITY		10963  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES		11051  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM		11040  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		10974  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		11029  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		10985  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		10996  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		11007  /**/
+#define ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		11018  /**/
+flag SampleAttributes_IsConstraintValid(const SampleAttributes* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SAMPLEATTRIBUTES		11059  /**/
+#define ERR_UPER_ENCODE_SAMPLEATTRIBUTES_TIMESTAMP_2_2		10959  /**/
+#define ERR_UPER_ENCODE_SAMPLEATTRIBUTES_VALIDITY_2		10970  /**/
+#define ERR_UPER_ENCODE_SAMPLEATTRIBUTES_ATTRIBUTES		11052  /**/
+#define ERR_UPER_ENCODE_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_2		11047  /**/
+#define SampleAttributes_REQUIRED_BYTES_FOR_ENCODING       66
+#define SampleAttributes_REQUIRED_BITS_FOR_ENCODING        525
+
+flag SampleAttributes_Encode(const SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SAMPLEATTRIBUTES		11060  /**/
+#define ERR_UPER_DECODE_SAMPLEATTRIBUTES_TIMESTAMP_2_2		10960  /**/
+#define ERR_UPER_DECODE_SAMPLEATTRIBUTES_VALIDITY_2		10971  /**/
+#define ERR_UPER_DECODE_SAMPLEATTRIBUTES_ATTRIBUTES		11053  /**/
+#define ERR_UPER_DECODE_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_2		11048  /**/
+flag SampleAttributes_Decode(SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Sensor.c b/generated/Sensor.c
new file mode 100644
index 0000000..fed5b91
--- /dev/null
+++ b/generated/Sensor.c
@@ -0,0 +1,597 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Sensor.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SamplePeriod_Initialize(SamplePeriod* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag SamplePeriod_IsConstraintValid(const SamplePeriod* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_SAMPLEPERIOD;
+
+	return ret;
+}
+
+flag SamplePeriod_Encode(const SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SamplePeriod_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SamplePeriod_Decode(SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && SamplePeriod_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void BatchSize_Initialize(BatchSize* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag BatchSize_IsConstraintValid(const BatchSize* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_BATCHSIZE;
+
+	return ret;
+}
+
+flag BatchSize_Encode(const BatchSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? BatchSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag BatchSize_Decode(BatchSize* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && BatchSize_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void BatchCount_Initialize(BatchCount* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag BatchCount_IsConstraintValid(const BatchCount* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_BATCHCOUNT;
+
+	return ret;
+}
+
+flag BatchCount_Encode(const BatchCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? BatchCount_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag BatchCount_Decode(BatchCount* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && BatchCount_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SampleCommand_Initialize(SampleCommand* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set period */
+	T_UInt32_Initialize((&(pVal->period)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+	/*set batch_count */
+	T_UInt32_Initialize((&(pVal->batch_count)));
+}
+
+flag SampleCommand_IsConstraintValid(const SampleCommand* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->period <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_SAMPLECOMMAND_PERIOD;
+    if (ret) {
+        ret = (pVal->batch_size <= 4294967295UL);
+        *pErrCode = ret ? 0 :  ERR_SAMPLECOMMAND_BATCH_SIZE;
+        if (ret) {
+            ret = (pVal->batch_count <= 4294967295UL);
+            *pErrCode = ret ? 0 :  ERR_SAMPLECOMMAND_BATCH_COUNT;
+        }
+    }
+
+	return ret;
+}
+
+flag SampleCommand_Encode(const SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SampleCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode period */
+	    ret = SamplePeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode batch_size */
+	        ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode batch_count */
+	            ret = BatchCount_Encode((&(pVal->batch_count)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SampleCommand_Decode(SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode period */
+	ret = SamplePeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode batch_size */
+	    ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode batch_count */
+	        ret = BatchCount_Decode((&(pVal->batch_count)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && SampleCommand_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SensorConfiguration_Initialize(SensorConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set device_name */
+	T_String_Initialize((&(pVal->device_name)));
+	/*set period */
+	T_UInt32_Initialize((&(pVal->period)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+	/*set batch_count */
+	T_UInt32_Initialize((&(pVal->batch_count)));
+}
+
+flag SensorConfiguration_IsConstraintValid(const SensorConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->device_name.nCount <= 40);
+    *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_DEVICE_NAME;
+    if (ret) {
+        ret = (pVal->period <= 4294967295UL);
+        *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_PERIOD;
+        if (ret) {
+            ret = (pVal->batch_size <= 4294967295UL);
+            *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_BATCH_SIZE;
+            if (ret) {
+                ret = (pVal->batch_count <= 4294967295UL);
+                *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_BATCH_COUNT;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag SensorConfiguration_Encode(const SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode device_name */
+	    ret = T_String_Encode((&(pVal->device_name)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode period */
+	        ret = SamplePeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode batch_size */
+	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode batch_count */
+	                ret = BatchCount_Encode((&(pVal->batch_count)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorConfiguration_Decode(SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode device_name */
+	ret = T_String_Decode((&(pVal->device_name)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode period */
+	    ret = SamplePeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode batch_size */
+	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode batch_count */
+	            ret = BatchCount_Decode((&(pVal->batch_count)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && SensorConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SensorState_Initialize(SensorState* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = inactive;
+}
+
+flag SensorState_IsConstraintValid(const SensorState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((*(pVal)) == inactive)) || (((*(pVal)) == standby)))) || (((*(pVal)) == operational)))) || (((*(pVal)) == failure)));
+    *pErrCode = ret ? 0 :  ERR_SENSORSTATE;
+
+	return ret;
+}
+
+flag SensorState_Encode(const SensorState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case inactive:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	        	break;
+	        case standby:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	        	break;
+	        case operational:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	        	break;
+	        case failure:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_SENSORSTATE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorState_Decode(SensorState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SENSORSTATE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = inactive;
+	                break;
+	            case 1:
+	                (*(pVal)) = standby;
+	                break;
+	            case 2:
+	                (*(pVal)) = operational;
+	                break;
+	            case 3:
+	                (*(pVal)) = failure;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_SENSORSTATE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = inactive;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && SensorState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SensorStatus_Initialize(SensorStatus* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set current_state */
+	SensorState_Initialize((&(pVal->current_state)));
+	/*set device_temperature */
+	Base_Temperature_Initialize((&(pVal->device_temperature)));
+}
+
+flag SensorStatus_IsConstraintValid(const SensorStatus* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (((((((pVal->current_state == inactive)) || ((pVal->current_state == standby)))) || ((pVal->current_state == operational)))) || ((pVal->current_state == failure)));
+    *pErrCode = ret ? 0 :  ERR_SENSORSTATUS_CURRENT_STATE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->device_temperature.kelvin) && (pVal->device_temperature.kelvin <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_SENSORSTATUS_DEVICE_TEMPERATURE_KELVIN;
+    }
+
+	return ret;
+}
+
+flag SensorStatus_Encode(const SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode current_state */
+	    ret = SensorState_Encode((&(pVal->current_state)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode device_temperature */
+	        ret = Base_Temperature_Encode((&(pVal->device_temperature)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorStatus_Decode(SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode current_state */
+	ret = SensorState_Decode((&(pVal->current_state)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode device_temperature */
+	    ret = Base_Temperature_Decode((&(pVal->device_temperature)), pBitStrm, pErrCode);
+	}
+
+	return ret  && SensorStatus_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void StateCommand_Initialize(StateCommand* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = activate;
+}
+
+flag StateCommand_IsConstraintValid(const StateCommand* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((*(pVal)) == activate)) || (((*(pVal)) == start)))) || (((*(pVal)) == stop)))) || (((*(pVal)) == deactivate)));
+    *pErrCode = ret ? 0 :  ERR_STATECOMMAND;
+
+	return ret;
+}
+
+flag StateCommand_Encode(const StateCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? StateCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case activate:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	        	break;
+	        case start:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	        	break;
+	        case stop:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	        	break;
+	        case deactivate:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_STATECOMMAND; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag StateCommand_Decode(StateCommand* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_STATECOMMAND;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = activate;
+	                break;
+	            case 1:
+	                (*(pVal)) = start;
+	                break;
+	            case 2:
+	                (*(pVal)) = stop;
+	                break;
+	            case 3:
+	                (*(pVal)) = deactivate;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_STATECOMMAND;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = activate;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && StateCommand_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Sensor.h b/generated/Sensor.h
new file mode 100644
index 0000000..b603d3b
--- /dev/null
+++ b/generated/Sensor.h
@@ -0,0 +1,227 @@
+#ifndef GENERATED_ASN1SCC_Sensor_H
+#define GENERATED_ASN1SCC_Sensor_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/base.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_UInt32 SamplePeriod;
+
+
+void SamplePeriod_Initialize(SamplePeriod* pVal);
+
+#define ERR_SAMPLEPERIOD		9286  /**/
+flag SamplePeriod_IsConstraintValid(const SamplePeriod* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SAMPLEPERIOD_2		9293  /**/
+#define SamplePeriod_REQUIRED_BYTES_FOR_ENCODING       4
+#define SamplePeriod_REQUIRED_BITS_FOR_ENCODING        32
+
+flag SamplePeriod_Encode(const SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SAMPLEPERIOD_2		9294  /**/
+flag SamplePeriod_Decode(SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt32 BatchSize;
+
+
+void BatchSize_Initialize(BatchSize* pVal);
+
+#define ERR_BATCHSIZE		9297  /**/
+flag BatchSize_IsConstraintValid(const BatchSize* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BATCHSIZE_2		9304  /**/
+#define BatchSize_REQUIRED_BYTES_FOR_ENCODING       4
+#define BatchSize_REQUIRED_BITS_FOR_ENCODING        32
+
+flag BatchSize_Encode(const BatchSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BATCHSIZE_2		9305  /**/
+flag BatchSize_Decode(BatchSize* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt32 BatchCount;
+
+
+void BatchCount_Initialize(BatchCount* pVal);
+
+#define ERR_BATCHCOUNT		9308  /**/
+flag BatchCount_IsConstraintValid(const BatchCount* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BATCHCOUNT_2		9315  /**/
+#define BatchCount_REQUIRED_BYTES_FOR_ENCODING       4
+#define BatchCount_REQUIRED_BITS_FOR_ENCODING        32
+
+flag BatchCount_Encode(const BatchCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BATCHCOUNT_2		9316  /**/
+flag BatchCount_Decode(BatchCount* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SampleCommand --------------------------------------------*/
+typedef struct {
+    T_UInt32 period;
+    T_UInt32 batch_size;
+    T_UInt32 batch_count;
+
+} SampleCommand;
+
+void SampleCommand_Initialize(SampleCommand* pVal);
+
+#define ERR_SAMPLECOMMAND		9364  /**/
+#define ERR_SAMPLECOMMAND_PERIOD		9319  /**/
+#define ERR_SAMPLECOMMAND_BATCH_SIZE		9334  /**/
+#define ERR_SAMPLECOMMAND_BATCH_COUNT		9349  /**/
+flag SampleCommand_IsConstraintValid(const SampleCommand* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SAMPLECOMMAND		9365  /**/
+#define ERR_UPER_ENCODE_SAMPLECOMMAND_PERIOD_2_2		9330  /**/
+#define ERR_UPER_ENCODE_SAMPLECOMMAND_BATCH_SIZE_2_2		9345  /**/
+#define ERR_UPER_ENCODE_SAMPLECOMMAND_BATCH_COUNT_2_2		9360  /**/
+#define SampleCommand_REQUIRED_BYTES_FOR_ENCODING       12
+#define SampleCommand_REQUIRED_BITS_FOR_ENCODING        96
+
+flag SampleCommand_Encode(const SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SAMPLECOMMAND		9366  /**/
+#define ERR_UPER_DECODE_SAMPLECOMMAND_PERIOD_2_2		9331  /**/
+#define ERR_UPER_DECODE_SAMPLECOMMAND_BATCH_SIZE_2_2		9346  /**/
+#define ERR_UPER_DECODE_SAMPLECOMMAND_BATCH_COUNT_2_2		9361  /**/
+flag SampleCommand_Decode(SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SensorConfiguration --------------------------------------------*/
+typedef struct {
+    T_String device_name;
+    T_UInt32 period;
+    T_UInt32 batch_size;
+    T_UInt32 batch_count;
+
+} SensorConfiguration;
+
+void SensorConfiguration_Initialize(SensorConfiguration* pVal);
+
+#define ERR_SENSORCONFIGURATION		9427  /**/
+#define ERR_SENSORCONFIGURATION_DEVICE_NAME		9371  /**/
+#define ERR_SENSORCONFIGURATION_PERIOD		9382  /**/
+#define ERR_SENSORCONFIGURATION_BATCH_SIZE		9397  /**/
+#define ERR_SENSORCONFIGURATION_BATCH_COUNT		9412  /**/
+flag SensorConfiguration_IsConstraintValid(const SensorConfiguration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SENSORCONFIGURATION		9428  /**/
+#define ERR_UPER_ENCODE_SENSORCONFIGURATION_DEVICE_NAME_2		9378  /**/
+#define ERR_UPER_ENCODE_SENSORCONFIGURATION_PERIOD_2_2		9393  /**/
+#define ERR_UPER_ENCODE_SENSORCONFIGURATION_BATCH_SIZE_2_2		9408  /**/
+#define ERR_UPER_ENCODE_SENSORCONFIGURATION_BATCH_COUNT_2_2		9423  /**/
+#define SensorConfiguration_REQUIRED_BYTES_FOR_ENCODING       53
+#define SensorConfiguration_REQUIRED_BITS_FOR_ENCODING        422
+
+flag SensorConfiguration_Encode(const SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SENSORCONFIGURATION		9429  /**/
+#define ERR_UPER_DECODE_SENSORCONFIGURATION_DEVICE_NAME_2		9379  /**/
+#define ERR_UPER_DECODE_SENSORCONFIGURATION_PERIOD_2_2		9394  /**/
+#define ERR_UPER_DECODE_SENSORCONFIGURATION_BATCH_SIZE_2_2		9409  /**/
+#define ERR_UPER_DECODE_SENSORCONFIGURATION_BATCH_COUNT_2_2		9424  /**/
+flag SensorConfiguration_Decode(SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    inactive = 0,
+    standby = 1,
+    operational = 2,
+    failure = 3
+} SensorState;
+
+// please use the following macros to avoid breaking code.
+#define SensorState_inactive inactive
+#define SensorState_standby standby
+#define SensorState_operational operational
+#define SensorState_failure failure
+
+void SensorState_Initialize(SensorState* pVal);
+
+#define ERR_SENSORSTATE		9232  /**/
+flag SensorState_IsConstraintValid(const SensorState* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SENSORSTATE		9233  /**/
+#define SensorState_REQUIRED_BYTES_FOR_ENCODING       1
+#define SensorState_REQUIRED_BITS_FOR_ENCODING        2
+
+flag SensorState_Encode(const SensorState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SENSORSTATE		9234  /**/
+flag SensorState_Decode(SensorState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SensorStatus --------------------------------------------*/
+typedef struct {
+    SensorState current_state;
+    Base_Temperature device_temperature;
+
+} SensorStatus;
+
+void SensorStatus_Initialize(SensorStatus* pVal);
+
+#define ERR_SENSORSTATUS		9279  /**/
+#define ERR_SENSORSTATUS_CURRENT_STATE		9246  /**/
+#define ERR_SENSORSTATUS_DEVICE_TEMPERATURE		9268  /**/
+#define ERR_SENSORSTATUS_DEVICE_TEMPERATURE_KELVIN		9257  /**/
+flag SensorStatus_IsConstraintValid(const SensorStatus* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_SENSORSTATUS		9280  /**/
+#define ERR_UPER_ENCODE_SENSORSTATUS_CURRENT_STATE_2		9253  /**/
+#define ERR_UPER_ENCODE_SENSORSTATUS_DEVICE_TEMPERATURE_2		9275  /**/
+#define SensorStatus_REQUIRED_BYTES_FOR_ENCODING       14
+#define SensorStatus_REQUIRED_BITS_FOR_ENCODING        106
+
+flag SensorStatus_Encode(const SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_SENSORSTATUS		9281  /**/
+#define ERR_UPER_DECODE_SENSORSTATUS_CURRENT_STATE_2		9254  /**/
+#define ERR_UPER_DECODE_SENSORSTATUS_DEVICE_TEMPERATURE_2		9276  /**/
+flag SensorStatus_Decode(SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    activate = 0,
+    start = 1,
+    stop = 2,
+    deactivate = 3
+} StateCommand;
+
+// please use the following macros to avoid breaking code.
+#define StateCommand_activate activate
+#define StateCommand_start start
+#define StateCommand_stop stop
+#define StateCommand_deactivate deactivate
+
+void StateCommand_Initialize(StateCommand* pVal);
+
+#define ERR_STATECOMMAND		9239  /**/
+flag StateCommand_IsConstraintValid(const StateCommand* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_STATECOMMAND		9240  /**/
+#define StateCommand_REQUIRED_BYTES_FOR_ENCODING       1
+#define StateCommand_REQUIRED_BITS_FOR_ENCODING        2
+
+flag StateCommand_Encode(const StateCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_STATECOMMAND		9241  /**/
+flag StateCommand_Decode(StateCommand* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/StarTracker.c b/generated/StarTracker.c
new file mode 100644
index 0000000..524f005
--- /dev/null
+++ b/generated/StarTracker.c
@@ -0,0 +1,118 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/StarTracker.hpp>
+namespace i3ds_asn1 {
+
+
+
+void StarTrackerMeasurement_Initialize(StarTrackerMeasurement* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set position */
+	Wrappers_Quaterniond_Initialize((&(pVal->position)));
+}
+
+flag StarTrackerMeasurement_IsConstraintValid(const StarTrackerMeasurement* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->position.im.nCount) && (pVal->position.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_POSITION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->position.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->position.im.arr[i1]) && (pVal->position.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_POSITION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->position.re) && (pVal->position.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_STARTRACKERMEASUREMENT_POSITION_RE;
+        }
+    }
+
+	return ret;
+}
+
+flag StarTrackerMeasurement_Encode(const StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? StarTrackerMeasurement_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode position */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag StarTrackerMeasurement_Decode(StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode position */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	}
+
+	return ret  && StarTrackerMeasurement_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/StarTracker.h b/generated/StarTracker.h
new file mode 100644
index 0000000..1deae83
--- /dev/null
+++ b/generated/StarTracker.h
@@ -0,0 +1,74 @@
+#ifndef GENERATED_ASN1SCC_StarTracker_H
+#define GENERATED_ASN1SCC_StarTracker_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/base.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- StarTrackerMeasurement --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Wrappers_Quaterniond position;
+
+} StarTrackerMeasurement;
+
+void StarTrackerMeasurement_Initialize(StarTrackerMeasurement* pVal);
+
+#define ERR_STARTRACKERMEASUREMENT		11226  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES		11175  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_TIMESTAMP		11065  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_VALIDITY		11080  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES		11168  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM		11157  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		11091  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		11146  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		11102  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		11113  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		11124  /**/
+#define ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		11135  /**/
+#define ERR_STARTRACKERMEASUREMENT_POSITION		11215  /**/
+#define ERR_STARTRACKERMEASUREMENT_POSITION_IM		11197  /**/
+#define ERR_STARTRACKERMEASUREMENT_POSITION_IM_ELM		11186  /**/
+#define ERR_STARTRACKERMEASUREMENT_POSITION_RE		11204  /**/
+flag StarTrackerMeasurement_IsConstraintValid(const StarTrackerMeasurement* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_STARTRACKERMEASUREMENT		11227  /**/
+#define ERR_UPER_ENCODE_STARTRACKERMEASUREMENT_ATTRIBUTES_2		11182  /**/
+#define ERR_UPER_ENCODE_STARTRACKERMEASUREMENT_POSITION_2		11222  /**/
+#define StarTrackerMeasurement_REQUIRED_BYTES_FOR_ENCODING       118
+#define StarTrackerMeasurement_REQUIRED_BITS_FOR_ENCODING        943
+
+flag StarTrackerMeasurement_Encode(const StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_STARTRACKERMEASUREMENT		11228  /**/
+#define ERR_UPER_DECODE_STARTRACKERMEASUREMENT_ATTRIBUTES_2		11183  /**/
+#define ERR_UPER_DECODE_STARTRACKERMEASUREMENT_POSITION_2		11223  /**/
+flag StarTrackerMeasurement_Decode(StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/ToFCamera.c b/generated/ToFCamera.c
new file mode 100644
index 0000000..b2496d3
--- /dev/null
+++ b/generated/ToFCamera.c
@@ -0,0 +1,263 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/ToFCamera.hpp>
+namespace i3ds_asn1 {
+
+
+
+void ToFRange_Initialize(ToFRange* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set min_depth */
+	T_Float_Initialize((&(pVal->min_depth)));
+	/*set max_depth */
+	T_Float_Initialize((&(pVal->max_depth)));
+}
+
+flag ToFRange_IsConstraintValid(const ToFRange* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_TOFRANGE_MIN_DEPTH;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_TOFRANGE_MAX_DEPTH;
+    }
+
+	return ret;
+}
+
+flag ToFRange_Encode(const ToFRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ToFRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode min_depth */
+	    ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode max_depth */
+	        ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ToFRange_Decode(ToFRange* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode min_depth */
+	ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode max_depth */
+	    ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
+	}
+
+	return ret  && ToFRange_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ToFRegion_Initialize(ToFRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag ToFRegion_IsConstraintValid(const ToFRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag ToFRegion_Encode(const ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ToFRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ToFRegion_Decode(ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && ToFRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ToFConfiguration_Initialize(ToFConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+	/*set min_depth */
+	T_Float_Initialize((&(pVal->min_depth)));
+	/*set max_depth */
+	T_Float_Initialize((&(pVal->max_depth)));
+}
+
+flag ToFConfiguration_IsConstraintValid(const ToFConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_SIZE_Y;
+            }
+        }
+    }
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_MIN_DEPTH;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_MAX_DEPTH;
+        }
+    }
+
+	return ret;
+}
+
+flag ToFConfiguration_Encode(const ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ToFConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode region_enabled */
+	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode min_depth */
+	            ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode max_depth */
+	                ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ToFConfiguration_Decode(ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode region_enabled */
+	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode min_depth */
+	        ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode max_depth */
+	            ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && ToFConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/ToFCamera.h b/generated/ToFCamera.h
new file mode 100644
index 0000000..11509a1
--- /dev/null
+++ b/generated/ToFCamera.h
@@ -0,0 +1,130 @@
+#ifndef GENERATED_ASN1SCC_ToFCamera_H
+#define GENERATED_ASN1SCC_ToFCamera_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- ToFRange --------------------------------------------*/
+typedef struct {
+    T_Float min_depth;
+    T_Float max_depth;
+
+} ToFRange;
+
+void ToFRange_Initialize(ToFRange* pVal);
+
+#define ERR_TOFRANGE		11328  /**/
+#define ERR_TOFRANGE_MIN_DEPTH		11306  /**/
+#define ERR_TOFRANGE_MAX_DEPTH		11317  /**/
+flag ToFRange_IsConstraintValid(const ToFRange* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TOFRANGE		11329  /**/
+#define ERR_UPER_ENCODE_TOFRANGE_MIN_DEPTH_2		11313  /**/
+#define ERR_UPER_ENCODE_TOFRANGE_MAX_DEPTH_2		11324  /**/
+#define ToFRange_REQUIRED_BYTES_FOR_ENCODING       26
+#define ToFRange_REQUIRED_BITS_FOR_ENCODING        208
+
+flag ToFRange_Encode(const ToFRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TOFRANGE		11330  /**/
+#define ERR_UPER_DECODE_TOFRANGE_MIN_DEPTH_2		11314  /**/
+#define ERR_UPER_DECODE_TOFRANGE_MAX_DEPTH_2		11325  /**/
+flag ToFRange_Decode(ToFRange* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ToFRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PlanarRegion region;
+
+} ToFRegion;
+
+void ToFRegion_Initialize(ToFRegion* pVal);
+
+#define ERR_TOFREGION		11299  /**/
+#define ERR_TOFREGION_ENABLE		11233  /**/
+#define ERR_TOFREGION_REGION		11288  /**/
+#define ERR_TOFREGION_REGION_OFFSET_X		11244  /**/
+#define ERR_TOFREGION_REGION_OFFSET_Y		11255  /**/
+#define ERR_TOFREGION_REGION_SIZE_X		11266  /**/
+#define ERR_TOFREGION_REGION_SIZE_Y		11277  /**/
+flag ToFRegion_IsConstraintValid(const ToFRegion* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TOFREGION		11300  /**/
+#define ERR_UPER_ENCODE_TOFREGION_ENABLE_2		11240  /**/
+#define ERR_UPER_ENCODE_TOFREGION_REGION_2		11295  /**/
+#define ToFRegion_REQUIRED_BYTES_FOR_ENCODING       9
+#define ToFRegion_REQUIRED_BITS_FOR_ENCODING        65
+
+flag ToFRegion_Encode(const ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TOFREGION		11301  /**/
+#define ERR_UPER_DECODE_TOFREGION_ENABLE_2		11241  /**/
+#define ERR_UPER_DECODE_TOFREGION_REGION_2		11296  /**/
+flag ToFRegion_Decode(ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ToFConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean region_enabled;
+    PlanarRegion region;
+    T_Float min_depth;
+    T_Float max_depth;
+
+} ToFConfiguration;
+
+void ToFConfiguration_Initialize(ToFConfiguration* pVal);
+
+#define ERR_TOFCONFIGURATION		11423  /**/
+#define ERR_TOFCONFIGURATION_REGION_ENABLED		11335  /**/
+#define ERR_TOFCONFIGURATION_REGION		11390  /**/
+#define ERR_TOFCONFIGURATION_REGION_OFFSET_X		11346  /**/
+#define ERR_TOFCONFIGURATION_REGION_OFFSET_Y		11357  /**/
+#define ERR_TOFCONFIGURATION_REGION_SIZE_X		11368  /**/
+#define ERR_TOFCONFIGURATION_REGION_SIZE_Y		11379  /**/
+#define ERR_TOFCONFIGURATION_MIN_DEPTH		11401  /**/
+#define ERR_TOFCONFIGURATION_MAX_DEPTH		11412  /**/
+flag ToFConfiguration_IsConstraintValid(const ToFConfiguration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TOFCONFIGURATION		11424  /**/
+#define ERR_UPER_ENCODE_TOFCONFIGURATION_REGION_ENABLED_2		11342  /**/
+#define ERR_UPER_ENCODE_TOFCONFIGURATION_REGION_2		11397  /**/
+#define ERR_UPER_ENCODE_TOFCONFIGURATION_MIN_DEPTH_2		11408  /**/
+#define ERR_UPER_ENCODE_TOFCONFIGURATION_MAX_DEPTH_2		11419  /**/
+#define ToFConfiguration_REQUIRED_BYTES_FOR_ENCODING       35
+#define ToFConfiguration_REQUIRED_BITS_FOR_ENCODING        273
+
+flag ToFConfiguration_Encode(const ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TOFCONFIGURATION		11425  /**/
+#define ERR_UPER_DECODE_TOFCONFIGURATION_REGION_ENABLED_2		11343  /**/
+#define ERR_UPER_DECODE_TOFCONFIGURATION_REGION_2		11398  /**/
+#define ERR_UPER_DECODE_TOFCONFIGURATION_MIN_DEPTH_2		11409  /**/
+#define ERR_UPER_DECODE_TOFCONFIGURATION_MAX_DEPTH_2		11420  /**/
+flag ToFConfiguration_Decode(ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/Trigger.c b/generated/Trigger.c
new file mode 100644
index 0000000..f94ac0c
--- /dev/null
+++ b/generated/Trigger.c
@@ -0,0 +1,677 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Trigger.hpp>
+namespace i3ds_asn1 {
+
+
+
+void TriggerMask_Initialize(TriggerMask* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 8) {
+	    T_Boolean_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+
+}
+
+flag TriggerMask_IsConstraintValid(const TriggerMask* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag TriggerMask_Encode(const TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? TriggerMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    	
+	    for(i1=0; (i1 < (int)8) && ret; i1++)
+	    {
+	    	ret = T_Boolean_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerMask_Decode(TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+
+		
+	for(i1=0; (i1 < (int)8) && ret; i1++)
+	{
+		ret = T_Boolean_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && TriggerMask_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerGenerator_Initialize(TriggerGenerator* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag TriggerGenerator_IsConstraintValid(const TriggerGenerator* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 4UL));
+    *pErrCode = ret ? 0 :  ERR_TRIGGERGENERATOR;
+
+	return ret;
+}
+
+flag TriggerGenerator_Encode(const TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerGenerator_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 4);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerGenerator_Decode(TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 4);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERGENERATOR;
+
+	return ret  && TriggerGenerator_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerInput_Initialize(TriggerInput* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag TriggerInput_IsConstraintValid(const TriggerInput* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 4UL));
+    *pErrCode = ret ? 0 :  ERR_TRIGGERINPUT;
+
+	return ret;
+}
+
+flag TriggerInput_Encode(const TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerInput_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 4);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerInput_Decode(TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 4);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERINPUT;
+
+	return ret  && TriggerInput_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerOutput_Initialize(TriggerOutput* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag TriggerOutput_IsConstraintValid(const TriggerOutput* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 8UL));
+    *pErrCode = ret ? 0 :  ERR_TRIGGEROUTPUT;
+
+	return ret;
+}
+
+flag TriggerOutput_Encode(const TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerOutput_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 8);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerOutput_Decode(TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 8);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGEROUTPUT;
+
+	return ret  && TriggerOutput_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerPeriod_Initialize(TriggerPeriod* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag TriggerPeriod_IsConstraintValid(const TriggerPeriod* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 16777215UL);
+    *pErrCode = ret ? 0 :  ERR_TRIGGERPERIOD;
+
+	return ret;
+}
+
+flag TriggerPeriod_Encode(const TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerPeriod_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerPeriod_Decode(TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERPERIOD;
+
+	return ret  && TriggerPeriod_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void GeneratorSetup_Initialize(GeneratorSetup* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set source */
+	TriggerGenerator_Initialize((&(pVal->source)));
+	/*set period */
+	TriggerPeriod_Initialize((&(pVal->period)));
+}
+
+flag GeneratorSetup_IsConstraintValid(const GeneratorSetup* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
+    *pErrCode = ret ? 0 :  ERR_GENERATORSETUP_SOURCE;
+    if (ret) {
+        ret = (pVal->period <= 16777215UL);
+        *pErrCode = ret ? 0 :  ERR_GENERATORSETUP_PERIOD;
+    }
+
+	return ret;
+}
+
+flag GeneratorSetup_Encode(const GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? GeneratorSetup_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode source */
+	    ret = TriggerGenerator_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode period */
+	        ret = TriggerPeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag GeneratorSetup_Decode(GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode source */
+	ret = TriggerGenerator_Decode((&(pVal->source)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode period */
+	    ret = TriggerPeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
+	}
+
+	return ret  && GeneratorSetup_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerOffset_Initialize(TriggerOffset* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag TriggerOffset_IsConstraintValid(const TriggerOffset* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 16777215UL);
+    *pErrCode = ret ? 0 :  ERR_TRIGGEROFFSET;
+
+	return ret;
+}
+
+flag TriggerOffset_Encode(const TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerOffset_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerOffset_Decode(TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGEROFFSET;
+
+	return ret  && TriggerOffset_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerDuration_Initialize(TriggerDuration* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag TriggerDuration_IsConstraintValid(const TriggerDuration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 1023UL);
+    *pErrCode = ret ? 0 :  ERR_TRIGGERDURATION;
+
+	return ret;
+}
+
+flag TriggerDuration_Encode(const TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerDuration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1023);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerDuration_Decode(TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1023);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERDURATION;
+
+	return ret  && TriggerDuration_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ChannelInternal_Initialize(ChannelInternal* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set output_channel */
+	TriggerOutput_Initialize((&(pVal->output_channel)));
+	/*set source */
+	TriggerGenerator_Initialize((&(pVal->source)));
+	/*set offset */
+	TriggerOffset_Initialize((&(pVal->offset)));
+	/*set duration */
+	TriggerDuration_Initialize((&(pVal->duration)));
+	/*set invert */
+	T_Boolean_Initialize((&(pVal->invert)));
+}
+
+flag ChannelInternal_IsConstraintValid(const ChannelInternal* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= pVal->output_channel) && (pVal->output_channel <= 8UL));
+    *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_OUTPUT_CHANNEL;
+    if (ret) {
+        ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
+        *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_SOURCE;
+        if (ret) {
+            ret = (pVal->offset <= 16777215UL);
+            *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_OFFSET;
+            if (ret) {
+                ret = (pVal->duration <= 1023UL);
+                *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_DURATION;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag ChannelInternal_Encode(const ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ChannelInternal_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode output_channel */
+	    ret = TriggerOutput_Encode((&(pVal->output_channel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode source */
+	        ret = TriggerGenerator_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode offset */
+	            ret = TriggerOffset_Encode((&(pVal->offset)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode duration */
+	                ret = TriggerDuration_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode invert */
+	                    ret = T_Boolean_Encode((&(pVal->invert)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ChannelInternal_Decode(ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode output_channel */
+	ret = TriggerOutput_Decode((&(pVal->output_channel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode source */
+	    ret = TriggerGenerator_Decode((&(pVal->source)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode offset */
+	        ret = TriggerOffset_Decode((&(pVal->offset)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode duration */
+	            ret = TriggerDuration_Decode((&(pVal->duration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode invert */
+	                ret = T_Boolean_Decode((&(pVal->invert)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && ChannelInternal_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ChannelExternal_Initialize(ChannelExternal* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set output_channel */
+	TriggerOutput_Initialize((&(pVal->output_channel)));
+	/*set source */
+	TriggerInput_Initialize((&(pVal->source)));
+	/*set offset */
+	TriggerOffset_Initialize((&(pVal->offset)));
+	/*set duration */
+	TriggerDuration_Initialize((&(pVal->duration)));
+	/*set bypass */
+	T_Boolean_Initialize((&(pVal->bypass)));
+	/*set invert */
+	T_Boolean_Initialize((&(pVal->invert)));
+}
+
+flag ChannelExternal_IsConstraintValid(const ChannelExternal* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= pVal->output_channel) && (pVal->output_channel <= 8UL));
+    *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_OUTPUT_CHANNEL;
+    if (ret) {
+        ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
+        *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_SOURCE;
+        if (ret) {
+            ret = (pVal->offset <= 16777215UL);
+            *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_OFFSET;
+            if (ret) {
+                ret = (pVal->duration <= 1023UL);
+                *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_DURATION;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag ChannelExternal_Encode(const ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ChannelExternal_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode output_channel */
+	    ret = TriggerOutput_Encode((&(pVal->output_channel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode source */
+	        ret = TriggerInput_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode offset */
+	            ret = TriggerOffset_Encode((&(pVal->offset)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode duration */
+	                ret = TriggerDuration_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode bypass */
+	                    ret = T_Boolean_Encode((&(pVal->bypass)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode invert */
+	                        ret = T_Boolean_Encode((&(pVal->invert)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ChannelExternal_Decode(ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode output_channel */
+	ret = TriggerOutput_Decode((&(pVal->output_channel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode source */
+	    ret = TriggerInput_Decode((&(pVal->source)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode offset */
+	        ret = TriggerOffset_Decode((&(pVal->offset)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode duration */
+	            ret = TriggerDuration_Decode((&(pVal->duration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode bypass */
+	                ret = T_Boolean_Decode((&(pVal->bypass)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode invert */
+	                    ret = T_Boolean_Decode((&(pVal->invert)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && ChannelExternal_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/Trigger.h b/generated/Trigger.h
new file mode 100644
index 0000000..050f272
--- /dev/null
+++ b/generated/Trigger.h
@@ -0,0 +1,259 @@
+#ifndef GENERATED_ASN1SCC_Trigger_H
+#define GENERATED_ASN1SCC_Trigger_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+
+
+typedef struct {
+
+    T_Boolean arr[8];
+} TriggerMask;
+
+void TriggerMask_Initialize(TriggerMask* pVal);
+
+#define ERR_TRIGGERMASK		11483  /**/
+#define ERR_TRIGGERMASK_ELM		11472  /**/
+flag TriggerMask_IsConstraintValid(const TriggerMask* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TRIGGERMASK		11484  /**/
+#define ERR_UPER_ENCODE_TRIGGERMASK_ELM_2		11479  /**/
+#define TriggerMask_REQUIRED_BYTES_FOR_ENCODING       1
+#define TriggerMask_REQUIRED_BITS_FOR_ENCODING        8
+
+flag TriggerMask_Encode(const TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TRIGGERMASK		11485  /**/
+#define ERR_UPER_DECODE_TRIGGERMASK_ELM_2		11480  /**/
+flag TriggerMask_Decode(TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerGenerator;
+
+
+void TriggerGenerator_Initialize(TriggerGenerator* pVal);
+
+#define ERR_TRIGGERGENERATOR		11430  /**/
+flag TriggerGenerator_IsConstraintValid(const TriggerGenerator* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TRIGGERGENERATOR		11431  /**/
+#define TriggerGenerator_REQUIRED_BYTES_FOR_ENCODING       1
+#define TriggerGenerator_REQUIRED_BITS_FOR_ENCODING        2
+
+flag TriggerGenerator_Encode(const TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TRIGGERGENERATOR		11432  /**/
+flag TriggerGenerator_Decode(TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerInput;
+
+
+void TriggerInput_Initialize(TriggerInput* pVal);
+
+#define ERR_TRIGGERINPUT		11437  /**/
+flag TriggerInput_IsConstraintValid(const TriggerInput* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TRIGGERINPUT		11438  /**/
+#define TriggerInput_REQUIRED_BYTES_FOR_ENCODING       1
+#define TriggerInput_REQUIRED_BITS_FOR_ENCODING        2
+
+flag TriggerInput_Encode(const TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TRIGGERINPUT		11439  /**/
+flag TriggerInput_Decode(TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerOutput;
+
+
+void TriggerOutput_Initialize(TriggerOutput* pVal);
+
+#define ERR_TRIGGEROUTPUT		11444  /**/
+flag TriggerOutput_IsConstraintValid(const TriggerOutput* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TRIGGEROUTPUT		11445  /**/
+#define TriggerOutput_REQUIRED_BYTES_FOR_ENCODING       1
+#define TriggerOutput_REQUIRED_BITS_FOR_ENCODING        3
+
+flag TriggerOutput_Encode(const TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TRIGGEROUTPUT		11446  /**/
+flag TriggerOutput_Decode(TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerPeriod;
+
+
+void TriggerPeriod_Initialize(TriggerPeriod* pVal);
+
+#define ERR_TRIGGERPERIOD		11451  /**/
+flag TriggerPeriod_IsConstraintValid(const TriggerPeriod* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TRIGGERPERIOD		11452  /**/
+#define TriggerPeriod_REQUIRED_BYTES_FOR_ENCODING       3
+#define TriggerPeriod_REQUIRED_BITS_FOR_ENCODING        24
+
+flag TriggerPeriod_Encode(const TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TRIGGERPERIOD		11453  /**/
+flag TriggerPeriod_Decode(TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- GeneratorSetup --------------------------------------------*/
+typedef struct {
+    TriggerGenerator source;
+    TriggerPeriod period;
+
+} GeneratorSetup;
+
+void GeneratorSetup_Initialize(GeneratorSetup* pVal);
+
+#define ERR_GENERATORSETUP		11512  /**/
+#define ERR_GENERATORSETUP_SOURCE		11490  /**/
+#define ERR_GENERATORSETUP_PERIOD		11501  /**/
+flag GeneratorSetup_IsConstraintValid(const GeneratorSetup* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_GENERATORSETUP		11513  /**/
+#define ERR_UPER_ENCODE_GENERATORSETUP_SOURCE_2		11497  /**/
+#define ERR_UPER_ENCODE_GENERATORSETUP_PERIOD_2		11508  /**/
+#define GeneratorSetup_REQUIRED_BYTES_FOR_ENCODING       4
+#define GeneratorSetup_REQUIRED_BITS_FOR_ENCODING        26
+
+flag GeneratorSetup_Encode(const GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_GENERATORSETUP		11514  /**/
+#define ERR_UPER_DECODE_GENERATORSETUP_SOURCE_2		11498  /**/
+#define ERR_UPER_DECODE_GENERATORSETUP_PERIOD_2		11509  /**/
+flag GeneratorSetup_Decode(GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerOffset;
+
+
+void TriggerOffset_Initialize(TriggerOffset* pVal);
+
+#define ERR_TRIGGEROFFSET		11458  /**/
+flag TriggerOffset_IsConstraintValid(const TriggerOffset* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TRIGGEROFFSET		11459  /**/
+#define TriggerOffset_REQUIRED_BYTES_FOR_ENCODING       3
+#define TriggerOffset_REQUIRED_BITS_FOR_ENCODING        24
+
+flag TriggerOffset_Encode(const TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TRIGGEROFFSET		11460  /**/
+flag TriggerOffset_Decode(TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerDuration;
+
+
+void TriggerDuration_Initialize(TriggerDuration* pVal);
+
+#define ERR_TRIGGERDURATION		11465  /**/
+flag TriggerDuration_IsConstraintValid(const TriggerDuration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_TRIGGERDURATION		11466  /**/
+#define TriggerDuration_REQUIRED_BYTES_FOR_ENCODING       2
+#define TriggerDuration_REQUIRED_BITS_FOR_ENCODING        10
+
+flag TriggerDuration_Encode(const TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_TRIGGERDURATION		11467  /**/
+flag TriggerDuration_Decode(TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ChannelInternal --------------------------------------------*/
+typedef struct {
+    TriggerOutput output_channel;
+    TriggerGenerator source;
+    TriggerOffset offset;
+    TriggerDuration duration;
+    T_Boolean invert;
+
+} ChannelInternal;
+
+void ChannelInternal_Initialize(ChannelInternal* pVal);
+
+#define ERR_CHANNELINTERNAL		11574  /**/
+#define ERR_CHANNELINTERNAL_OUTPUT_CHANNEL		11519  /**/
+#define ERR_CHANNELINTERNAL_SOURCE		11530  /**/
+#define ERR_CHANNELINTERNAL_OFFSET		11541  /**/
+#define ERR_CHANNELINTERNAL_DURATION		11552  /**/
+#define ERR_CHANNELINTERNAL_INVERT		11563  /**/
+flag ChannelInternal_IsConstraintValid(const ChannelInternal* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CHANNELINTERNAL		11575  /**/
+#define ERR_UPER_ENCODE_CHANNELINTERNAL_OUTPUT_CHANNEL_2		11526  /**/
+#define ERR_UPER_ENCODE_CHANNELINTERNAL_SOURCE_2		11537  /**/
+#define ERR_UPER_ENCODE_CHANNELINTERNAL_OFFSET_2		11548  /**/
+#define ERR_UPER_ENCODE_CHANNELINTERNAL_DURATION_2		11559  /**/
+#define ERR_UPER_ENCODE_CHANNELINTERNAL_INVERT_2		11570  /**/
+#define ChannelInternal_REQUIRED_BYTES_FOR_ENCODING       5
+#define ChannelInternal_REQUIRED_BITS_FOR_ENCODING        40
+
+flag ChannelInternal_Encode(const ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CHANNELINTERNAL		11576  /**/
+#define ERR_UPER_DECODE_CHANNELINTERNAL_OUTPUT_CHANNEL_2		11527  /**/
+#define ERR_UPER_DECODE_CHANNELINTERNAL_SOURCE_2		11538  /**/
+#define ERR_UPER_DECODE_CHANNELINTERNAL_OFFSET_2		11549  /**/
+#define ERR_UPER_DECODE_CHANNELINTERNAL_DURATION_2		11560  /**/
+#define ERR_UPER_DECODE_CHANNELINTERNAL_INVERT_2		11571  /**/
+flag ChannelInternal_Decode(ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ChannelExternal --------------------------------------------*/
+typedef struct {
+    TriggerOutput output_channel;
+    TriggerInput source;
+    TriggerOffset offset;
+    TriggerDuration duration;
+    T_Boolean bypass;
+    T_Boolean invert;
+
+} ChannelExternal;
+
+void ChannelExternal_Initialize(ChannelExternal* pVal);
+
+#define ERR_CHANNELEXTERNAL		11647  /**/
+#define ERR_CHANNELEXTERNAL_OUTPUT_CHANNEL		11581  /**/
+#define ERR_CHANNELEXTERNAL_SOURCE		11592  /**/
+#define ERR_CHANNELEXTERNAL_OFFSET		11603  /**/
+#define ERR_CHANNELEXTERNAL_DURATION		11614  /**/
+#define ERR_CHANNELEXTERNAL_BYPASS		11625  /**/
+#define ERR_CHANNELEXTERNAL_INVERT		11636  /**/
+flag ChannelExternal_IsConstraintValid(const ChannelExternal* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_CHANNELEXTERNAL		11648  /**/
+#define ERR_UPER_ENCODE_CHANNELEXTERNAL_OUTPUT_CHANNEL_2		11588  /**/
+#define ERR_UPER_ENCODE_CHANNELEXTERNAL_SOURCE_2		11599  /**/
+#define ERR_UPER_ENCODE_CHANNELEXTERNAL_OFFSET_2		11610  /**/
+#define ERR_UPER_ENCODE_CHANNELEXTERNAL_DURATION_2		11621  /**/
+#define ERR_UPER_ENCODE_CHANNELEXTERNAL_BYPASS_2		11632  /**/
+#define ERR_UPER_ENCODE_CHANNELEXTERNAL_INVERT_2		11643  /**/
+#define ChannelExternal_REQUIRED_BYTES_FOR_ENCODING       6
+#define ChannelExternal_REQUIRED_BITS_FOR_ENCODING        41
+
+flag ChannelExternal_Encode(const ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_CHANNELEXTERNAL		11649  /**/
+#define ERR_UPER_DECODE_CHANNELEXTERNAL_OUTPUT_CHANNEL_2		11589  /**/
+#define ERR_UPER_DECODE_CHANNELEXTERNAL_SOURCE_2		11600  /**/
+#define ERR_UPER_DECODE_CHANNELEXTERNAL_OFFSET_2		11611  /**/
+#define ERR_UPER_DECODE_CHANNELEXTERNAL_DURATION_2		11622  /**/
+#define ERR_UPER_DECODE_CHANNELEXTERNAL_BYPASS_2		11633  /**/
+#define ERR_UPER_DECODE_CHANNELEXTERNAL_INVERT_2		11644  /**/
+flag ChannelExternal_Decode(ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/asn1crt.c b/generated/asn1crt.c
new file mode 100644
index 0000000..67b3d40
--- /dev/null
+++ b/generated/asn1crt.c
@@ -0,0 +1,138 @@
+#include <string.h>
+#include <assert.h>
+#include <math.h>
+#include <float.h>
+
+#include <i3ds_asn1/asn1crt.hpp>
+namespace i3ds_asn1 {
+
+
+
+
+
+int GetCharIndex(char ch, byte Set[], int setLen)
+{
+    int i=0;
+    for(i=0; i<setLen; i++)
+        if (ch == Set[i])
+            return i;
+    return 0;
+}
+
+
+
+void ByteStream_Init(ByteStream* pStrm, byte* buf, long count)
+{
+    pStrm->count = count;
+    pStrm->buf = buf;
+    memset(pStrm->buf,0x0,(size_t)count);
+    pStrm->currentByte = 0;
+    pStrm->EncodeWhiteSpace = FALSE;
+}
+
+void ByteStream_AttachBuffer(ByteStream* pStrm, unsigned char* buf, long count)
+{
+    pStrm->count = count;
+    pStrm->buf = buf;
+    pStrm->currentByte = 0;
+}
+
+asn1SccSint ByteStream_GetLength(ByteStream* pStrm)
+{
+    return pStrm->currentByte;
+}
+
+#if WORD_SIZE==8
+const asn1SccUint64 ber_aux[] = {
+    0xFF,
+    0xFF00,
+    0xFF0000,
+    0xFF000000,
+    0xFF00000000ULL,
+    0xFF0000000000ULL,
+    0xFF000000000000ULL,
+    0xFF00000000000000ULL };
+#else
+const asn1SccUint32 ber_aux[] = {
+    0xFF,
+    0xFF00,
+    0xFF0000,
+    0xFF000000 };
+#endif
+
+
+
+asn1SccUint int2uint(asn1SccSint v) {
+    asn1SccUint ret = 0;
+    if (v < 0) {
+        ret = (asn1SccUint)(-v - 1);
+        ret = ~ret;
+    }
+    else {
+        ret = (asn1SccUint)v;
+    };
+    return ret;
+}
+
+asn1SccSint uint2int(asn1SccUint v, int uintSizeInBytes) {
+    int i;
+    asn1SccUint tmp = 0x80;
+    flag bIsNegative = (v & (tmp << ((uintSizeInBytes - 1) * 8)))>0;
+    if (!bIsNegative)
+        return (asn1SccSint)v;
+    for (i = WORD_SIZE - 1; i >= uintSizeInBytes; i--)
+        v |= ber_aux[i];
+    return -(asn1SccSint)(~v) - 1;
+}
+
+
+
+/*
+
+#######                                      ###
+#     # #####       # ######  ####  #####     #  #####  ###### #    # ##### # ###### # ###### #####
+#     # #    #      # #      #    #   #       #  #    # #      ##   #   #   # #      # #      #    #
+#     # #####       # #####  #        #       #  #    # #####  # #  #   #   # #####  # #####  #    #
+#     # #    #      # #      #        #       #  #    # #      #  # #   #   # #      # #      #####
+#     # #    # #    # #      #    #   #       #  #    # #      #   ##   #   # #      # #      #   #
+####### #####   ####  ######  ####    #      ### #####  ###### #    #   #   # #      # ###### #    #
+
+Object Identifier
+
+*/
+
+void ObjectIdentifier_Init(Asn1ObjectIdentifier *pVal) {
+	int i;
+	for (i = 0; i < OBJECT_IDENTIFIER_MAX_LENGTH; i++) {
+		pVal->values[i] = 0;
+	}
+	pVal->nCount = 0;
+}
+
+flag ObjectIdentifier_isValid(const Asn1ObjectIdentifier *pVal) {
+	return (pVal->nCount >= 2) && (pVal->values[0] <= 2) && (pVal->values[1] <= 39);
+}
+
+flag RelativeOID_isValid(const Asn1ObjectIdentifier *pVal) {
+	return pVal->nCount > 0;
+}
+
+flag ObjectIdentifier_equal(const Asn1ObjectIdentifier *pVal1, const Asn1ObjectIdentifier *pVal2) {
+	int i;
+	if ((pVal1 != NULL) && (pVal2 != NULL) && pVal1->nCount == pVal2->nCount && pVal1->nCount <= OBJECT_IDENTIFIER_MAX_LENGTH) {
+		flag ret = true;
+		for (i = 0; i < pVal1->nCount && ret; i++)
+		{
+			ret = (pVal1->values[i] == pVal2->values[i]);
+		}
+		return ret;
+	}
+	else {
+		return FALSE;
+	}
+}
+
+
+
+} // namespace i3ds_asn1
+
diff --git a/generated/asn1crt.h b/generated/asn1crt.h
new file mode 100644
index 0000000..493b116
--- /dev/null
+++ b/generated/asn1crt.h
@@ -0,0 +1,175 @@
+#ifndef ASN1SCC_ASN1CRT_H_
+#define ASN1SCC_ASN1CRT_H_
+
+#include <stddef.h>
+namespace i3ds_asn1 {
+
+#if (!defined(_MSC_VER) || _MSC_VER >= 1800)
+#  ifndef SWIG
+#    include <stdbool.h>
+#  endif
+#else
+typedef unsigned char bool;
+#define true 1
+#define false 0
+#endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifndef NULL
+#define NULL	0
+#endif
+
+#ifndef TRUE
+#define TRUE	true
+#endif
+
+#ifndef FALSE
+#define FALSE	false
+#endif
+
+#ifndef WORD_SIZE
+#define WORD_SIZE	8
+#endif
+
+#ifndef FP_WORD_SIZE
+#define FP_WORD_SIZE	8
+#endif
+
+#define OBJECT_IDENTIFIER_MAX_LENGTH	20
+
+typedef float asn1Real32;
+typedef double asn1Real64;
+
+
+
+typedef unsigned char byte;
+
+typedef int asn1SccSint32;
+typedef unsigned int asn1SccUint32;
+
+typedef long long asn1SccSint64;
+typedef unsigned long long asn1SccUint64;
+
+#if WORD_SIZE==8
+typedef asn1SccUint64 asn1SccUint;
+typedef asn1SccSint64 asn1SccSint;
+#else
+typedef asn1SccUint32 asn1SccUint;
+typedef asn1SccSint32 asn1SccSint;
+#endif
+
+#if FP_WORD_SIZE==8
+typedef asn1Real64 asn1Real;
+#else
+typedef asn1Real32 asn1Real;
+#endif
+
+
+#ifdef _MSC_VER
+#  ifndef INFINITY
+#    define INFINITY (DBL_MAX+DBL_MAX)
+#  endif
+#  ifndef NAN
+#    define NAN (INFINITY-INFINITY)
+#  endif
+#endif
+
+typedef bool flag;
+
+typedef char NullType;
+
+typedef struct {
+	byte* buf;
+	long count;
+	long currentByte;
+	/* Next available bit for writting. Possible vallues 0..7, 0 is most significant bit of current byte*/
+	int currentBit;
+} BitStream;
+
+typedef struct {
+	byte* buf;
+	long count;
+	long currentByte;
+	flag EncodeWhiteSpace;
+} ByteStream;
+
+typedef struct {
+	int TokenID;
+	char Value[100];
+} Token;
+
+typedef struct {
+	char Name[50];
+	char Value[100];
+} XmlAttribute;
+
+typedef struct {
+	XmlAttribute attrs[20];
+	int nCount;
+} XmlAttributeArray;
+
+typedef struct {
+	int nCount;
+	asn1SccUint values[OBJECT_IDENTIFIER_MAX_LENGTH];
+} Asn1ObjectIdentifier;
+
+#define ERR_INSUFFICIENT_DATA	101
+#define ERR_INCORRECT_PER_STREAM	102
+#define ERR_INVALID_CHOICE_ALTERNATIVE	103
+#define ERR_INVALID_ENUM_VALUE	104
+#define ERR_INVALID_XML_FILE	200
+#define ERR_INVALID_BER_FILE	201
+#define ERR_BER_LENGTH_MISMATCH	202
+
+
+
+flag OctetString_equal(int len1, int len2, const byte arr1[], const byte arr2[]);
+flag BitString_equal(int nBitsLength1, int nBitsLength2, const byte arr1[], const byte arr2[]);
+void ObjectIdentifier_Init(Asn1ObjectIdentifier *pVal);
+flag ObjectIdentifier_equal(const Asn1ObjectIdentifier *pVal1, const Asn1ObjectIdentifier *pVal2);
+flag ObjectIdentifier_isValid(const Asn1ObjectIdentifier *pVal);
+flag RelativeOID_isValid(const Asn1ObjectIdentifier *pVal);
+
+
+int GetCharIndex(char ch, byte allowedCharSet[], int setLen);
+
+
+
+
+
+
+
+typedef asn1SccUint BerTag;
+
+
+
+
+
+
+#if WORD_SIZE==8
+extern const asn1SccUint64 ber_aux[];
+#else
+extern const asn1SccUint32 ber_aux[];
+#endif
+
+
+
+
+#define CHECK_BIT_STREAM(pBitStrm)	assert((pBitStrm)->currentByte*8+(pBitStrm)->currentBit<=(pBitStrm)->count*8)
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4127)
+#endif
+
+#define ASSERT_OR_RETURN_FALSE(_Expression) do { assert(_Expression); if (!(_Expression)) return FALSE;} while(0)
+
+#ifdef  __cplusplus
+}
+#endif
+
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/asn1crt_encoding.c b/generated/asn1crt_encoding.c
new file mode 100644
index 0000000..fe8e14a
--- /dev/null
+++ b/generated/asn1crt_encoding.c
@@ -0,0 +1,981 @@
+#include <string.h>
+#include <assert.h>
+#include <math.h>
+#include <float.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+namespace i3ds_asn1 {
+
+
+
+static byte masks[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
+static byte masksb[] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F, 0xFF };
+
+static asn1SccUint32 masks2[] = { 0x0,
+0xFF,
+0xFF00,
+0xFF0000,
+0xFF000000 };
+
+/***********************************************************************************************/
+/*   Bit Stream Functions                                                                      */
+/***********************************************************************************************/
+
+flag OctetString_equal(int len1, int len2, const byte arr1[], const byte arr2[])
+{
+	return (len1 == len2) && (memcmp(arr1, arr2, len1) == 0);
+}
+
+flag BitString_equal(int nBitsLength1, int nBitsLength2, const byte arr1[], const byte arr2[])
+{
+	return
+		(nBitsLength1 == nBitsLength2) &&
+		(nBitsLength1 / 8 == 0 || memcmp(arr1, arr2, nBitsLength1 / 8) == 0) &&
+		(nBitsLength1 % 8 > 0 ? (arr1[nBitsLength1 / 8] >> (8 - nBitsLength1 % 8) == arr2[nBitsLength1 / 8] >> (8 - nBitsLength1 % 8)) : TRUE);
+}
+
+
+void BitStream_Init(BitStream* pBitStrm, unsigned char* buf, long count)
+{
+	pBitStrm->count = count;
+	pBitStrm->buf = buf;
+	memset(pBitStrm->buf, 0x0, (size_t)count);
+	pBitStrm->currentByte = 0;
+	pBitStrm->currentBit = 0;
+}
+
+void BitStream_AttachBuffer(BitStream* pBitStrm, unsigned char* buf, long count)
+{
+	pBitStrm->count = count;
+	pBitStrm->buf = buf;
+	pBitStrm->currentByte = 0;
+	pBitStrm->currentBit = 0;
+}
+
+asn1SccSint BitStream_GetLength(BitStream* pBitStrm)
+{
+	int ret = pBitStrm->currentByte;
+	if (pBitStrm->currentBit)
+		ret++;
+	return ret;
+}
+
+
+void BitStream_AppendBitOne(BitStream* pBitStrm)
+{
+	pBitStrm->buf[pBitStrm->currentByte] |= masks[pBitStrm->currentBit];
+
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+}
+
+void BitStream_AppendBitZero(BitStream* pBitStrm)
+{
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+}
+
+void BitStream_AppendNBitZero(BitStream* pBitStrm, int nbits)
+{
+	int totalBits = pBitStrm->currentBit + nbits;
+	pBitStrm->currentBit = totalBits % 8;
+	pBitStrm->currentByte += totalBits / 8;
+}
+
+void BitStream_AppendNBitOne(BitStream* pBitStrm, int nbits)
+{
+	int i;
+
+	while (nbits >= 8) {
+		BitStream_AppendByte(pBitStrm, 0xFF, FALSE);
+		nbits -= 8;
+	}
+	for (i = 0; i<nbits; i++)
+		BitStream_AppendBitOne(pBitStrm);
+
+}
+
+void BitStream_AppendBits(BitStream* pBitStrm, const byte* srcBuffer, int nbits)
+{
+	int i = 0;
+	byte lastByte = 0;
+
+	while (nbits >= 8) {
+		BitStream_AppendByte(pBitStrm, srcBuffer[i], FALSE);
+		nbits -= 8;
+		i++;
+	}
+	if (nbits > 0) {
+		lastByte = (byte)(srcBuffer[i] >> (8 - nbits));
+		BitStream_AppendPartialByte(pBitStrm, lastByte, (byte)nbits, FALSE);
+	}
+}
+
+void BitStream_AppendBit(BitStream* pBitStrm, flag v)
+{
+	if (v)
+		pBitStrm->buf[pBitStrm->currentByte] |= masks[pBitStrm->currentBit];
+
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+}
+
+
+flag BitStream_ReadBit(BitStream* pBitStrm, flag* v)
+{
+	*v = pBitStrm->buf[pBitStrm->currentByte] & masks[pBitStrm->currentBit];
+
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	return pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8;
+}
+
+void BitStream_AppendByte(BitStream* pBitStrm, byte v, flag negate)
+{
+	int cb = pBitStrm->currentBit;
+	int ncb = 8 - cb;
+	if (negate)
+		v = (byte)~v;
+	pBitStrm->buf[pBitStrm->currentByte++] |= (byte)(v >> cb);
+
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+
+	if (cb)
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << ncb);
+
+}
+
+void BitStream_AppendByte0(BitStream* pBitStrm, byte v)
+{
+	int cb = pBitStrm->currentBit;
+	int ncb = 8 - cb;
+
+	pBitStrm->buf[pBitStrm->currentByte++] |= (byte)(v >> cb);
+
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+
+	if (cb)
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << ncb);
+
+}
+
+
+flag BitStream_ReadByte(BitStream* pBitStrm, byte* v)
+{
+	int cb = pBitStrm->currentBit;
+	int ncb = 8 - pBitStrm->currentBit;
+	*v = (byte)(pBitStrm->buf[pBitStrm->currentByte++] << cb);
+
+	if (cb) {
+		*v |= (byte)(pBitStrm->buf[pBitStrm->currentByte] >> ncb);
+	}
+
+	return pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8;
+}
+
+flag BitStream_ReadBits(BitStream* pBitStrm, byte* BuffToWrite, int nbits)
+{
+	int i = 0;
+
+	while (nbits >= 8) {
+		if (!BitStream_ReadByte(pBitStrm, &BuffToWrite[i]))
+			return FALSE;
+		nbits -= 8;
+		i++;
+	}
+
+	if (nbits > 0) {
+		if (!BitStream_ReadPartialByte(pBitStrm, &BuffToWrite[i], (byte)nbits))
+			return FALSE;
+		BuffToWrite[i] = (byte)(BuffToWrite[i] << (8 - nbits));
+	}
+
+	return TRUE;
+}
+
+/* nbits 1..7*/
+void BitStream_AppendPartialByte(BitStream* pBitStrm, byte v, byte nbits, flag negate)
+{
+	int cb = pBitStrm->currentBit;
+	int totalBits = cb + nbits;
+	int totalBitsForNextByte;
+	if (negate)
+		v = masksb[nbits] & ((byte)~v);
+
+	if (totalBits <= 8) {
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << (8 - totalBits));
+		pBitStrm->currentBit += nbits;
+		if (pBitStrm->currentBit == 8) {
+			pBitStrm->currentBit = 0;
+			pBitStrm->currentByte++;
+		}
+	}
+	else {
+		totalBitsForNextByte = totalBits - 8;
+		pBitStrm->buf[pBitStrm->currentByte++] |= (byte)(v >> totalBitsForNextByte);
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << (8 - totalBitsForNextByte));
+		pBitStrm->currentBit = totalBitsForNextByte;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+
+}
+
+/* nbits 1..7*/
+flag BitStream_ReadPartialByte(BitStream* pBitStrm, byte *v, byte nbits)
+{
+	int cb = pBitStrm->currentBit;
+	int totalBits = cb + nbits;
+	int totalBitsForNextByte;
+
+	if (totalBits <= 8) {
+		*v = (byte)((pBitStrm->buf[pBitStrm->currentByte] >> (8 - totalBits)) & masksb[nbits]);
+		pBitStrm->currentBit += nbits;
+		if (pBitStrm->currentBit == 8) {
+			pBitStrm->currentBit = 0;
+			pBitStrm->currentByte++;
+		}
+	}
+	else {
+		totalBitsForNextByte = totalBits - 8;
+		*v = (byte)(pBitStrm->buf[pBitStrm->currentByte++] << totalBitsForNextByte);
+		*v |= (byte)(pBitStrm->buf[pBitStrm->currentByte] >> (8 - totalBitsForNextByte));
+		*v &= masksb[nbits];
+		pBitStrm->currentBit = totalBitsForNextByte;
+	}
+	return pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8;
+}
+
+
+
+
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+/*   Integer Functions                                                                     */
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+
+
+
+static void BitStream_EncodeNonNegativeInteger32Neg(BitStream* pBitStrm,
+	asn1SccUint32 v,
+	flag negate)
+{
+	int cc;
+	asn1SccUint32 curMask;
+	int pbits;
+
+	if (v == 0)
+		return;
+
+	if (v<0x100) {
+		cc = 8;
+		curMask = 0x80;
+	}
+	else if (v<0x10000) {
+		cc = 16;
+		curMask = 0x8000;
+	}
+	else if (v<0x1000000) {
+		cc = 24;
+		curMask = 0x800000;
+	}
+	else {
+		cc = 32;
+		curMask = 0x80000000;
+	}
+
+	while ((v & curMask) == 0) {
+		curMask >>= 1;
+		cc--;
+	}
+
+	pbits = cc % 8;
+	if (pbits) {
+		cc -= pbits;
+		BitStream_AppendPartialByte(pBitStrm, (byte)(v >> cc), (byte)pbits, negate);
+	}
+
+	while (cc) {
+		asn1SccUint32 t1 = v & masks2[cc >> 3];
+		cc -= 8;
+		BitStream_AppendByte(pBitStrm, (byte)(t1 >> cc), negate);
+	}
+
+}
+
+static flag BitStream_DecodeNonNegativeInteger32Neg(BitStream* pBitStrm,
+	asn1SccUint32* v,
+	int nBits)
+{
+	byte b;
+	*v = 0;
+	while (nBits >= 8) {
+		*v <<= 8;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		*v |= b;
+		nBits -= 8;
+	}
+	if (nBits)
+	{
+		*v <<= nBits;
+		if (!BitStream_ReadPartialByte(pBitStrm, &b, (byte)nBits))
+			return FALSE;
+		*v |= b;
+	}
+
+	return TRUE;
+}
+
+
+
+void BitStream_EncodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint v)
+{
+
+#if WORD_SIZE==8
+	if (v<0x100000000LL)
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, (asn1SccUint32)v, 0);
+	else {
+		asn1SccUint32 hi = (asn1SccUint32)(v >> 32);
+		asn1SccUint32 lo = (asn1SccUint32)v;
+		int nBits;
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, hi, 0);
+
+		nBits = GetNumberOfBitsForNonNegativeInteger(lo);
+		BitStream_AppendNBitZero(pBitStrm, 32 - nBits);
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, lo, 0);
+	}
+#else
+	BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, v, 0);
+#endif
+}
+
+
+flag BitStream_DecodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint* v, int nBits)
+{
+#if WORD_SIZE==8
+	asn1SccUint32 hi = 0;
+	asn1SccUint32 lo = 0;
+	flag ret;
+
+	if (nBits <= 32)
+	{
+		ret = BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, &lo, nBits);
+		*v = lo;
+		return ret;
+	}
+
+	ret = BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, &hi, 32) && BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, &lo, nBits - 32);
+
+	*v = hi;
+	*v <<= nBits - 32;
+	*v |= lo;
+	return ret;
+#else
+	return BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, v, nBits);
+#endif
+}
+
+
+void BitStream_EncodeNonNegativeIntegerNeg(BitStream* pBitStrm, asn1SccUint v, flag negate)
+{
+#if WORD_SIZE==8
+	if (v<0x100000000LL)
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, (asn1SccUint32)v, negate);
+	else {
+		int nBits;
+		asn1SccUint32 hi = (asn1SccUint32)(v >> 32);
+		asn1SccUint32 lo = (asn1SccUint32)v;
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, hi, negate);
+
+		/*bug !!!!*/
+		if (negate)
+			lo = ~lo;
+		nBits = GetNumberOfBitsForNonNegativeInteger(lo);
+		BitStream_AppendNBitZero(pBitStrm, 32 - nBits);
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, lo, 0);
+	}
+#else
+	BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, v, negate);
+#endif
+}
+
+static int GetNumberOfBitsForNonNegativeInteger32(asn1SccUint32 v)
+{
+	int ret = 0;
+
+	if (v<0x100) {
+		ret = 0;
+	}
+	else if (v<0x10000) {
+		ret = 8;
+		v >>= 8;
+	}
+	else if (v<0x1000000) {
+		ret = 16;
+		v >>= 16;
+	}
+	else {
+		ret = 24;
+		v >>= 24;
+	}
+	while (v>0) {
+		v >>= 1;
+		ret++;
+	}
+	return ret;
+}
+
+int GetNumberOfBitsForNonNegativeInteger(asn1SccUint v)
+{
+#if WORD_SIZE==8
+	if (v<0x100000000LL)
+		return GetNumberOfBitsForNonNegativeInteger32((asn1SccUint32)v);
+	else {
+		asn1SccUint32 hi = (asn1SccUint32)(v >> 32);
+		return 32 + GetNumberOfBitsForNonNegativeInteger32(hi);
+	}
+#else
+	return GetNumberOfBitsForNonNegativeInteger32(v);
+#endif
+}
+
+int GetLengthInBytesOfUInt(asn1SccUint64 v)
+{
+	int ret = 0;
+	asn1SccUint32 v32 = (asn1SccUint32)v;
+#if WORD_SIZE==8
+	if (v>0xFFFFFFFF) {
+		ret = 4;
+		v32 = (asn1SccUint32)(v >> 32);
+	}
+#endif
+
+	if (v32<0x100)
+		return ret + 1;
+	if (v32<0x10000)
+		return ret + 2;
+	if (v32<0x1000000)
+		return ret + 3;
+	return ret + 4;
+}
+
+static int GetLengthSIntHelper(asn1SccUint v)
+{
+	int ret = 0;
+	asn1SccUint32 v32 = (asn1SccUint32)v;
+#if WORD_SIZE==8
+	if (v>0x7FFFFFFF) {
+		ret = 4;
+		v32 = (asn1SccUint32)(v >> 32);
+	}
+#endif
+
+	if (v32 <= 0x7F)
+		return ret + 1;
+	if (v32 <= 0x7FFF)
+		return ret + 2;
+	if (v32 <= 0x7FFFFF)
+		return ret + 3;
+	return ret + 4;
+}
+
+int GetLengthInBytesOfSInt(asn1SccSint v)
+{
+	if (v >= 0)
+		return GetLengthSIntHelper((asn1SccUint)v);
+
+	return GetLengthSIntHelper((asn1SccUint)(-v - 1));
+}
+
+
+
+void BitStream_EncodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min, asn1SccSint max)
+{
+	int nRangeBits;
+	int nBits;
+	asn1SccUint range;
+	assert(min <= max);
+	range = (asn1SccUint)(max - min);
+	if (!range)
+		return;
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+	nBits = GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(v - min));
+	BitStream_AppendNBitZero(pBitStrm, nRangeBits - nBits);
+	BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)(v - min));
+}
+
+void BitStream_EncodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min, asn1SccUint max)
+{
+	int nRangeBits;
+	int nBits;
+	asn1SccUint range;
+	assert(min <= v);
+	assert(v <= max);
+	range = (asn1SccUint)(max - min);
+	if (!range)
+		return;
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+	nBits = GetNumberOfBitsForNonNegativeInteger(v - min);
+	BitStream_AppendNBitZero(pBitStrm, nRangeBits - nBits);
+	BitStream_EncodeNonNegativeInteger(pBitStrm, v - min);
+}
+
+
+flag BitStream_DecodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min, asn1SccSint max)
+{
+	asn1SccUint uv;
+	int nRangeBits;
+	asn1SccUint range = (asn1SccUint)(max - min);
+
+	ASSERT_OR_RETURN_FALSE(min <= max);
+
+
+	*v = 0;
+	if (!range) {
+		*v = min;
+		return TRUE;
+	}
+
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+
+
+	if (BitStream_DecodeNonNegativeInteger(pBitStrm, &uv, nRangeBits))
+	{
+		*v = ((asn1SccSint)uv) + min;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+flag BitStream_DecodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min, asn1SccUint max)
+{
+	asn1SccUint uv;
+	int nRangeBits;
+	asn1SccUint range = max - min;
+
+	ASSERT_OR_RETURN_FALSE(min <= max);
+
+
+	*v = 0;
+	if (!range) {
+		*v = min;
+		return TRUE;
+	}
+
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+
+	if (BitStream_DecodeNonNegativeInteger(pBitStrm, &uv, nRangeBits))
+	{
+		*v = uv + min;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+
+void BitStream_EncodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min)
+{
+	int nBytes;
+	assert(v >= min);
+	nBytes = GetLengthInBytesOfUInt((asn1SccUint)(v - min));
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, nBytes, 0, 255); /*8 bits, first bit is always 0*/
+																	 /* put required zeros*/
+	BitStream_AppendNBitZero(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(v - min)));
+	/*Encode number */
+	BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)(v - min));
+}
+
+void BitStream_EncodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min)
+{
+	int nBytes;
+	assert(v >= min);
+	nBytes = GetLengthInBytesOfUInt(v - min);
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, nBytes, 0, 255); /*8 bits, first bit is always 0*/
+																	 /* put required zeros*/
+	BitStream_AppendNBitZero(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger(v - min));
+	/*Encode number */
+	BitStream_EncodeNonNegativeInteger(pBitStrm, (v - min));
+}
+
+
+flag BitStream_DecodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min)
+{
+	asn1SccSint nBytes;
+	int i;
+	*v = 0;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nBytes, 0, 255))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		*v = (*v << 8) | b;
+	}
+	*v += min;
+	return TRUE;
+}
+
+flag BitStream_DecodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min)
+{
+	asn1SccSint nBytes;
+	int i;
+	*v = 0;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nBytes, 0, 255))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		*v = (*v << 8) | b;
+	}
+	*v += min;
+	return TRUE;
+}
+
+
+void BitStream_EncodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v)
+{
+	int nBytes = GetLengthInBytesOfSInt(v);
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, nBytes, 0, 255); /*8 bits, first bit is always 0*/
+
+	if (v >= 0) {
+		BitStream_AppendNBitZero(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)v));
+		BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)(v));
+	}
+	else {
+		BitStream_AppendNBitOne(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(-v - 1)));
+		BitStream_EncodeNonNegativeIntegerNeg(pBitStrm, (asn1SccUint)(-v - 1), 1);
+	}
+}
+
+flag BitStream_DecodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v)
+{
+	asn1SccSint nBytes;
+	int i;
+	flag valIsNegative = FALSE;
+	*v = 0;
+
+
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nBytes, 0, 255))
+		return FALSE;
+
+
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (!i) {
+			valIsNegative = b>0x7F;
+			if (valIsNegative)
+				*v = -1;
+		}
+		*v = (*v << 8) | b;
+	}
+	return TRUE;
+}
+
+
+
+#ifndef INFINITY
+#ifdef __GNUC__
+#define INFINITY (__builtin_inf())
+#endif
+#endif
+
+/*
+Bynary encoding will be used
+REAL = M*B^E
+where
+M = S*N*2^F
+
+ENCODING is done within three parts
+part 1 is 1 byte header
+part 2 is 1 or more byte for exponent
+part 3 is 3 or more byte for mantissa (N)
+
+First byte
+S :0-->+, S:1-->-1
+Base will be always be 2 (implied by 6th and 5th bit which are zero)
+ab: F  (0..3)
+cd:00 --> 1 byte for exponent as 2's complement
+cd:01 --> 2 byte for exponent as 2's complement
+cd:10 --> 3 byte for exponent as 2's complement
+cd:11 --> 1 byte for encoding the length of the exponent, then the expoent
+
+8 7 6 5 4 3 2 1
++-+-+-+-+-+-+-+-+
+|1|S|0|0|a|b|c|d|
++-+-+-+-+-+-+-+-+
+*/
+
+#if FP_WORD_SIZE==8
+
+#define ExpoBitMask  0x7FF0000000000000ULL
+#define MantBitMask  0x000FFFFFFFFFFFFFULL
+#define MantBitMask2 0xFFE0000000000000ULL
+#define MantisaExtraBit 0x0010000000000000ULL
+#else				
+
+#define ExpoBitMask  0x7F800000U
+#define MantBitMask  0x007FFFFFU
+#define MantBitMask2 0xF0000000U
+#define MantisaExtraBit 0x00800000U
+
+#endif
+
+
+void CalculateMantissaAndExponent(asn1Real d, int* exponent, asn1SccUint64* mantissa)
+{
+
+#if FP_WORD_SIZE==8
+	union {
+		asn1Real in;
+		asn1SccUint64 out;
+	} double2uint;
+	asn1SccUint64 ll = 0;
+#else
+	union {
+		asn1Real in;
+		asn1SccUint32 out;
+	} double2uint;
+	asn1SccUint32 ll = 0;
+#endif
+
+	double2uint.in = d;
+	ll = double2uint.out;
+
+	*exponent = 0;
+	*mantissa = 0;
+
+#if FP_WORD_SIZE==8
+	* exponent = (int)(((ll & ExpoBitMask) >> 52) - 1023 - 52);
+	*mantissa = ll & MantBitMask;
+	(*mantissa) |= MantisaExtraBit;
+#else
+	*exponent = (int)(((ll & ExpoBitMask) >> 23) - 127 - 23);
+
+	*mantissa = ll & MantBitMask;
+	(*mantissa) |= MantisaExtraBit;
+#endif
+}
+
+asn1Real GetDoubleByMantissaAndExp(asn1SccUint mantissa, int exponent)
+{
+	asn1Real ret = 1.0;
+	if (mantissa == 0)
+		return 0.0;
+
+	if (exponent >= 0) {
+		while (exponent) {
+			ret = ret * 2.0;
+			exponent--;
+		}
+		return (asn1Real)mantissa*ret;
+	}
+	else {
+		exponent = -exponent;
+		while (exponent) {
+			ret = ret * 2.0;
+			exponent--;
+		}
+		return ((asn1Real)mantissa) / ret;
+	}
+}
+
+
+
+
+void BitStream_EncodeReal(BitStream* pBitStrm, asn1Real v)
+{
+	byte header = 0x80;
+	int nExpLen;
+	int nManLen;
+	int exponent;
+	asn1SccUint64 mantissa;
+
+
+	if (v == 0.0)
+	{
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0xFF);
+		return;
+	}
+
+	if (v == INFINITY)
+	{
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 0xFF);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0x40, 0, 0xFF);
+		return;
+	}
+
+	if (v == -INFINITY)
+	{
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 0xFF);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0x41, 0, 0xFF);
+		return;
+	}
+	if (v < 0) {
+		header |= 0x40;
+		v = -v;
+	}
+
+	CalculateMantissaAndExponent(v, &exponent, &mantissa);
+	nExpLen = GetLengthInBytesOfSInt(exponent);
+	nManLen = GetLengthInBytesOfUInt(mantissa);
+	assert(nExpLen <= 3);
+	if (nExpLen == 2)
+		header |= 1;
+	else if (nExpLen == 3)
+		header |= 2;
+
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1 + nExpLen + nManLen, 0, 0xFF);
+
+	/* encode header */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, header, 0, 0xFF);
+
+	/* encode exponent */
+	if (exponent >= 0) {
+		BitStream_AppendNBitZero(pBitStrm, nExpLen * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)exponent));
+		BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)exponent);
+	}
+	else {
+		BitStream_AppendNBitOne(pBitStrm, nExpLen * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(-exponent - 1)));
+		BitStream_EncodeNonNegativeIntegerNeg(pBitStrm, (asn1SccUint)(-exponent - 1), 1);
+	}
+
+
+	/* encode mantissa */
+	BitStream_AppendNBitZero(pBitStrm, nManLen * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(mantissa)));
+	BitStream_EncodeNonNegativeInteger(pBitStrm, mantissa);
+
+}
+
+flag DecodeRealAsBinaryEncoding(BitStream* pBitStrm, int length, byte header, asn1Real* v);
+
+flag BitStream_DecodeReal(BitStream* pBitStrm, asn1Real* v)
+{
+	byte header;
+	byte length;
+
+	if (!BitStream_ReadByte(pBitStrm, &length))
+		return FALSE;
+	if (length == 0)
+	{
+		*v = 0.0;
+		return TRUE;
+	}
+
+	if (!BitStream_ReadByte(pBitStrm, &header))
+		return FALSE;
+
+	if (header == 0x40)
+	{
+		*v = INFINITY;
+		return TRUE;
+	}
+
+	if (header == 0x41)
+	{
+		*v = -INFINITY;
+		return TRUE;
+	}
+
+	return DecodeRealAsBinaryEncoding(pBitStrm, length - 1, header, v);
+}
+
+
+flag DecodeRealAsBinaryEncoding(BitStream* pBitStrm, int length, byte header, asn1Real* v)
+{
+	int sign = 1;
+	/*int base=2;*/
+	int F;
+	unsigned factor = 1;
+	int expLen;
+	int exponent = 0;
+	int expFactor = 1;
+	asn1SccUint N = 0;
+	int i;
+
+	if (header & 0x40)
+		sign = -1;
+	if (header & 0x10) {
+		/*base = 8;*/
+		expFactor = 3;
+	}
+	else if (header & 0x20) {
+		/*base = 16;*/
+		expFactor = 4;
+	}
+
+	F = (header & 0x0C) >> 2;
+	factor <<= F;
+
+	expLen = (header & 0x03) + 1;
+
+	if (expLen>length)
+		return FALSE;
+
+	for (i = 0; i<expLen; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (!i) {
+			if (b>0x7F)
+				exponent = -1;
+		}
+		exponent = exponent << 8 | b;
+	}
+	length -= expLen;
+
+	for (i = 0; i<length; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		N = N << 8 | b;
+	}
+
+
+	/*  *v = N*factor * pow(base,exp);*/
+	*v = GetDoubleByMantissaAndExp(N*factor, expFactor*exponent);
+
+	if (sign<0)
+		*v = -(*v);
+
+
+	return TRUE;
+}
+
+
+} // namespace i3ds_asn1
+
diff --git a/generated/asn1crt_encoding.h b/generated/asn1crt_encoding.h
new file mode 100644
index 0000000..69c36bd
--- /dev/null
+++ b/generated/asn1crt_encoding.h
@@ -0,0 +1,80 @@
+#ifndef ASN1SCC_ASN1CRT_ENCODING_H_
+#define ASN1SCC_ASN1CRT_ENCODING_H_
+
+#include <i3ds_asn1/asn1crt.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* Bit strean functions */
+
+void BitStream_AppendNBitZero(BitStream* pBitStrm, int nbits);
+void BitStream_EncodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint v);
+void BitStream_AppendNBitOne(BitStream* pBitStrm, int nbits);
+void BitStream_EncodeNonNegativeIntegerNeg(BitStream* pBitStrm, asn1SccUint v, flag negate);
+flag BitStream_DecodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint* v, int nBits);
+flag BitStream_ReadPartialByte(BitStream* pBitStrm, byte *v, byte nbits);
+void BitStream_AppendPartialByte(BitStream* pBitStrm, byte v, byte nbits, flag negate);
+
+
+
+
+
+void BitStream_Init(BitStream* pBitStrm, unsigned char* buf, long count);
+void BitStream_AttachBuffer(BitStream* pBitStrm, unsigned char* buf, long count);
+void BitStream_AppendBit(BitStream* pBitStrm, flag v);
+void BitStream_AppendBits(BitStream* pBitStrm, const byte* srcBuffer, int nBitsToWrite);
+void BitStream_AppendByte(BitStream* pBitStrm, byte v, flag negate);
+void BitStream_AppendByte0(BitStream* pBitStrm, byte v);
+
+
+void ByteStream_Init(ByteStream* pStrm, byte* buf, long count);
+void ByteStream_AttachBuffer(ByteStream* pStrm, unsigned char* buf, long count);
+asn1SccSint ByteStream_GetLength(ByteStream* pStrm);
+
+asn1SccSint BitStream_GetLength(BitStream* pBitStrm);
+void BitStream_AppendBitOne(BitStream* pBitStrm);
+void BitStream_AppendBitZero(BitStream* pBitStrm);
+flag BitStream_ReadBit(BitStream* pBitStrm, flag* v);
+flag BitStream_ReadBits(BitStream* pBitStrm, byte* BuffToWrite, int nBitsToRead);
+flag BitStream_ReadByte(BitStream* pBitStrm, byte* v);
+
+/* Integer functions */
+
+
+void BitStream_EncodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v);
+void BitStream_EncodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min);
+void BitStream_EncodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min);
+void BitStream_EncodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min, asn1SccSint max);
+void BitStream_EncodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min, asn1SccUint max);
+
+flag BitStream_DecodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v);
+flag BitStream_DecodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min);
+flag BitStream_DecodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min);
+flag BitStream_DecodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min, asn1SccSint max);
+flag BitStream_DecodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min, asn1SccUint max);
+
+asn1SccUint int2uint(asn1SccSint v);
+asn1SccSint uint2int(asn1SccUint v, int uintSizeInBytes);
+
+int GetNumberOfBitsForNonNegativeInteger(asn1SccUint v);
+
+void CalculateMantissaAndExponent(asn1Real d, int* exp, asn1SccUint64* mantissa);
+asn1Real GetDoubleByMantissaAndExp(asn1SccUint mantissa, int exp);
+
+int GetLengthInBytesOfSInt(asn1SccSint v);
+int GetLengthInBytesOfUInt(asn1SccUint64 v);
+
+void BitStream_EncodeReal(BitStream* pBitStrm, asn1Real v);
+flag BitStream_DecodeReal(BitStream* pBitStrm, asn1Real* v);
+
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/asn1crt_encoding_acn.c b/generated/asn1crt_encoding_acn.c
new file mode 100644
index 0000000..2e4c6dc
--- /dev/null
+++ b/generated/asn1crt_encoding_acn.c
@@ -0,0 +1,1454 @@
+#include <string.h>
+#include <assert.h>
+
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+namespace i3ds_asn1 {
+
+static byte masks[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
+
+static flag RequiresReverse(void)
+{
+	short int word = 0x0001;
+	char *b = (char *)&word;
+	return b[0] == 1;
+}
+
+
+
+void Acn_AlignToNextByte(BitStream* pBitStrm)
+{
+	if (pBitStrm->currentBit != 0)
+	{
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+
+		CHECK_BIT_STREAM(pBitStrm);
+	}
+}
+
+void Acn_AlignToNextWord(BitStream* pBitStrm)
+{
+	Acn_AlignToNextByte(pBitStrm);
+
+	pBitStrm->currentByte += pBitStrm->currentByte % 2;
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_AlignToNextDWord(BitStream* pBitStrm)
+{
+	Acn_AlignToNextByte(pBitStrm);
+
+	pBitStrm->currentByte += pBitStrm->currentByte % 4;
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+/*ACN Integer functions*/
+void Acn_Enc_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBits)
+{
+	int nBits = 0;
+	if (encodedSizeInBits == 0)
+		return;
+	/* Get number of bits*/
+	nBits = GetNumberOfBitsForNonNegativeInteger(intVal);
+	/* put required zeros*/
+	BitStream_AppendNBitZero(pBitStrm, encodedSizeInBits - nBits);
+	/*Encode number */
+	BitStream_EncodeNonNegativeInteger(pBitStrm, intVal);
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+void Acn_Enc_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	BitStream_AppendByte0(pBitStrm, (byte)intVal);
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+static void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(BitStream* pBitStrm,
+	asn1SccUint intVal,
+	int size)
+{
+	int i = 0;
+	asn1SccUint tmp = intVal;
+	asn1SccUint mask = 0xFF;
+	mask <<= (size - 1) * 8;
+
+	for (i = 0; i<size; i++) {
+		byte ByteToEncode = (byte)((tmp & mask) >> ((size - i - 1) * 8));
+		BitStream_AppendByte0(pBitStrm, ByteToEncode);
+		mask >>= 8;
+	}
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(pBitStrm, intVal, 2);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(pBitStrm, intVal, 4);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(pBitStrm, intVal, 8);
+}
+
+static void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(BitStream* pBitStrm,
+	asn1SccUint intVal,
+	int size)
+{
+	int i = 0;
+	asn1SccUint tmp = intVal;
+
+	for (i = 0; i<size; i++) {
+		byte ByteToEncode = (byte)tmp;
+		BitStream_AppendByte0(pBitStrm, ByteToEncode);
+		tmp >>= 8;
+	}
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, intVal, 2);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, intVal, 4);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, intVal, 8);
+}
+
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBits)
+{
+	asn1SccUint tmp = 0;
+	if (BitStream_DecodeNonNegativeInteger(pBitStrm, &tmp, encodedSizeInBits))
+	{
+		*pIntVal = tmp;
+		return TRUE;
+	}
+	return FALSE;
+
+}
+
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte v = 0;
+	if (!BitStream_ReadByte(pBitStrm, &v))
+		return FALSE;
+	*pIntVal = v;
+	return TRUE;
+}
+
+static flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(BitStream* pBitStrm,
+	asn1SccUint* pIntVal,
+	int SizeInBytes)
+{
+	int i;
+	asn1SccUint ret = 0;
+
+	*pIntVal = 0;
+
+	for (i = 0; i<SizeInBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		ret <<= 8;
+		ret |= b;
+	}
+	*pIntVal = ret;
+	return TRUE;
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(pBitStrm, pIntVal, 2);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(pBitStrm, pIntVal, 4);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(pBitStrm, pIntVal, 8);
+}
+
+static flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(BitStream* pBitStrm,
+	asn1SccUint* pIntVal,
+	int SizeInBytes)
+{
+	int i;
+	asn1SccUint ret = 0;
+	asn1SccUint tmp = 0;
+
+	*pIntVal = 0;
+
+	for (i = 0; i<SizeInBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		tmp = b;
+		tmp <<= i * 8;
+		ret |= tmp;
+	}
+	*pIntVal = ret;
+	return TRUE;
+
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, pIntVal, 2);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, pIntVal, 4);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, pIntVal, 8);
+}
+
+
+
+
+static void Encode_UnsignedInteger(BitStream* pBitStrm, asn1SccUint val, byte nBytes)
+{
+#if WORD_SIZE==8
+#define MAX_BYTE_MASK 0xFF00000000000000LL
+#else
+#define MAX_BYTE_MASK 0xFF000000
+#endif
+	int i = 0;
+	assert(nBytes <= 8);
+	val <<= (sizeof(asn1SccUint) * 8U - nBytes * 8U);
+	for (i = 0; i<nBytes; i++) {
+		byte ByteToEncode = (byte)((val & MAX_BYTE_MASK) >> ((sizeof(asn1SccUint) - 1) * 8));
+		BitStream_AppendByte0(pBitStrm, ByteToEncode);
+		val <<= 8;
+	}
+}
+
+
+int GetLengthInBytesOfUInt(asn1SccUint64 v);
+
+
+void Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	asn1SccUint val = intVal;
+	byte nBytes = (byte)GetLengthInBytesOfUInt(val);
+
+
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, nBytes);
+	/* Encode integer data*/
+	Encode_UnsignedInteger(pBitStrm, val, nBytes);
+
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+flag Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte nBytes;
+	int i;
+	asn1SccUint v = 0;
+	if (!BitStream_ReadByte(pBitStrm, &nBytes))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		v = (v << 8) | b;
+	}
+	*pIntVal = v;
+	return TRUE;
+}
+
+
+void Acn_Enc_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBits)
+{
+	if (intVal >= 0) {
+		BitStream_AppendNBitZero(pBitStrm, encodedSizeInBits - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)intVal));
+		BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)intVal);
+	}
+	else {
+		BitStream_AppendNBitOne(pBitStrm, encodedSizeInBits - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(-intVal - 1)));
+		BitStream_EncodeNonNegativeIntegerNeg(pBitStrm, (asn1SccUint)(-intVal - 1), 1);
+	}
+	CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+
+
+
+void Acn_Enc_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(pBitStrm, int2uint(intVal));
+}
+
+
+
+
+flag Acn_Dec_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBits)
+{
+	int i;
+	flag valIsNegative = FALSE;
+	int nBytes = encodedSizeInBits / 8;
+	int rstBits = encodedSizeInBits % 8;
+	byte b = 0;
+
+	*pIntVal = 0;
+
+
+	for (i = 0; i<nBytes; i++) {
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (i == 0) {
+			valIsNegative = b>0x7F;
+			if (valIsNegative)
+				*pIntVal = -1;
+		}
+		*pIntVal = (*pIntVal << 8) | b;
+	}
+
+	if (rstBits>0)
+	{
+		if (!BitStream_ReadPartialByte(pBitStrm, &b, (byte)rstBits))
+			return FALSE;
+		if (nBytes == 0)
+		{
+			valIsNegative = b & masks[8 - rstBits];
+			if (valIsNegative)
+				*pIntVal = -1;
+		}
+		*pIntVal = (*pIntVal << rstBits) | b;
+	}
+
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 1);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 2);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 4);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 8);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 2);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 4);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 8);
+	return TRUE;
+}
+
+
+
+
+static asn1SccUint To_UInt(asn1SccSint intVal) {
+	asn1SccUint ret = 0;
+	if (intVal <0) {
+		ret = (asn1SccUint)(-intVal - 1);
+		ret = ~ret;
+	}
+	else {
+		ret = (asn1SccUint)intVal;
+	}
+	return ret;
+}
+
+
+int GetLengthInBytesOfSInt(asn1SccSint v);
+
+
+void Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal)
+{
+
+	byte nBytes = (byte)GetLengthInBytesOfSInt(intVal);
+
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, nBytes);
+	/* Encode integer data*/
+	Encode_UnsignedInteger(pBitStrm, To_UInt(intVal), nBytes);
+
+
+	CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+
+flag Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+
+#if WORD_SIZE==8
+#define MAX_INT 0xFFFFFFFFFFFFFFFFULL
+#else
+#define MAX_INT 0xFFFFFFFF
+#endif
+
+	byte nBytes;
+	int i;
+	asn1SccUint v = 0;
+	flag isNegative = 0;
+	if (!BitStream_ReadByte(pBitStrm, &nBytes))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (i == 0 && (b & 0x80)>0) {
+			v = MAX_INT;
+			isNegative = 1;
+		}
+
+		v = (v << 8) | b;
+	}
+	if (isNegative) {
+		*pIntVal = -((asn1SccSint)(~v)) - 1;
+	}
+	else {
+		*pIntVal = (asn1SccSint)v;
+	}
+	return TRUE;
+
+}
+
+
+//return values is in nibbles
+static int Acn_Get_Int_Size_BCD(asn1SccUint intVal)
+{
+	int ret = 0;
+	while (intVal>0)
+	{
+		intVal /= 10;
+		ret++;
+	}
+	return ret;
+}
+
+
+
+
+void Acn_Enc_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInNibbles)
+{
+	int i = 0;
+	int totalNibbles = 0;
+	char tmp[100];
+
+	memset(tmp, 0x0, sizeof(tmp));
+
+	assert(100 >= encodedSizeInNibbles);
+
+	while (intVal>0) {
+		tmp[totalNibbles++] = (char)(intVal % 10);
+		intVal /= 10;
+	}
+	assert(encodedSizeInNibbles >= totalNibbles);
+
+	for (i = encodedSizeInNibbles - 1; i >= 0; i--) {
+		BitStream_AppendPartialByte(pBitStrm, (byte)tmp[i], 4, 0);
+	}
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+
+
+flag Acn_Dec_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInNibbles)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+
+
+	while (encodedSizeInNibbles>0)
+	{
+		if (!BitStream_ReadPartialByte(pBitStrm, &digit, 4))
+			return FALSE;
+
+		ret *= 10;
+		ret += digit;
+
+		encodedSizeInNibbles--;
+	}
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+
+void Acn_Enc_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	int nNibbles = Acn_Get_Int_Size_BCD(intVal);
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, (byte)nNibbles);
+
+
+	/* Encode Number */
+	Acn_Enc_Int_BCD_ConstSize(pBitStrm, intVal, nNibbles);
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+flag Acn_Dec_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte nNibbles = 0;
+	if (BitStream_ReadByte(pBitStrm, &nNibbles))
+		return Acn_Dec_Int_BCD_ConstSize(pBitStrm, pIntVal, nNibbles);
+
+	return FALSE;
+
+}
+
+
+
+//encoding puts an 'F' at the end
+void Acn_Enc_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal)
+{
+
+	int nNibbles = Acn_Get_Int_Size_BCD(intVal);
+
+	/* Encode Number */
+	Acn_Enc_Int_BCD_ConstSize(pBitStrm, intVal, nNibbles);
+
+	BitStream_AppendPartialByte(pBitStrm, 0xF, 4, 0);
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+flag Acn_Dec_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+
+	for (;;)
+	{
+		if (!BitStream_ReadPartialByte(pBitStrm, &digit, 4))
+			return FALSE;
+		if (digit>9)
+			break;
+
+		ret *= 10;
+		ret += digit;
+
+	}
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+
+void Acn_Enc_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBytes)
+{
+	int i = 0;
+	int totalNibbles = 0;
+	char tmp[100];
+
+	memset(tmp, 0x0, sizeof(tmp));
+
+	assert(100 >= encodedSizeInBytes);
+
+	while (intVal>0) {
+		tmp[totalNibbles++] = (char)(intVal % 10);
+		intVal /= 10;
+	}
+	assert(encodedSizeInBytes >= totalNibbles);
+
+	for (i = encodedSizeInBytes - 1; i >= 0; i--) {
+		BitStream_AppendByte0(pBitStrm, (byte)(tmp[i] + '0'));
+	}
+
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+
+void Acn_Enc_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBytes)
+{
+	asn1SccUint absIntVal = intVal >= 0 ? (asn1SccUint)intVal : (asn1SccUint)(-intVal);
+
+	/* encode sign */
+	BitStream_AppendByte0(pBitStrm, intVal >= 0 ? '+' : '-');
+	encodedSizeInBytes--;
+
+
+
+	Acn_Enc_UInt_ASCII_ConstSize(pBitStrm, absIntVal, encodedSizeInBytes);
+
+}
+
+flag Acn_Dec_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBytes)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+
+	while (encodedSizeInBytes>0)
+	{
+		if (!BitStream_ReadByte(pBitStrm, &digit))
+			return FALSE;
+		ASSERT_OR_RETURN_FALSE(digit >= '0' && digit <= '9');
+		digit = (byte)((int)digit - '0');
+
+		ret *= 10;
+		ret += digit;
+
+		encodedSizeInBytes--;
+	}
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+flag Acn_Dec_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBytes)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+	int sign = 1;
+
+	if (!BitStream_ReadByte(pBitStrm, &digit))
+		return FALSE;
+	if (digit == '+')
+		sign = 1;
+	else if (digit == '-')
+		sign = -1;
+	else {
+		ASSERT_OR_RETURN_FALSE(0);
+	}
+	encodedSizeInBytes--;
+
+
+	if (!Acn_Dec_UInt_ASCII_ConstSize(pBitStrm, &ret, encodedSizeInBytes)) {
+		return false;
+	}
+
+	*pIntVal = (asn1SccSint)ret;
+
+	*pIntVal = sign*(*pIntVal);
+	return TRUE;
+
+}
+
+
+
+void getIntegerDigits(asn1SccUint intVal, byte digitsArray100[], byte* totalDigits) {
+	int i = 0;
+	*totalDigits = 0;
+	byte reversedDigitsArray[100];
+	memset(reversedDigitsArray, 0x0, 100);
+	memset(digitsArray100, 0x0, 100);
+	if (intVal > 0) {
+		while (intVal > 0 && *totalDigits < 100) {
+			reversedDigitsArray[*totalDigits] = '0' + (byte)(intVal % 10);
+			(*totalDigits)++;
+			intVal /= 10;
+		}
+		for (i = *totalDigits - 1; i >= 0; i--) {
+			digitsArray100[(*totalDigits - 1) - i] = reversedDigitsArray[i];
+		}
+	}
+	else {
+		digitsArray100[0] = '0';
+		*totalDigits = 1;
+	}
+}
+
+
+void Acn_Enc_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	byte digitsArray100[100];
+	int i = 0;
+	byte nChars;
+	asn1SccUint absIntVal = intVal >= 0 ? (asn1SccUint)intVal : (asn1SccUint)(-intVal);
+	getIntegerDigits(absIntVal, digitsArray100, &nChars);
+
+	/* encode length, plus 1 for sign */
+	BitStream_AppendByte0(pBitStrm, nChars + 1);
+
+	/* encode sign */
+	BitStream_AppendByte0(pBitStrm, intVal >= 0 ? '+' : '-');
+
+	/* encode digits */
+	while (digitsArray100[i] != 0x0 && i<100) {
+		BitStream_AppendByte0(pBitStrm, digitsArray100[i]);
+		i++;
+	}
+
+	CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+void Acn_Enc_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	byte digitsArray100[100];
+	int i = 0;
+	byte nChars;
+	getIntegerDigits(intVal, digitsArray100, &nChars);
+
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, nChars);
+	/* encode digits */
+	while (digitsArray100[i] != 0x0 && i<100) {
+		BitStream_AppendByte0(pBitStrm, digitsArray100[i]);
+		i++;
+	}
+
+	CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+
+flag Acn_Dec_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte nChars = 0;
+	if (BitStream_ReadByte(pBitStrm, &nChars))
+		return Acn_Dec_UInt_ASCII_ConstSize(pBitStrm, pIntVal, nChars);
+
+	return FALSE;
+}
+
+flag Acn_Dec_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	byte nChars = 0;
+	if (BitStream_ReadByte(pBitStrm, &nChars))
+		return Acn_Dec_SInt_ASCII_ConstSize(pBitStrm, pIntVal, nChars);
+
+	return FALSE;
+}
+
+
+
+void Acn_Enc_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal, const byte null_characters[], size_t null_characters_size)
+{
+	byte digitsArray100[100];
+	byte nChars;
+	size_t i = 0;
+	getIntegerDigits(intVal, digitsArray100, &nChars);
+	while (digitsArray100[i] != 0x0 && i<100) {
+		BitStream_AppendByte0(pBitStrm, digitsArray100[i]);
+		i++;
+	}
+	for (i = 0; i<null_characters_size; i++)
+		BitStream_AppendByte0(pBitStrm, null_characters[i]);
+	CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_Enc_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint intVal, const byte null_characters[], size_t null_characters_size)
+{
+	asn1SccUint absValue = intVal >= 0 ? (asn1SccUint)intVal : (asn1SccUint)(-intVal);
+	BitStream_AppendByte0(pBitStrm, intVal >= 0 ? '+' : '-');
+
+	Acn_Enc_UInt_ASCII_VarSize_NullTerminated(pBitStrm, absValue, null_characters, null_characters_size);
+}
+
+/*
+flag Acn_Dec_String_Ascii_Null_Teminated_mult(BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size,   char* strVal)
+{
+byte tmp[10];
+size_t sz = null_character_size < 10 ? null_character_size : 10;
+memset(tmp, 0x0, 10);
+memset(strVal, 0x0, (size_t)max + 1);
+//read null_character_size characters into the tmp buffer
+for (int j = 0; j < (int)null_character_size; j++) {
+if (!BitStream_ReadByte(pBitStrm, &(tmp[j])))
+return FALSE;
+}
+
+asn1SccSint i = 0;
+while (i <= max && (memcmp(null_character, tmp, sz) != 0)) {
+strVal[i] = tmp[0];
+i++;
+for (int j = 0; j < (int)null_character_size - 1; j++)
+tmp[j] = tmp[j + 1];
+if (!BitStream_ReadByte(pBitStrm, &(tmp[null_character_size - 1])))
+return FALSE;
+}
+
+strVal[i] = 0x0;
+return memcmp(null_character, tmp, sz) == 0;
+
+}
+
+
+*/
+
+flag Acn_Dec_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal, const byte null_characters[], size_t null_characters_size)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+	byte tmp[10];
+	size_t sz = null_characters_size < 10 ? null_characters_size : 10;
+	memset(tmp, 0x0, 10);
+	asn1SccSint i = 0;
+
+	//read null_character_size characters into the tmp buffer
+	for (int j = 0; j < (int)null_characters_size; j++) {
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[j])))
+			return FALSE;
+	}
+
+	while (memcmp(null_characters, tmp, sz) != 0) {
+		digit = tmp[0];
+		i++;
+		for (int j = 0; j < (int)null_characters_size - 1; j++)
+			tmp[j] = tmp[j + 1];
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[null_characters_size - 1])))
+			return FALSE;
+
+		digit = (byte)((int)digit - '0');
+
+		ret *= 10;
+		ret += digit;
+	}
+
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+
+flag Acn_Dec_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint* pIntVal, const byte null_characters[], size_t null_characters_size)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+	flag isNegative = FALSE;
+
+	if (!BitStream_ReadByte(pBitStrm, &digit))
+		return FALSE;
+	ASSERT_OR_RETURN_FALSE(digit == '-' || digit == '+');
+	if (digit == '-')
+		isNegative = TRUE;
+
+	if (!Acn_Dec_UInt_ASCII_VarSize_NullTerminated(pBitStrm, &ret, null_characters, null_characters_size))
+		return false;
+
+	*pIntVal = (asn1SccSint)ret;
+	if (isNegative)
+		*pIntVal = -(*pIntVal);
+	return TRUE;
+}
+
+
+
+
+
+/* Boolean Decode */
+
+flag BitStream_ReadBitPattern(BitStream* pBitStrm, const byte* patternToRead, int nBitsToRead, flag* pBoolValue)
+{
+	int nBytesToRead = nBitsToRead / 8;
+	int nRemainingBitsToRead = nBitsToRead % 8;
+	byte curByte;
+	int i = 0;
+
+	*pBoolValue = TRUE;
+	for (i = 0; i<nBytesToRead; i++) {
+		if (!BitStream_ReadByte(pBitStrm, &curByte))
+			return FALSE;
+		if (curByte != patternToRead[i])
+			*pBoolValue = FALSE;
+	}
+
+	if (nRemainingBitsToRead > 0) {
+		if (!BitStream_ReadPartialByte(pBitStrm, &curByte, (byte)nRemainingBitsToRead))
+			return FALSE;
+		if (curByte != patternToRead[nBytesToRead] >> (8 - nRemainingBitsToRead))
+			*pBoolValue = FALSE;
+	}
+
+	return TRUE;
+}
+
+/*Real encoding functions*/
+typedef union _float_tag
+{
+	float f;
+	byte b[sizeof(float)];
+} _float;
+
+typedef union _double_tag
+{
+	double f;
+	byte b[sizeof(double)];
+} _double;
+
+
+#define Acn_enc_real_big_endian(type)       \
+    int i;                      \
+    _##type dat1;               \
+    dat1.f = (type)realValue;   \
+    if (!RequiresReverse()) {   \
+        for(i=0;i<(int)sizeof(dat1);i++)        \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    } else {    \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--)   \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    }   \
+
+
+#define Acn_dec_real_big_endian(type)   \
+    int i;                  \
+    _##type dat1;           \
+    dat1.f=0.0;             \
+    if (!RequiresReverse()) {       \
+        for(i=0;i<(int)sizeof(dat1);i++) {  \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))  \
+                return FALSE;       \
+        }                           \
+    } else {                        \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--) {         \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))      \
+                return FALSE;           \
+        }       \
+    }       \
+    *pRealValue = dat1.f;   \
+    return TRUE;            \
+
+
+void Acn_Enc_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_big_endian(float)
+}
+
+flag Acn_Dec_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_big_endian(float)
+}
+
+void Acn_Enc_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_big_endian(double)
+}
+
+flag Acn_Dec_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_big_endian(double)
+}
+
+
+
+
+#define Acn_enc_real_little_endian(type)        \
+    int i;                      \
+    _##type dat1;               \
+    dat1.f = (type)realValue;   \
+    if (RequiresReverse()) {    \
+        for(i=0;i<(int)sizeof(dat1);i++)        \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    } else {    \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--)   \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    }   \
+
+
+#define Acn_dec_real_little_endian(type)    \
+    int i;                  \
+    _##type dat1;           \
+    dat1.f=0.0;             \
+    if (RequiresReverse()) {        \
+        for(i=0;i<(int)sizeof(dat1);i++) {  \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))  \
+                return FALSE;       \
+        }                           \
+    } else {                        \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--) {         \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))      \
+                return FALSE;           \
+        }       \
+    }       \
+    *pRealValue = dat1.f;   \
+    return TRUE;            \
+
+
+void Acn_Enc_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_little_endian(float)
+}
+
+flag Acn_Dec_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_little_endian(float)
+}
+
+void Acn_Enc_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_little_endian(double)
+}
+
+flag Acn_Dec_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_little_endian(double)
+}
+
+
+
+
+/* String functions*/
+void Acn_Enc_String_Ascii_FixSize(BitStream* pBitStrm, asn1SccSint max, const char* strVal)
+{
+	asn1SccSint i = 0;
+	while (i<max) {
+		BitStream_AppendByte(pBitStrm, strVal[i], FALSE);
+		i++;
+	}
+}
+
+static asn1SccSint Acn_Enc_String_Ascii_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	const char* strVal)
+{
+	asn1SccSint i = 0;
+	while ((strVal[i] != '\0') && (i<max)) {
+		BitStream_AppendByte(pBitStrm, strVal[i], FALSE);
+		i++;
+	}
+	return i;
+}
+
+void Acn_Enc_String_Ascii_Null_Teminated(BitStream* pBitStrm, asn1SccSint max, char null_character, const char* strVal)
+{
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+	BitStream_AppendByte(pBitStrm, null_character, FALSE);
+}
+
+void Acn_Enc_String_Ascii_Null_Teminated_mult(BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, const char* strVal) {
+	size_t i = 0;
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+	for (i = 0; i<null_character_size; i++) {
+		BitStream_AppendByte(pBitStrm, null_character[i], FALSE);
+	}
+}
+
+
+void Acn_Enc_String_Ascii_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, const char* strVal)
+{
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+}
+
+void Acn_Enc_String_Ascii_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal)
+{
+	int strLen = strlen(strVal);
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, strLen <= max ? strLen : max, min, max);
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+}
+
+void Acn_Enc_String_CharIndex_FixSize(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal)
+{
+	asn1SccSint i = 0;
+	while (i<max) {
+		int charIndex = GetCharIndex(strVal[i], allowedCharSet, charSetSize);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, charSetSize - 1);
+		i++;
+	}
+}
+
+static asn1SccSint Acn_Enc_String_CharIndex_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	byte allowedCharSet[],
+	int charSetSize,
+	const char* strVal)
+{
+	asn1SccSint i = 0;
+	while ((strVal[i] != '\0') && (i<max)) {
+		int charIndex = GetCharIndex(strVal[i], allowedCharSet, charSetSize);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, charSetSize - 1);
+		i++;
+	}
+	return i;
+}
+
+
+void Acn_Enc_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal)
+{
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, charSetSize, strVal);
+}
+
+void Acn_Enc_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, const char* strVal)
+{
+	int strLen = strlen(strVal);
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, strLen <= max ? strLen : max, min, max);
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, charSetSize, strVal);
+}
+
+
+void Acn_Enc_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, const char* strVal)
+{
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, 128, strVal);
+}
+
+void Acn_Enc_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal)
+{
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+	int strLen = strlen(strVal);
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, strLen <= max ? strLen : max, min, max);
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, 128, strVal);
+}
+
+
+static flag Acn_Dec_String_Ascii_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	asn1SccSint charactersToDecode,
+	char* strVal)
+{
+	asn1SccSint i = 0;
+	byte decodedCharacter;
+	memset(strVal, 0x0, (size_t)max + 1);
+	while (i<charactersToDecode) {
+		if (!BitStream_ReadByte(pBitStrm, &decodedCharacter))
+			return FALSE;
+		strVal[i] = decodedCharacter;
+		i++;
+	}
+	return TRUE;
+}
+
+
+flag Acn_Dec_String_Ascii_FixSize(BitStream* pBitStrm, asn1SccSint max, char* strVal)
+{
+	return Acn_Dec_String_Ascii_private(pBitStrm, max, max, strVal);
+}
+
+/*
+int put_byte_in_last_dec_bytes(byte last_dec_bytes[], size_t* pCur_size, size_t null_characters_size, byte decodedCharacter, byte *pDiscardedCharacter) {
+int i;
+if (*pCur_size < null_characters_size) {
+last_dec_bytes[*pCur_size] = decodedCharacter;
+(*pCur_size)++;
+*pDiscardedCharacter = NULL;
+return 0;
+} else {
+*pDiscardedCharacter = last_dec_bytes[0];
+for (i = 1; i < null_characters_size; i++) {
+last_dec_bytes[i - 1] = last_dec_bytes[i];
+}
+last_dec_bytes[null_characters_size - 1] = decodedCharacter;
+return 1;
+}
+}
+
+flag Acn_Dec_String_Ascii_Null_Teminated(BitStream* pBitStrm, asn1SccSint max, const byte null_characters[], size_t null_characters_size, char* strVal)
+{
+asn1SccSint i = 0;
+byte decodedCharacter;
+byte characterToAppendInString;
+size_t cur_size_of_last_dec_bytes = 0;
+byte last_dec_bytes[128];
+int ret;
+
+assert(null_characters_size<128);
+memset(last_dec_bytes, 0x0, sizeof(last_dec_bytes));
+memset(strVal, 0x0, (size_t)max+1);
+while (i<=max) {
+if (!BitStream_ReadByte(pBitStrm, &decodedCharacter))
+return FALSE;
+ret = put_byte_in_last_dec_bytes(last_dec_bytes, &cur_size_of_last_dec_bytes, null_characters_size, decodedCharacter, &characterToAppendInString);
+
+
+//if (decodedCharacter == (byte)null_character) {
+if ((ret == 1) && (memcmp(last_dec_bytes,null_characters,null_characters_size) == 0)) {
+strVal[i] = 0x0;
+return TRUE;
+} else if (ret == 1) {
+strVal[i] = characterToAppendInString;
+i++;
+}
+}
+
+return FALSE;
+
+}
+
+*/
+
+
+flag Acn_Dec_String_Ascii_Null_Teminated(BitStream* pBitStrm, asn1SccSint max, char null_character, char* strVal)
+{
+	asn1SccSint i = 0;
+	byte decodedCharacter;
+	memset(strVal, 0x0, (size_t)max + 1);
+	while (i <= max) {
+		if (!BitStream_ReadByte(pBitStrm, &decodedCharacter))
+			return FALSE;
+		if (decodedCharacter != (byte)null_character) {
+			strVal[i] = decodedCharacter;
+			i++;
+		}
+		else {
+			strVal[i] = 0x0;
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+
+}
+
+flag Acn_Dec_String_Ascii_Null_Teminated_mult(BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, char* strVal)
+{
+	byte tmp[10];
+	size_t sz = null_character_size < 10 ? null_character_size : 10;
+	memset(tmp, 0x0, 10);
+	memset(strVal, 0x0, (size_t)max + 1);
+	//read null_character_size characters into the tmp buffer
+	for (int j = 0; j < (int)null_character_size; j++) {
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[j])))
+			return FALSE;
+	}
+
+	asn1SccSint i = 0;
+	while (i <= max && (memcmp(null_character, tmp, sz) != 0)) {
+		strVal[i] = tmp[0];
+		i++;
+		for (int j = 0; j < (int)null_character_size - 1; j++)
+			tmp[j] = tmp[j + 1];
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[null_character_size - 1])))
+			return FALSE;
+	}
+
+	strVal[i] = 0x0;
+	return memcmp(null_character, tmp, sz) == 0;
+
+}
+
+
+flag Acn_Dec_String_Ascii_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal)
+{
+	return Acn_Dec_String_Ascii_private(pBitStrm, max, extSizeDeterminatFld <= max ? extSizeDeterminatFld : max, strVal);
+}
+
+flag Acn_Dec_String_Ascii_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal)
+{
+	asn1SccSint nCount;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, min, max))
+		return FALSE;
+
+	return Acn_Dec_String_Ascii_private(pBitStrm, max, nCount <= max ? nCount : max, strVal);
+
+}
+
+static flag Acn_Dec_String_CharIndex_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	asn1SccSint charactersToDecode,
+	byte allowedCharSet[],
+	int charSetSize,
+	char* strVal)
+{
+	asn1SccSint i = 0;
+	memset(strVal, 0x0, (size_t)max + 1);
+	while (i<charactersToDecode) {
+		asn1SccSint charIndex = 0;
+		if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &charIndex, 0, charSetSize - 1))
+			return FALSE;
+		strVal[i] = allowedCharSet[charIndex];
+		i++;
+	}
+	return TRUE;
+}
+
+
+flag Acn_Dec_String_CharIndex_FixSize(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, char* strVal)
+{
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, max, allowedCharSet, charSetSize, strVal);
+}
+
+flag Acn_Dec_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint extSizeDeterminatFld, char* strVal)
+{
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, extSizeDeterminatFld <= max ? extSizeDeterminatFld : max, allowedCharSet, charSetSize, strVal);
+}
+
+flag Acn_Dec_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, char* strVal)
+{
+	asn1SccSint nCount;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, min, max))
+		return FALSE;
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, nCount <= max ? nCount : max, allowedCharSet, charSetSize, strVal);
+}
+
+
+
+
+flag Acn_Dec_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal)
+{
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, extSizeDeterminatFld <= max ? extSizeDeterminatFld : max, allowedCharSet, 128, strVal);
+}
+
+flag Acn_Dec_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal)
+{
+	asn1SccSint nCount;
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, min, max))
+		return FALSE;
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, nCount <= max ? nCount : max, allowedCharSet, 128, strVal);
+}
+
+
+
+
+
+
+/* Length Determinant functions*/
+void Acn_Enc_Length(BitStream* pBitStrm, asn1SccUint lengthValue, int lengthSizeInBits)
+{
+	/* encode length */
+	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, lengthValue, lengthSizeInBits);
+}
+
+flag Acn_Dec_Length(BitStream* pBitStrm, asn1SccUint* pLengthValue, int lengthSizeInBits)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pLengthValue, lengthSizeInBits);
+}
+
+asn1SccSint milbus_encode(asn1SccSint val)
+{
+	return val == 32 ? 0 : val;
+}
+
+asn1SccSint milbus_decode(asn1SccSint val)
+{
+	return val == 0 ? 32 : val;
+}
+
+} // namespace i3ds_asn1
+
diff --git a/generated/asn1crt_encoding_acn.h b/generated/asn1crt_encoding_acn.h
new file mode 100644
index 0000000..3b43d60
--- /dev/null
+++ b/generated/asn1crt_encoding_acn.h
@@ -0,0 +1,153 @@
+#ifndef ASN1SCC_ASN1CRT_ENCODING_ACN_H_
+#define ASN1SCC_ASN1CRT_ENCODING_ACN_H_
+
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*
+
+       db         ,ad8888ba,   888b      88           88888888888                                             88
+      d88b       d8"'    `"8b  8888b     88           88                                               ,d     ""
+     d8'`8b     d8'            88 `8b    88           88                                               88
+    d8'  `8b    88             88  `8b   88           88aaaaa  88       88  8b,dPPYba,    ,adPPYba,  MM88MMM  88   ,adPPYba,   8b,dPPYba,   ,adPPYba,
+   d8YaaaaY8b   88             88   `8b  88           88"""""  88       88  88P'   `"8a  a8"     ""    88     88  a8"     "8a  88P'   `"8a  I8[    ""
+  d8""""""""8b  Y8,            88    `8b 88           88       88       88  88       88  8b            88     88  8b       d8  88       88   `"Y8ba,
+ d8'        `8b  Y8a.    .a8P  88     `8888           88       "8a,   ,a88  88       88  "8a,   ,aa    88,    88  "8a,   ,a8"  88       88  aa    ]8I
+d8'          `8b  `"Y8888Y"'   88      `888           88        `"YbbdP'Y8  88       88   `"Ybbd8"'    "Y888  88   `"YbbdP"'   88       88  `"YbbdP"
+*/
+
+void Acn_AlignToNextByte(BitStream* pBitStrm);
+void Acn_AlignToNextWord(BitStream* pBitStrm);
+void Acn_AlignToNextDWord(BitStream* pBitStrm);
+
+/*ACN Integer functions*/
+void Acn_Enc_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBits);
+void Acn_Enc_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal);
+
+void Acn_Enc_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBits);
+void Acn_Enc_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal);
+
+void Acn_Enc_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInNibbles);
+void Acn_Enc_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal); /*encoding ends when 'F' is reached*/
+
+void Acn_Enc_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBytes);
+void Acn_Enc_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint intVal, const byte null_characters[], size_t null_characters_size); /*encoding ends when null_character is reached*/
+
+void Acn_Enc_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBytes);
+void Acn_Enc_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal, const byte null_characters[], size_t null_characters_size); /*encoding ends when null_character is reached*/
+
+
+/*ACN Decode Integer functions*/
+flag Acn_Dec_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBits);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal);
+
+flag Acn_Dec_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBits);
+flag Acn_Dec_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal);
+
+flag Acn_Dec_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInNibbles);
+flag Acn_Dec_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal);
+/*encoding ends when 'F' is reached*/
+flag Acn_Dec_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal);
+
+flag Acn_Dec_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBytes);
+flag Acn_Dec_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint* pIntVal, const byte null_characters[], size_t null_characters_size);
+
+flag Acn_Dec_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBytes);
+flag Acn_Dec_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal, const byte null_characters[], size_t null_characters_size);
+
+/*flag Acn_Dec_Int_ASCII_NullTerminated_FormattedInteger(BitStream* pBitStrm, const char* format, asn1SccSint* pIntVal);*/
+
+
+/* Boolean Decode */
+
+flag BitStream_ReadBitPattern(BitStream* pBitStrm, const byte* patternToRead, int nBitsToRead, flag* pBoolValue);
+
+/*Real encoding functions*/
+void Acn_Enc_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real realValue);
+void Acn_Enc_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real realValue);
+void Acn_Enc_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real realValue);
+void Acn_Enc_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real realValue);
+
+flag Acn_Dec_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+flag Acn_Dec_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+flag Acn_Dec_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+flag Acn_Dec_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+
+/*String functions*/
+void Acn_Enc_String_Ascii_FixSize                       (BitStream* pBitStrm, asn1SccSint max, const char* strVal);
+void Acn_Enc_String_Ascii_Null_Teminated                (BitStream* pBitStrm, asn1SccSint max, char null_character, const char* strVal);
+void Acn_Enc_String_Ascii_Null_Teminated_mult           (BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, const char* strVal);
+void Acn_Enc_String_Ascii_External_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, const char* strVal);
+void Acn_Enc_String_Ascii_Internal_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal);
+void Acn_Enc_String_CharIndex_FixSize                   (BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal);
+void Acn_Enc_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal);
+void Acn_Enc_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, const char* strVal);
+void Acn_Enc_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, const char* strVal);
+void Acn_Enc_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal);
+
+flag Acn_Dec_String_Ascii_FixSize                       (BitStream* pBitStrm, asn1SccSint max, char* strVal);
+flag Acn_Dec_String_Ascii_Null_Teminated                (BitStream* pBitStrm, asn1SccSint max, char null_character, char* strVal);
+flag Acn_Dec_String_Ascii_Null_Teminated_mult           (BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, char* strVal);
+flag Acn_Dec_String_Ascii_External_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal);
+flag Acn_Dec_String_Ascii_Internal_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal);
+flag Acn_Dec_String_CharIndex_FixSize                   (BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, char* strVal);
+flag Acn_Dec_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint extSizeDeterminatFld, char* strVal);
+flag Acn_Dec_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, char* strVal);
+flag Acn_Dec_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal);
+flag Acn_Dec_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal);
+
+
+/* Length Determinant functions*/
+void Acn_Enc_Length(BitStream* pBitStrm, asn1SccUint lengthValue, int lengthSizeInBits);
+flag Acn_Dec_Length(BitStream* pBitStrm, asn1SccUint* pLengthValue, int lengthSizeInBits);
+
+
+
+asn1SccSint milbus_encode(asn1SccSint val);
+asn1SccSint milbus_decode(asn1SccSint val);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+} // namespace i3ds_asn1
+#endif
\ No newline at end of file
diff --git a/generated/asn1crt_encoding_uper.c b/generated/asn1crt_encoding_uper.c
new file mode 100644
index 0000000..002b969
--- /dev/null
+++ b/generated/asn1crt_encoding_uper.c
@@ -0,0 +1,163 @@
+#include <string.h>
+#include <assert.h>
+#include <math.h>
+#include <float.h>
+
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+namespace i3ds_asn1 {
+
+
+
+void ObjectIdentifier_subidentifiers_uper_encode(byte* encodingBuf, int* pSize, asn1SccUint siValue) {
+	flag lastOctet = FALSE;
+	byte tmp[16];
+	int nSize = 0;
+	int i;
+	while (!lastOctet)
+	{
+		byte curByte = siValue % 128;
+		siValue = siValue / 128;
+		lastOctet = (siValue == 0);
+		tmp[nSize] = curByte;
+		nSize++;
+	}
+	for (i = 0; i < nSize; i++) {
+		byte curByte = (i == nSize - 1) ? tmp[nSize - i - 1] : tmp[nSize - i - 1] | 0x80;
+
+		encodingBuf[*pSize] = curByte;
+		(*pSize)++;
+	}
+}
+
+
+void ObjectIdentifier_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal) {
+	//a subifentifier (i.e. a component) should not take more than size(asn1SccUint) + 2 to be encoded
+	//(the above statement is true for 8 byte integers. If we ever user larger integer then it should be adjusted)
+	byte tmp[OBJECT_IDENTIFIER_MAX_LENGTH * (sizeof(asn1SccUint) + 2)];
+	int totalSize = 0;
+
+	int i = 0;
+	ObjectIdentifier_subidentifiers_uper_encode(tmp, &totalSize, pVal->values[0] * 40 + pVal->values[1]);
+	for (i = 2; i < pVal->nCount; i++) {
+		ObjectIdentifier_subidentifiers_uper_encode(tmp, &totalSize, pVal->values[i]);
+	}
+
+	if (totalSize <= 0x7F)
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0xFF);
+	else
+	{
+		BitStream_AppendBit(pBitStrm, 1);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0x7FFF);
+	}
+
+	for (i = 0; i < totalSize; i++) {
+		BitStream_AppendByte0(pBitStrm, tmp[i]);
+	}
+
+}
+
+void RelativeOID_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal) {
+	//a subifentifier (i.e. a component) should not take more than size(asn1SccUint) + 2 to be encoded
+	//(the above statement is true for 8 byte integers. If we ever user larger integer then it should be adjusted)
+	byte tmp[OBJECT_IDENTIFIER_MAX_LENGTH * (sizeof(asn1SccUint) + 2)];
+	int totalSize = 0;
+	int i = 0;
+
+	for (i = 0; i < pVal->nCount; i++) {
+		ObjectIdentifier_subidentifiers_uper_encode(tmp, &totalSize, pVal->values[i]);
+	}
+
+
+	if (totalSize <= 0x7F)
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0xFF);
+	else
+	{
+		BitStream_AppendBit(pBitStrm, 1);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0x7FFF);
+	}
+
+
+	for (i = 0; i < totalSize; i++) {
+		BitStream_AppendByte0(pBitStrm, tmp[i]);
+	}
+}
+
+flag ObjectIdentifier_subidentifiers_uper_decode(BitStream* pBitStrm, asn1SccSint* pRemainingOctets, asn1SccUint* siValue) {
+	byte curByte;
+	flag bLastOctet = FALSE;
+	asn1SccUint curOctetValue = 0;
+	*siValue = 0;
+	while (*pRemainingOctets > 0 && !bLastOctet)
+	{
+		curByte = 0;
+		if (!BitStream_ReadByte(pBitStrm, &curByte))
+			return FALSE;
+		(*pRemainingOctets)--;
+
+		bLastOctet = ((curByte & 0x80) == 0);
+		curOctetValue = curByte & 0x7F;
+		(*siValue) <<= 7;
+		(*siValue) |= curOctetValue;
+	}
+	return TRUE;
+}
+
+flag ObjectIdentifier_uper_decode_lentg(BitStream* pBitStrm, asn1SccSint* totalSize) {
+	asn1SccSint len2;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0xFF))
+		return FALSE;
+	if (*totalSize > 0x7F) {
+		if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF))
+			return false;
+		(*totalSize) <<= 8;
+		(*totalSize) |= len2;
+		(*totalSize) &= 0x7FFF;
+	}
+	return true;
+}
+flag ObjectIdentifier_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal) {
+	asn1SccUint si;
+	asn1SccSint totalSize;
+	ObjectIdentifier_Init(pVal);
+
+
+	if (!ObjectIdentifier_uper_decode_lentg(pBitStrm, &totalSize))
+		return FALSE;
+
+	if (!ObjectIdentifier_subidentifiers_uper_decode(pBitStrm, &totalSize, &si))
+		return FALSE;
+	pVal->nCount = 2;
+	pVal->values[0] = si / 40;
+	pVal->values[1] = si % 40;
+	while (totalSize > 0 && pVal->nCount < OBJECT_IDENTIFIER_MAX_LENGTH)
+	{
+		if (!ObjectIdentifier_subidentifiers_uper_decode(pBitStrm, &totalSize, &si))
+			return FALSE;
+
+		pVal->values[pVal->nCount] = si;
+		pVal->nCount++;
+	}
+	//return true, if totalSize reduced to zero. Otherwise we exit the loop because more components we present than OBJECT_IDENTIFIER_MAX_LENGTH
+	return totalSize == 0;
+}
+
+flag RelativeOID_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal) {
+	asn1SccUint si;
+	asn1SccSint totalSize;
+	ObjectIdentifier_Init(pVal);
+
+	if (!ObjectIdentifier_uper_decode_lentg(pBitStrm, &totalSize))
+		return FALSE;
+
+	while (totalSize > 0 && pVal->nCount < OBJECT_IDENTIFIER_MAX_LENGTH)
+	{
+		if (!ObjectIdentifier_subidentifiers_uper_decode(pBitStrm, &totalSize, &si))
+			return FALSE;
+		pVal->values[pVal->nCount] = si;
+		pVal->nCount++;
+	}
+	//return true, if totalSize is zero. Otherwise we exit the loop because more components were present than OBJECT_IDENTIFIER_MAX_LENGTH
+	return totalSize == 0;
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/asn1crt_encoding_uper.h b/generated/asn1crt_encoding_uper.h
new file mode 100644
index 0000000..b76af96
--- /dev/null
+++ b/generated/asn1crt_encoding_uper.h
@@ -0,0 +1,25 @@
+#ifndef ASN1SCC_ASN1CRT_ENCODING_UPER_H_
+#define ASN1SCC_ASN1CRT_ENCODING_UPER_H_
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+void ObjectIdentifier_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal);
+flag ObjectIdentifier_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal);
+void RelativeOID_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal);
+flag RelativeOID_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal);
+
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+
+} // namespace i3ds_asn1
+#endif
\ No newline at end of file
diff --git a/generated/base.c b/generated/base.c
new file mode 100644
index 0000000..e0b8a11
--- /dev/null
+++ b/generated/base.c
@@ -0,0 +1,11530 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/base.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Base_Angle_Initialize(Base_Angle* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set rad */
+	T_Double_Initialize((&(pVal->rad)));
+}
+
+flag Base_Angle_IsConstraintValid(const Base_Angle* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->rad) && (pVal->rad <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_ANGLE_RAD;
+
+	return ret;
+}
+
+flag Base_Angle_Encode(const Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Angle_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode rad */
+	    ret = T_Double_Encode((&(pVal->rad)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Angle_Decode(Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode rad */
+	ret = T_Double_Decode((&(pVal->rad)), pBitStrm, pErrCode);
+
+	return ret  && Base_Angle_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_Motion2D_Initialize(Base_commands_Motion2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	T_Double_Initialize((&(pVal->translation)));
+	/*set rotation */
+	T_Double_Initialize((&(pVal->rotation)));
+	/*set heading */
+	Base_Angle_Initialize((&(pVal->heading)));
+}
+
+flag Base_commands_Motion2D_IsConstraintValid(const Base_commands_Motion2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_TRANSLATION;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_ROTATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_HEADING_RAD;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_Motion2D_Encode(const Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rotation */
+	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heading */
+	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_Motion2D_Decode(Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rotation */
+	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heading */
+	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_PoseUpdateThreshold_Initialize(Base_PoseUpdateThreshold* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set distance */
+	T_Double_Initialize((&(pVal->distance)));
+	/*set angle */
+	T_Double_Initialize((&(pVal->angle)));
+}
+
+flag Base_PoseUpdateThreshold_IsConstraintValid(const Base_PoseUpdateThreshold* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->distance) && (pVal->distance <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_POSEUPDATETHRESHOLD_DISTANCE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_POSEUPDATETHRESHOLD_ANGLE;
+    }
+
+	return ret;
+}
+
+flag Base_PoseUpdateThreshold_Encode(const Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode distance */
+	    ret = T_Double_Encode((&(pVal->distance)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode angle */
+	        ret = T_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_PoseUpdateThreshold_Decode(Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode distance */
+	ret = T_Double_Decode((&(pVal->distance)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode angle */
+	    ret = T_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Temperature_Initialize(Base_Temperature* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set kelvin */
+	T_Double_Initialize((&(pVal->kelvin)));
+}
+
+flag Base_Temperature_IsConstraintValid(const Base_Temperature* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->kelvin) && (pVal->kelvin <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_TEMPERATURE_KELVIN;
+
+	return ret;
+}
+
+flag Base_Temperature_Encode(const Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Temperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode kelvin */
+	    ret = T_Double_Encode((&(pVal->kelvin)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Temperature_Decode(Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode kelvin */
+	ret = T_Double_Decode((&(pVal->kelvin)), pBitStrm, pErrCode);
+
+	return ret  && Base_Temperature_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_Speed6D_Initialize(Base_commands_Speed6D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set surge */
+	T_Double_Initialize((&(pVal->surge)));
+	/*set sway */
+	T_Double_Initialize((&(pVal->sway)));
+	/*set heave */
+	T_Double_Initialize((&(pVal->heave)));
+	/*set roll */
+	T_Double_Initialize((&(pVal->roll)));
+	/*set pitch */
+	T_Double_Initialize((&(pVal->pitch)));
+	/*set yaw */
+	T_Double_Initialize((&(pVal->yaw)));
+}
+
+flag Base_commands_Speed6D_IsConstraintValid(const Base_commands_Speed6D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->surge) && (pVal->surge <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_SURGE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->sway) && (pVal->sway <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_SWAY;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heave) && (pVal->heave <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_HEAVE;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->roll) && (pVal->roll <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_ROLL;
+                if (ret) {
+                    ret = ((-1.79769313486231570000E+308 <= pVal->pitch) && (pVal->pitch <= 1.79769313486231570000E+308));
+                    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_PITCH;
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->yaw) && (pVal->yaw <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_YAW;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_Speed6D_Encode(const Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_commands_Speed6D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode surge */
+	    ret = T_Double_Encode((&(pVal->surge)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode sway */
+	        ret = T_Double_Encode((&(pVal->sway)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heave */
+	            ret = T_Double_Encode((&(pVal->heave)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode roll */
+	                ret = T_Double_Encode((&(pVal->roll)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode pitch */
+	                    ret = T_Double_Encode((&(pVal->pitch)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode yaw */
+	                        ret = T_Double_Encode((&(pVal->yaw)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_Speed6D_Decode(Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode surge */
+	ret = T_Double_Decode((&(pVal->surge)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode sway */
+	    ret = T_Double_Decode((&(pVal->sway)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heave */
+	        ret = T_Double_Decode((&(pVal->heave)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode roll */
+	            ret = T_Double_Decode((&(pVal->roll)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode pitch */
+	                ret = T_Double_Decode((&(pVal->pitch)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode yaw */
+	                    ret = T_Double_Decode((&(pVal->yaw)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_commands_Speed6D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_AngleAxisd_axis_Initialize(Wrappers_AngleAxisd_axis* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 3) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_AngleAxisd_Initialize(Wrappers_AngleAxisd* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set angle */
+	T_Double_Initialize((&(pVal->angle)));
+	/*set axis */
+	Wrappers_AngleAxisd_axis_Initialize((&(pVal->axis)));
+}
+
+flag Wrappers_AngleAxisd_IsConstraintValid(const Wrappers_AngleAxisd* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_ANGLE;
+    if (ret) {
+        ret = ((1 <= pVal->axis.nCount) && (pVal->axis.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_AXIS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->axis.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->axis.arr[i1]) && (pVal->axis.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_AXIS_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_AngleAxisd_Encode(const Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode angle */
+	    ret = T_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode axis */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->axis.nCount, 1, 3);
+	        	
+	        for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++)
+	        {
+	        	ret = T_Double_Encode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_AngleAxisd_Decode(Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode angle */
+	ret = T_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode axis */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS;
+	    pVal->axis.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Decode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Wrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector2d_data_Initialize(Wrappers_Vector2d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 2) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector2d_Initialize(Wrappers_Vector2d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector2d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector2d_IsConstraintValid(const Wrappers_Vector2d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 2));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR2D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR2D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector2d_Encode(const Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 2);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector2d_Decode(Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector2d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose2D_Initialize(Base_Pose2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector2d_Initialize((&(pVal->position)));
+	/*set orientation */
+	T_Double_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose2D_IsConstraintValid(const Base_Pose2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
+    *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_POSE2D_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_ORIENTATION;
+    }
+
+	return ret;
+}
+
+flag Base_Pose2D_Encode(const Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = T_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose2D_Decode(Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = T_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose2D_m_Initialize(Base_Pose2D_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector2d_Initialize((&(pVal->position)));
+	/*set orientation */
+	T_Double_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose2D_m_IsConstraintValid(const Base_Pose2D_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
+    *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_ORIENTATION;
+    }
+
+	return ret;
+}
+
+flag Base_Pose2D_m_Encode(const Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose2D_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = T_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose2D_m_Decode(Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = T_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose2D_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix2d_data_Initialize(Wrappers_Matrix2d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 4) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix2d_Initialize(Wrappers_Matrix2d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix2d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix2d_IsConstraintValid(const Wrappers_Matrix2d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX2D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX2D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix2d_Encode(const Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix2d_Decode(Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix2d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector3d_data_Initialize(Wrappers_Vector3d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 3) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector3d_Initialize(Wrappers_Vector3d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector3d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector3d_IsConstraintValid(const Wrappers_Vector3d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR3D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR3D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector3d_Encode(const Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 3);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector3d_Decode(Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector3d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Wrench_Initialize(Base_Wrench* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+}
+
+flag Base_Wrench_IsConstraintValid(const Base_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Wrench_Encode(const Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Wrench_Decode(Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Waypoint_Initialize(Base_Waypoint* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set heading */
+	T_Double_Initialize((&(pVal->heading)));
+	/*set tol_position */
+	T_Double_Initialize((&(pVal->tol_position)));
+	/*set tol_heading */
+	T_Double_Initialize((&(pVal->tol_heading)));
+}
+
+flag Base_Waypoint_IsConstraintValid(const Base_Waypoint* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_HEADING;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_TOL_POSITION;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_TOL_HEADING;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Waypoint_Encode(const Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode heading */
+	        ret = T_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode tol_position */
+	            ret = T_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode tol_heading */
+	                ret = T_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Waypoint_Decode(Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode heading */
+	    ret = T_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode tol_position */
+	        ret = T_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode tol_heading */
+	            ret = T_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_Waypoint_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Waypoint_m_Initialize(Base_Waypoint_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set heading */
+	T_Double_Initialize((&(pVal->heading)));
+	/*set tol_position */
+	T_Double_Initialize((&(pVal->tol_position)));
+	/*set tol_heading */
+	T_Double_Initialize((&(pVal->tol_heading)));
+}
+
+flag Base_Waypoint_m_IsConstraintValid(const Base_Waypoint_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_HEADING;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_TOL_POSITION;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_TOL_HEADING;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Waypoint_m_Encode(const Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Waypoint_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode heading */
+	        ret = T_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode tol_position */
+	            ret = T_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode tol_heading */
+	                ret = T_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Waypoint_m_Decode(Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode heading */
+	    ret = T_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode tol_position */
+	        ret = T_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode tol_heading */
+	            ret = T_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_Waypoint_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Waypoint_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((1 <= pVal->arr[i1].position.data.nCount) && (pVal->arr[i1].position.data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->arr[i1].position.data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position.data.arr[i2]) && (pVal->arr[i1].position.data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA_ELM;
+        	    }
+        	}
+        	if (ret) {
+        	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].heading) && (pVal->arr[i1].heading <= 1.79769313486231570000E+308));
+        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_HEADING;
+        	    if (ret) {
+        	        ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_position) && (pVal->arr[i1].tol_position <= 1.79769313486231570000E+308));
+        	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_POSITION;
+        	        if (ret) {
+        	            ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_heading) && (pVal->arr[i1].tol_heading <= 1.79769313486231570000E+308));
+        	            *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_HEADING;
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Encode(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_Waypoint_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Decode(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_Waypoint_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Wrench_m_Initialize(Base_Wrench_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+}
+
+flag Base_Wrench_m_IsConstraintValid(const Base_Wrench_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Wrench_m_Encode(const Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Wrench_m_Decode(Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Wrench_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Wrench_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((1 <= pVal->arr[i1].force.data.nCount) && (pVal->arr[i1].force.data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->arr[i1].force.data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].force.data.arr[i2]) && (pVal->arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA_ELM;
+        	    }
+        	}
+        	if (ret) {
+        	    ret = ((1 <= pVal->arr[i1].torque.data.nCount) && (pVal->arr[i1].torque.data.nCount <= 3));
+        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA;
+        	    if (ret) {
+        	        for(i2 = 0; ret && i2 < pVal->arr[i1].torque.data.nCount; i2++)
+        	        {
+        	        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].torque.data.arr[i2]) && (pVal->arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+        	        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA_ELM;
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_Wrench_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_Wrench_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix3d_data_Initialize(Wrappers_Matrix3d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 9) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix3d_Initialize(Wrappers_Matrix3d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix3d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix3d_IsConstraintValid(const Wrappers_Matrix3d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 9));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX3D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX3D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix3d_Encode(const Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 9);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix3d_Decode(Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix3d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector4d_data_Initialize(Wrappers_Vector4d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 4) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector4d_Initialize(Wrappers_Vector4d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector4d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector4d_IsConstraintValid(const Wrappers_Vector4d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR4D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR4D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector4d_Encode(const Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector4d_Decode(Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_vector_Wrappers_Vector4d_Initialize(Std_vector_Wrappers_Vector4d* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_vector_Wrappers_Vector4d_IsConstraintValid(const Std_vector_Wrappers_Vector4d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((1 <= pVal->arr[i1].data.nCount) && (pVal->arr[i1].data.nCount <= 4));
+        	*pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->arr[i1].data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].data.arr[i2]) && (pVal->arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA_ELM;
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_vector_Wrappers_Vector4d_Encode(const Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Wrappers_Vector4d_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_vector_Wrappers_Vector4d_Decode(Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Wrappers_Vector4d_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix4d_data_Initialize(Wrappers_Matrix4d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 16) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix4d_Initialize(Wrappers_Matrix4d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix4d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix4d_IsConstraintValid(const Wrappers_Matrix4d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 16));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX4D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX4D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix4d_Encode(const Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 16);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix4d_Decode(Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix4d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector6d_data_Initialize(Wrappers_Vector6d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 6) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector6d_Initialize(Wrappers_Vector6d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector6d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector6d_IsConstraintValid(const Wrappers_Vector6d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 6));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR6D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR6D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector6d_Encode(const Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 6);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector6d_Decode(Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector6d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix6d_data_Initialize(Wrappers_Matrix6d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 36) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix6d_Initialize(Wrappers_Matrix6d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix6d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix6d_IsConstraintValid(const Wrappers_Matrix6d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 36));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX6D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX6D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix6d_Encode(const Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 36);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix6d_Decode(Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix6d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TwistWithCovariance_Initialize(Base_TwistWithCovariance* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set vel */
+	Wrappers_Vector3d_Initialize((&(pVal->vel)));
+	/*set rot */
+	Wrappers_Vector3d_Initialize((&(pVal->rot)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TwistWithCovariance_IsConstraintValid(const Base_TwistWithCovariance* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TwistWithCovariance_Encode(const Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TwistWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode vel */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rot */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TwistWithCovariance_Decode(Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode vel */
+	ret = Wrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rot */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TwistWithCovariance_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TwistWithCovariance_m_Initialize(Base_TwistWithCovariance_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set vel */
+	Wrappers_Vector3d_Initialize((&(pVal->vel)));
+	/*set rot */
+	Wrappers_Vector3d_Initialize((&(pVal->rot)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TwistWithCovariance_m_IsConstraintValid(const Base_TwistWithCovariance_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TwistWithCovariance_m_Encode(const Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode vel */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rot */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TwistWithCovariance_m_Decode(Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode vel */
+	ret = Wrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rot */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Quaterniond_im_Initialize(Wrappers_Quaterniond_im* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 3) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Quaterniond_Initialize(Wrappers_Quaterniond* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set im */
+	Wrappers_Quaterniond_im_Initialize((&(pVal->im)));
+	/*set re */
+	T_Double_Initialize((&(pVal->re)));
+}
+
+flag Wrappers_Quaterniond_IsConstraintValid(const Wrappers_Quaterniond* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->im.nCount) && (pVal->im.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_IM;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->im.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->im.arr[i1]) && (pVal->im.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_IM_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->re) && (pVal->re <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_RE;
+    }
+
+	return ret;
+}
+
+flag Wrappers_Quaterniond_Encode(const Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Quaterniond_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode im */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->im.nCount, 1, 3);
+	    	
+	    for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->im.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode re */
+	        ret = T_Double_Encode((&(pVal->re)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Quaterniond_Decode(Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode im */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM;
+	pVal->im.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->im.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode re */
+	    ret = T_Double_Decode((&(pVal->re)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Quaterniond_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose_Initialize(Base_Pose* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose_IsConstraintValid(const Base_Pose* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_POSE_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_POSE_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_RE;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Pose_Encode(const Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose_Decode(Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TransformWithCovariance_Initialize(Base_TransformWithCovariance* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	Wrappers_Vector3d_Initialize((&(pVal->translation)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TransformWithCovariance_IsConstraintValid(const Base_TransformWithCovariance* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TransformWithCovariance_Encode(const Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TransformWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TransformWithCovariance_Decode(Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = Wrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TransformWithCovariance_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose_m_Initialize(Base_Pose_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose_m_IsConstraintValid(const Base_Pose_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_POSE_M_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_RE;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Pose_m_Encode(const Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose_m_Decode(Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TransformWithCovariance_m_Initialize(Base_TransformWithCovariance_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	Wrappers_Vector3d_Initialize((&(pVal->translation)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TransformWithCovariance_m_IsConstraintValid(const Base_TransformWithCovariance_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TransformWithCovariance_m_Encode(const Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TransformWithCovariance_m_Decode(Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = Wrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_VectorXd_data_Initialize(Wrappers_VectorXd_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_VectorXd_Initialize(Wrappers_VectorXd* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_VectorXd_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_VectorXd_IsConstraintValid(const Wrappers_VectorXd* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTORXD_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTORXD_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_VectorXd_Encode(const Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_VectorXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_VectorXd_Decode(Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_VectorXd_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointState_Initialize(Base_JointState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	T_Double_Initialize((&(pVal->position)));
+	/*set speed */
+	T_Float_Initialize((&(pVal->speed)));
+	/*set effort */
+	T_Float_Initialize((&(pVal->effort)));
+	/*set raw */
+	T_Float_Initialize((&(pVal->raw)));
+	/*set acceleration */
+	T_Float_Initialize((&(pVal->acceleration)));
+}
+
+flag Base_JointState_IsConstraintValid(const Base_JointState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->position) && (pVal->position <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_POSITION;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->speed) && (pVal->speed <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_SPEED;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->effort) && (pVal->effort <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_EFFORT;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->raw) && (pVal->raw <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_RAW;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->acceleration) && (pVal->acceleration <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_ACCELERATION;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointState_Encode(const Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = T_Double_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode speed */
+	        ret = T_Float_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode effort */
+	            ret = T_Float_Encode((&(pVal->effort)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode raw */
+	                ret = T_Float_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode acceleration */
+	                    ret = T_Float_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointState_Decode(Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = T_Double_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode speed */
+	    ret = T_Float_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode effort */
+	        ret = T_Float_Decode((&(pVal->effort)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode raw */
+	            ret = T_Float_Decode((&(pVal->raw)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode acceleration */
+	                ret = T_Float_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_JointState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTrajectory_Initialize(Base_JointTrajectory* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointState_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Base_JointTrajectory_IsConstraintValid(const Base_JointTrajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position) && (pVal->arr[i1].position <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_POSITION;
+        	if (ret) {
+        	    ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 3.40282346600000020000E+038));
+        	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_SPEED;
+        	    if (ret) {
+        	        ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].effort) && (pVal->arr[i1].effort <= 3.40282346600000020000E+038));
+        	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_EFFORT;
+        	        if (ret) {
+        	            ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].raw) && (pVal->arr[i1].raw <= 3.40282346600000020000E+038));
+        	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_RAW;
+        	            if (ret) {
+        	                ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].acceleration) && (pVal->arr[i1].acceleration <= 3.40282346600000020000E+038));
+        	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_ACCELERATION;
+        	            }
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTrajectory_Encode(const Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointState_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTrajectory_Decode(Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRAJECTORY;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_JointState_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointLimitRange_Initialize(Base_JointLimitRange* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set min */
+	Base_JointState_Initialize((&(pVal->min)));
+	/*set max */
+	Base_JointState_Initialize((&(pVal->max)));
+}
+
+flag Base_JointLimitRange_IsConstraintValid(const Base_JointLimitRange* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->min.position) && (pVal->min.position <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_POSITION;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->min.speed) && (pVal->min.speed <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_SPEED;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->min.effort) && (pVal->min.effort <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_EFFORT;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->min.raw) && (pVal->min.raw <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_RAW;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->min.acceleration) && (pVal->min.acceleration <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_ACCELERATION;
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->max.position) && (pVal->max.position <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_POSITION;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->max.speed) && (pVal->max.speed <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_SPEED;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->max.effort) && (pVal->max.effort <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_EFFORT;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->max.raw) && (pVal->max.raw <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_RAW;
+                    if (ret) {
+                        ret = ((-3.40282346600000020000E+038 <= pVal->max.acceleration) && (pVal->max.acceleration <= 3.40282346600000020000E+038));
+                        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_ACCELERATION;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointLimitRange_Encode(const Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode min */
+	    ret = Base_JointState_Encode((&(pVal->min)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode max */
+	        ret = Base_JointState_Encode((&(pVal->max)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointLimitRange_Decode(Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode min */
+	ret = Base_JointState_Decode((&(pVal->min)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode max */
+	    ret = Base_JointState_Decode((&(pVal->max)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pressure_Initialize(Base_Pressure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set pascal */
+	T_Float_Initialize((&(pVal->pascal)));
+}
+
+flag Base_Pressure_IsConstraintValid(const Base_Pressure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_BASE_PRESSURE_PASCAL;
+
+	return ret;
+}
+
+flag Base_Pressure_Encode(const Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode pascal */
+	    ret = T_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pressure_Decode(Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode pascal */
+	ret = T_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);
+
+	return ret  && Base_Pressure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Time_Initialize(Base_Time* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set microseconds */
+	T_Int64_Initialize((&(pVal->microseconds)));
+}
+
+flag Base_Time_IsConstraintValid(const Base_Time* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag Base_Time_Encode(const Base_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode microseconds */
+	    ret = T_Int64_Encode((&(pVal->microseconds)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Time_Decode(Base_Time* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode microseconds */
+	ret = T_Int64_Decode((&(pVal->microseconds)), pBitStrm, pErrCode);
+
+	return ret  && Base_Time_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TimeStamped_Base_commands_Motion2D_Initialize(Base_TimeStamped_Base_commands_Motion2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	T_Double_Initialize((&(pVal->translation)));
+	/*set rotation */
+	T_Double_Initialize((&(pVal->rotation)));
+	/*set heading */
+	Base_Angle_Initialize((&(pVal->heading)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const Base_TimeStamped_Base_commands_Motion2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_RAD;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TimeStamped_Base_commands_Motion2D_Encode(const Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rotation */
+	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heading */
+	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode time */
+	                ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TimeStamped_Base_commands_Motion2D_Decode(Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rotation */
+	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heading */
+	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode time */
+	            ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_LinearAngular6DCommand_Initialize(Base_LinearAngular6DCommand* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set linear */
+	Wrappers_Vector3d_Initialize((&(pVal->linear)));
+	/*set angular */
+	Wrappers_Vector3d_Initialize((&(pVal->angular)));
+}
+
+flag Base_LinearAngular6DCommand_IsConstraintValid(const Base_LinearAngular6DCommand* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_LinearAngular6DCommand_Encode(const Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode linear */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode angular */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_LinearAngular6DCommand_Decode(Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode linear */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode angular */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_BodyState_Initialize(Base_samples_BodyState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set pose */
+	Base_TransformWithCovariance_Initialize((&(pVal->pose)));
+	/*set velocity */
+	Base_TwistWithCovariance_Initialize((&(pVal->velocity)));
+}
+
+flag Base_samples_BodyState_IsConstraintValid(const Base_samples_BodyState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_BodyState_Encode(const Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_BodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode pose */
+	        ret = Base_TransformWithCovariance_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode velocity */
+	            ret = Base_TwistWithCovariance_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_BodyState_Decode(Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode pose */
+	    ret = Base_TransformWithCovariance_Decode((&(pVal->pose)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode velocity */
+	        ret = Base_TwistWithCovariance_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_BodyState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_IMUSensors_Initialize(Base_samples_IMUSensors* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acc */
+	Wrappers_Vector3d_Initialize((&(pVal->acc)));
+	/*set gyro */
+	Wrappers_Vector3d_Initialize((&(pVal->gyro)));
+	/*set mag */
+	Wrappers_Vector3d_Initialize((&(pVal->mag)));
+}
+
+flag Base_samples_IMUSensors_IsConstraintValid(const Base_samples_IMUSensors* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_IMUSensors_Encode(const Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_IMUSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acc */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode gyro */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode mag */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_IMUSensors_Decode(Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acc */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode gyro */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode mag */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_IMUSensors_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Motion2D_Initialize(Base_samples_Motion2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	T_Double_Initialize((&(pVal->translation)));
+	/*set rotation */
+	T_Double_Initialize((&(pVal->rotation)));
+	/*set heading */
+	Base_Angle_Initialize((&(pVal->heading)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Motion2D_IsConstraintValid(const Base_samples_Motion2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_TRANSLATION;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_ROTATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_HEADING_RAD;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Motion2D_Encode(const Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rotation */
+	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heading */
+	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode time */
+	                ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Motion2D_Decode(Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rotation */
+	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heading */
+	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode time */
+	            ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Motion2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Pressure_Initialize(Base_samples_Pressure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set pascal */
+	T_Float_Initialize((&(pVal->pascal)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Pressure_IsConstraintValid(const Base_samples_Pressure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_PRESSURE_PASCAL;
+
+	return ret;
+}
+
+flag Base_samples_Pressure_Encode(const Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode pascal */
+	    ret = T_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode time */
+	        ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Pressure_Decode(Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode pascal */
+	ret = T_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode time */
+	    ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_samples_Pressure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyAcceleration_Initialize(Base_samples_RigidBodyAcceleration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->acceleration)));
+	/*set cov_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
+	/*set angular_acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
+	/*set cov_angular_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
+}
+
+flag Base_samples_RigidBodyAcceleration_IsConstraintValid(const Base_samples_RigidBodyAcceleration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_Encode(const Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acceleration */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov_acceleration */
+	            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode angular_acceleration */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_angular_acceleration */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_Decode(Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acceleration */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov_acceleration */
+	        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode angular_acceleration */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_angular_acceleration */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrench_Initialize(Base_samples_Wrench* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrench_IsConstraintValid(const Base_samples_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrench_Encode(const Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrench_Decode(Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Pointcloud_points_Initialize(Base_samples_Pointcloud_points* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector3d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_colors_Initialize(Base_samples_Pointcloud_colors* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_Initialize(Base_samples_Pointcloud* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set points */
+	Base_samples_Pointcloud_points_Initialize((&(pVal->points)));
+	/*set colors */
+	Base_samples_Pointcloud_colors_Initialize((&(pVal->colors)));
+}
+
+flag Base_samples_Pointcloud_IsConstraintValid(const Base_samples_Pointcloud* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++)
+        {
+        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA_ELM;
+        	    }
+        	}
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA_ELM;
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Pointcloud_Encode(const Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Pointcloud_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode points */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode colors */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	            {
+	            	ret = Wrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Pointcloud_Decode(Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode points */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS;
+	    pVal->points.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	    {
+	    	ret = Wrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode colors */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS;
+	        pVal->colors.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Pointcloud_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_SonarBeam_beam_Initialize(Base_samples_SonarBeam_beam* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 200);
+	pVal->nCount = 1;
+
+}
+void Base_samples_SonarBeam_Initialize(Base_samples_SonarBeam* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set bearing */
+	Base_Angle_Initialize((&(pVal->bearing)));
+	/*set sampling_interval */
+	T_Double_Initialize((&(pVal->sampling_interval)));
+	/*set speed_of_sound */
+	T_Float_Initialize((&(pVal->speed_of_sound)));
+	/*set beamwidth_horizontal */
+	T_Float_Initialize((&(pVal->beamwidth_horizontal)));
+	/*set beamwidth_vertical */
+	T_Float_Initialize((&(pVal->beamwidth_vertical)));
+	/*set beam */
+	Base_samples_SonarBeam_beam_Initialize((&(pVal->beam)));
+}
+
+flag Base_samples_SonarBeam_IsConstraintValid(const Base_samples_SonarBeam* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->bearing.rad) && (pVal->bearing.rad <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEARING_RAD;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_horizontal) && (pVal->beamwidth_horizontal <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_vertical) && (pVal->beamwidth_vertical <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL;
+                    if (ret) {
+                        ret = ((1 <= pVal->beam.nCount) && (pVal->beam.nCount <= 200));
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_SonarBeam_Encode(const Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_SonarBeam_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode bearing */
+	        ret = Base_Angle_Encode((&(pVal->bearing)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode sampling_interval */
+	            ret = T_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode speed_of_sound */
+	                ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode beamwidth_horizontal */
+	                    ret = T_Float_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode beamwidth_vertical */
+	                        ret = T_Float_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode beam */
+	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->beam.nCount, 1, 200);
+	                            	
+	                            for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++)
+	                            {
+	                            	BitStream_AppendByte0(pBitStrm, pVal->beam.arr[i1]);
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_SonarBeam_Decode(Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode bearing */
+	    ret = Base_Angle_Decode((&(pVal->bearing)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode sampling_interval */
+	        ret = T_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode speed_of_sound */
+	            ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode beamwidth_horizontal */
+	                ret = T_Float_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode beamwidth_vertical */
+	                    ret = T_Float_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode beam */
+	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
+	                        pVal->beam.nCount = (long)nCount;
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++)
+	                        {
+	                        	ret = BitStream_ReadByte(pBitStrm, &(pVal->beam.arr[i1]));
+	                        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_SonarBeam_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_LinearAngular6DCommand_m_Initialize(Base_commands_LinearAngular6DCommand_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set linear */
+	Wrappers_Vector3d_Initialize((&(pVal->linear)));
+	/*set angular */
+	Wrappers_Vector3d_Initialize((&(pVal->angular)));
+}
+
+flag Base_commands_LinearAngular6DCommand_m_IsConstraintValid(const Base_commands_LinearAngular6DCommand_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_LinearAngular6DCommand_m_Encode(const Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode linear */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode angular */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_LinearAngular6DCommand_m_Decode(Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode linear */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode angular */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_BodyState_m_Initialize(Base_samples_BodyState_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set pose */
+	Base_TransformWithCovariance_m_Initialize((&(pVal->pose)));
+	/*set velocity */
+	Base_TwistWithCovariance_m_Initialize((&(pVal->velocity)));
+}
+
+flag Base_samples_BodyState_m_IsConstraintValid(const Base_samples_BodyState_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_BodyState_m_Encode(const Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_BodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode pose */
+	        ret = Base_TransformWithCovariance_m_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode velocity */
+	            ret = Base_TwistWithCovariance_m_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_BodyState_m_Decode(Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode pose */
+	    ret = Base_TransformWithCovariance_m_Decode((&(pVal->pose)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode velocity */
+	        ret = Base_TwistWithCovariance_m_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_BodyState_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_IMUSensors_m_Initialize(Base_samples_IMUSensors_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acc */
+	Wrappers_Vector3d_Initialize((&(pVal->acc)));
+	/*set gyro */
+	Wrappers_Vector3d_Initialize((&(pVal->gyro)));
+	/*set mag */
+	Wrappers_Vector3d_Initialize((&(pVal->mag)));
+}
+
+flag Base_samples_IMUSensors_m_IsConstraintValid(const Base_samples_IMUSensors_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_IMUSensors_m_Encode(const Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acc */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode gyro */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode mag */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_IMUSensors_m_Decode(Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acc */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode gyro */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode mag */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyAcceleration_m_Initialize(Base_samples_RigidBodyAcceleration_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->acceleration)));
+	/*set cov_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
+	/*set angular_acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
+	/*set cov_angular_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
+}
+
+flag Base_samples_RigidBodyAcceleration_m_IsConstraintValid(const Base_samples_RigidBodyAcceleration_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_m_Encode(const Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acceleration */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov_acceleration */
+	            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode angular_acceleration */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_angular_acceleration */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_m_Decode(Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acceleration */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov_acceleration */
+	        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode angular_acceleration */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_angular_acceleration */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrench_m_Initialize(Base_samples_Wrench_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrench_m_IsConstraintValid(const Base_samples_Wrench_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrench_m_Encode(const Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrench_m_Decode(Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrench_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Pointcloud_m_points_Initialize(Base_samples_Pointcloud_m_points* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector3d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_m_colors_Initialize(Base_samples_Pointcloud_m_colors* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_m_Initialize(Base_samples_Pointcloud_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set points */
+	Base_samples_Pointcloud_m_points_Initialize((&(pVal->points)));
+	/*set colors */
+	Base_samples_Pointcloud_m_colors_Initialize((&(pVal->colors)));
+}
+
+flag Base_samples_Pointcloud_m_IsConstraintValid(const Base_samples_Pointcloud_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++)
+        {
+        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA_ELM;
+        	    }
+        	}
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA_ELM;
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Pointcloud_m_Encode(const Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode points */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode colors */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	            {
+	            	ret = Wrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Pointcloud_m_Decode(Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode points */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS;
+	    pVal->points.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	    {
+	    	ret = Wrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode colors */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS;
+	        pVal->colors.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_size_t_Initialize(Base_samples_frame_frame_size_t* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set width */
+	T_UInt16_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt16_Initialize((&(pVal->height)));
+}
+
+flag Base_samples_frame_frame_size_t_IsConstraintValid(const Base_samples_frame_frame_size_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->width <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH;
+    if (ret) {
+        ret = (pVal->height <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT;
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_size_t_Encode(const Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode width */
+	    ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode height */
+	        ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_size_t_Decode(Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode width */
+	ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode height */
+	    ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DistanceImage_data_Initialize(Base_samples_DistanceImage_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DistanceImage_Initialize(Base_samples_DistanceImage* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set width */
+	T_UInt16_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt16_Initialize((&(pVal->height)));
+	/*set scale_x */
+	T_Float_Initialize((&(pVal->scale_x)));
+	/*set scale_y */
+	T_Float_Initialize((&(pVal->scale_y)));
+	/*set center_x */
+	T_Float_Initialize((&(pVal->center_x)));
+	/*set center_y */
+	T_Float_Initialize((&(pVal->center_y)));
+	/*set data */
+	Base_samples_DistanceImage_data_Initialize((&(pVal->data)));
+}
+
+flag Base_samples_DistanceImage_IsConstraintValid(const Base_samples_DistanceImage* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->width <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_WIDTH;
+    if (ret) {
+        ret = (pVal->height <= 65535UL);
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->scale_x) && (pVal->scale_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->scale_y) && (pVal->scale_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->center_x) && (pVal->center_x <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X;
+                    if (ret) {
+                        ret = ((-3.40282346600000020000E+038 <= pVal->center_y) && (pVal->center_y <= 3.40282346600000020000E+038));
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y;
+                        if (ret) {
+                            ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+                                {
+                                	ret = ((-3.40282346600000020000E+038 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 3.40282346600000020000E+038));
+                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_DistanceImage_Encode(const Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_DistanceImage_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode width */
+	        ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode height */
+	            ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode scale_x */
+	                ret = T_Float_Encode((&(pVal->scale_x)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode scale_y */
+	                    ret = T_Float_Encode((&(pVal->scale_y)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode center_x */
+	                        ret = T_Float_Encode((&(pVal->center_x)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode center_y */
+	                            ret = T_Float_Encode((&(pVal->center_y)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode data */
+	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	                                	
+	                                for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	                                {
+	                                	ret = T_Float_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DistanceImage_Decode(Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode width */
+	    ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode height */
+	        ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode scale_x */
+	            ret = T_Float_Decode((&(pVal->scale_x)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode scale_y */
+	                ret = T_Float_Decode((&(pVal->scale_y)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode center_x */
+	                    ret = T_Float_Decode((&(pVal->center_x)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode center_y */
+	                        ret = T_Float_Decode((&(pVal->center_y)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode data */
+	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA;
+	                            pVal->data.nCount = (long)nCount;
+	                            	
+	                            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	                            {
+	                            	ret = T_Float_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_DistanceImage_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointLimits_names_Initialize(Base_JointLimits_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointLimits_elements_Initialize(Base_JointLimits_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointLimitRange_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointLimits_Initialize(Base_JointLimits* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointLimits_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointLimits_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_JointLimits_IsConstraintValid(const Base_JointLimits* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_POSITION;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_SPEED;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_EFFORT;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_RAW;
+            	                if (ret) {
+            	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
+            	                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_ACCELERATION;
+            	                }
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointLimits_Encode(const Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointLimits_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointLimits_Decode(Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointLimits_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransform_Initialize(Base_JointTransform* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set rotationaxis */
+	Wrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
+}
+
+flag Base_JointTransform_IsConstraintValid(const Base_JointTransform* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransform_Encode(const Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode sourceframe */
+	    ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode targetframe */
+	        ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode rotationaxis */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransform_Decode(Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode sourceframe */
+	ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode targetframe */
+	    ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode rotationaxis */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointTransform_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransformVector_names_Initialize(Base_JointTransformVector_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointTransformVector_elements_Initialize(Base_JointTransformVector_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTransform_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointTransformVector_Initialize(Base_JointTransformVector* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointTransformVector_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointTransformVector_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_JointTransformVector_IsConstraintValid(const Base_JointTransformVector* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransformVector_Encode(const Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointTransformVector_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransformVector_Decode(Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointTransformVector_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointTransform_names_Initialize(Base_NamedVector_Base_JointTransform_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTransform_elements_Initialize(Base_NamedVector_Base_JointTransform_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTransform_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTransform_Initialize(Base_NamedVector_Base_JointTransform* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointTransform_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_JointTransform_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointTransform_IsConstraintValid(const Base_NamedVector_Base_JointTransform* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointTransform_Encode(const Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointTransform_Decode(Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointsTrajectory_names_Initialize(Base_JointsTrajectory_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointsTrajectory_elements_Initialize(Base_JointsTrajectory_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTrajectory_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointsTrajectory_times_val_Initialize(Base_JointsTrajectory_times_val* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointsTrajectory_Initialize(Base_JointsTrajectory* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointsTrajectory_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointsTrajectory_elements_Initialize((&(pVal->elements)));
+	/*set times_val */
+	Base_JointsTrajectory_times_val_Initialize((&(pVal->times_val)));
+}
+
+flag Base_JointsTrajectory_IsConstraintValid(const Base_JointsTrajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
+            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
+            	    	if (ret) {
+            	    	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
+            	    	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
+            	    	    if (ret) {
+            	    	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
+            	    	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
+            	    	        if (ret) {
+            	    	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
+            	    	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
+            	    	            if (ret) {
+            	    	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
+            	    	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
+            	    	            }
+            	    	        }
+            	    	    }
+            	    	}
+            	    }
+            	}
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->times_val.nCount) && (pVal->times_val.nCount <= 200));
+            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointsTrajectory_Encode(const Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointsTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode times_val */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->times_val.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++)
+	            {
+	            	ret = Base_Time_Encode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointsTrajectory_Decode(Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode times_val */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL;
+	        pVal->times_val.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Decode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_JointsTrajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointLimitRange_names_Initialize(Base_NamedVector_Base_JointLimitRange_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointLimitRange_elements_Initialize(Base_NamedVector_Base_JointLimitRange_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointLimitRange_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointLimitRange_Initialize(Base_NamedVector_Base_JointLimitRange* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointLimitRange_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_JointLimitRange_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointLimitRange_IsConstraintValid(const Base_NamedVector_Base_JointLimitRange* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_POSITION;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_SPEED;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_EFFORT;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_RAW;
+            	                if (ret) {
+            	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
+            	                    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_ACCELERATION;
+            	                }
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointLimitRange_Encode(const Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointLimitRange_Decode(Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointState_names_Initialize(Base_NamedVector_Base_JointState_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointState_Initialize(Base_NamedVector_Base_JointState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointState_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointTrajectory_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointState_IsConstraintValid(const Base_NamedVector_Base_JointState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointState_Encode(const Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Base_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointState_Decode(Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Base_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_Wrench_names_Initialize(Base_NamedVector_Base_Wrench_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_Wrench_elements_Initialize(Base_NamedVector_Base_Wrench_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Wrench_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_Wrench_Initialize(Base_NamedVector_Base_Wrench* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_Wrench_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_Wrench_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_Wrench_IsConstraintValid(const Base_NamedVector_Base_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_Wrench_Encode(const Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_Wrench_Decode(Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointTrajectory_names_Initialize(Base_NamedVector_Base_JointTrajectory_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTrajectory_elements_Initialize(Base_NamedVector_Base_JointTrajectory_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTrajectory_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTrajectory_Initialize(Base_NamedVector_Base_JointTrajectory* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointTrajectory_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_JointTrajectory_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointTrajectory_IsConstraintValid(const Base_NamedVector_Base_JointTrajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
+            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
+            	    	if (ret) {
+            	    	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
+            	    	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
+            	    	    if (ret) {
+            	    	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
+            	    	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
+            	    	        if (ret) {
+            	    	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
+            	    	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
+            	    	            if (ret) {
+            	    	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
+            	    	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
+            	    	            }
+            	    	        }
+            	    	    }
+            	    	}
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointTrajectory_Encode(const Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointTrajectory_Decode(Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_Joints_names_Initialize(Base_commands_Joints_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_commands_Joints_Initialize(Base_commands_Joints* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_commands_Joints_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointTrajectory_Initialize((&(pVal->elements)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_commands_Joints_IsConstraintValid(const Base_commands_Joints* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_Joints_Encode(const Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_commands_Joints_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Base_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_Joints_Decode(Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Base_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_commands_Joints_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyState_Initialize(Base_samples_RigidBodyState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set cov_position */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov_orientation */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
+	/*set velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->velocity)));
+	/*set cov_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
+	/*set angular_velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
+	/*set cov_angular_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
+}
+
+flag Base_samples_RigidBodyState_IsConstraintValid(const Base_samples_RigidBodyState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_RE;
+                    }
+                    if (ret) {
+                        ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA_ELM;
+                                }
+                            }
+                            if (ret) {
+                                ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++)
+                                    {
+                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA_ELM;
+                                    }
+                                }
+                                if (ret) {
+                                    ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
+                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA;
+                                    if (ret) {
+                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++)
+                                        {
+                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA_ELM;
+                                        }
+                                    }
+                                    if (ret) {
+                                        ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
+                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA;
+                                        if (ret) {
+                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++)
+                                            {
+                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA_ELM;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyState_Encode(const Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode sourceframe */
+	        ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode targetframe */
+	            ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode position */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_position */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode orientation */
+	                        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode cov_orientation */
+	                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode velocity */
+	                                ret = Wrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode cov_velocity */
+	                                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode angular_velocity */
+	                                        ret = Wrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode cov_angular_velocity */
+	                                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyState_Decode(Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode sourceframe */
+	    ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode targetframe */
+	        ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode position */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_position */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode orientation */
+	                    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode cov_orientation */
+	                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode velocity */
+	                            ret = Wrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode cov_velocity */
+	                                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode angular_velocity */
+	                                    ret = Wrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode cov_angular_velocity */
+	                                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrenches_names_Initialize(Base_samples_Wrenches_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Wrenches_elements_Initialize(Base_samples_Wrenches_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Wrench_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Wrenches_Initialize(Base_samples_Wrenches* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_samples_Wrenches_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_samples_Wrenches_elements_Initialize((&(pVal->elements)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrenches_IsConstraintValid(const Base_samples_Wrenches* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrenches_Encode(const Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Wrenches_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrenches_Decode(Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrenches_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_attrib_t_Initialize(Base_samples_frame_frame_attrib_t* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	T_String_Initialize((&(pVal->data)));
+	/*set name_val */
+	T_String_Initialize((&(pVal->name_val)));
+}
+
+flag Base_samples_frame_frame_attrib_t_IsConstraintValid(const Base_samples_frame_frame_attrib_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->data.nCount <= 40);
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA;
+    if (ret) {
+        ret = (pVal->name_val.nCount <= 40);
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL;
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_attrib_t_Encode(const Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    ret = T_String_Encode((&(pVal->data)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode name_val */
+	        ret = T_String_Encode((&(pVal->name_val)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_attrib_t_Decode(Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode data */
+	ret = T_String_Decode((&(pVal->data)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode name_val */
+	    ret = T_String_Decode((&(pVal->name_val)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransform_m_Initialize(Base_JointTransform_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set rotationaxis */
+	Wrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
+}
+
+flag Base_JointTransform_m_IsConstraintValid(const Base_JointTransform_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransform_m_Encode(const Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode sourceframe */
+	    ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode targetframe */
+	        ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode rotationaxis */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransform_m_Decode(Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode sourceframe */
+	ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode targetframe */
+	    ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode rotationaxis */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTransform_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = (pVal->arr[i1].sourceframe.nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME;
+        	if (ret) {
+        	    ret = (pVal->arr[i1].targetframe.nCount <= 40);
+        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME;
+        	    if (ret) {
+        	        ret = ((1 <= pVal->arr[i1].rotationaxis.data.nCount) && (pVal->arr[i1].rotationaxis.data.nCount <= 3));
+        	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA;
+        	        if (ret) {
+        	            for(i2 = 0; ret && i2 < pVal->arr[i1].rotationaxis.data.nCount; i2++)
+        	            {
+        	            	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].rotationaxis.data.arr[i2]) && (pVal->arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+        	            	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA_ELM;
+        	            }
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTransform_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_JointTransform_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransformVector_m_names_Initialize(Base_JointTransformVector_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointTransformVector_m_Initialize(Base_JointTransformVector_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointTransformVector_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
+}
+
+flag Base_JointTransformVector_m_IsConstraintValid(const Base_JointTransformVector_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransformVector_m_Encode(const Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointTransformVector_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransformVector_m_Decode(Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_JointTransformVector_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_base_JointTransform_m_names_Initialize(Base_NamedVector_base_JointTransform_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_base_JointTransform_m_Initialize(Base_NamedVector_base_JointTransform_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_base_JointTransform_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_base_JointTransform_m_IsConstraintValid(const Base_NamedVector_base_JointTransform_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_base_JointTransform_m_Encode(const Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_base_JointTransform_m_Decode(Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyState_m_Initialize(Base_samples_RigidBodyState_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set cov_position */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov_orientation */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
+	/*set velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->velocity)));
+	/*set cov_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
+	/*set angular_velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
+	/*set cov_angular_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
+}
+
+flag Base_samples_RigidBodyState_m_IsConstraintValid(const Base_samples_RigidBodyState_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_RE;
+                    }
+                    if (ret) {
+                        ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA_ELM;
+                                }
+                            }
+                            if (ret) {
+                                ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++)
+                                    {
+                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA_ELM;
+                                    }
+                                }
+                                if (ret) {
+                                    ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
+                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA;
+                                    if (ret) {
+                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++)
+                                        {
+                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA_ELM;
+                                        }
+                                    }
+                                    if (ret) {
+                                        ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
+                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA;
+                                        if (ret) {
+                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++)
+                                            {
+                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA_ELM;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyState_m_Encode(const Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode sourceframe */
+	        ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode targetframe */
+	            ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode position */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_position */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode orientation */
+	                        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode cov_orientation */
+	                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode velocity */
+	                                ret = Wrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode cov_velocity */
+	                                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode angular_velocity */
+	                                        ret = Wrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode cov_angular_velocity */
+	                                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyState_m_Decode(Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode sourceframe */
+	    ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode targetframe */
+	        ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode position */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_position */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode orientation */
+	                    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode cov_orientation */
+	                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode velocity */
+	                            ret = Wrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode cov_velocity */
+	                                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode angular_velocity */
+	                                    ret = Wrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode cov_angular_velocity */
+	                                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_base_Wrench_m_names_Initialize(Base_NamedVector_base_Wrench_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_base_Wrench_m_Initialize(Base_NamedVector_base_Wrench_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_base_Wrench_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_base_Wrench_m_IsConstraintValid(const Base_NamedVector_base_Wrench_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_base_Wrench_m_Encode(const Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_base_Wrench_m_Decode(Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrenches_m_names_Initialize(Base_samples_Wrenches_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Wrenches_m_Initialize(Base_samples_Wrenches_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_samples_Wrenches_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrenches_m_IsConstraintValid(const Base_samples_Wrenches_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrenches_m_Encode(const Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrenches_m_Decode(Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_LaserScan_ranges_Initialize(Base_samples_LaserScan_ranges* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_UInt32_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_LaserScan_remission_Initialize(Base_samples_LaserScan_remission* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_LaserScan_Initialize(Base_samples_LaserScan* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set start_angle */
+	T_Double_Initialize((&(pVal->start_angle)));
+	/*set angular_resolution */
+	T_Double_Initialize((&(pVal->angular_resolution)));
+	/*set speed */
+	T_Double_Initialize((&(pVal->speed)));
+	/*set ranges */
+	Base_samples_LaserScan_ranges_Initialize((&(pVal->ranges)));
+	/*set minrange */
+	T_UInt32_Initialize((&(pVal->minrange)));
+	/*set maxrange */
+	T_UInt32_Initialize((&(pVal->maxrange)));
+	/*set remission */
+	Base_samples_LaserScan_remission_Initialize((&(pVal->remission)));
+}
+
+flag Base_samples_LaserScan_IsConstraintValid(const Base_samples_LaserScan* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->start_angle) && (pVal->start_angle <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_START_ANGLE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution) && (pVal->angular_resolution <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_SPEED;
+            if (ret) {
+                ret = ((1 <= pVal->ranges.nCount) && (pVal->ranges.nCount <= 200));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_RANGES;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->ranges.nCount; i1++)
+                    {
+                    	ret = (pVal->ranges.arr[i1] <= 4294967295UL);
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_RANGES_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = (pVal->minrange <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_MINRANGE;
+                    if (ret) {
+                        ret = (pVal->maxrange <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_MAXRANGE;
+                        if (ret) {
+                            ret = ((1 <= pVal->remission.nCount) && (pVal->remission.nCount <= 200));
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_REMISSION;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->remission.nCount; i1++)
+                                {
+                                	ret = ((-3.40282346600000020000E+038 <= pVal->remission.arr[i1]) && (pVal->remission.arr[i1] <= 3.40282346600000020000E+038));
+                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_REMISSION_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_LaserScan_Encode(const Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_LaserScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode start_angle */
+	        ret = T_Double_Encode((&(pVal->start_angle)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode angular_resolution */
+	            ret = T_Double_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode speed */
+	                ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode ranges */
+	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->ranges.nCount, 1, 200);
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_UInt32_Encode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                    }
+	                    if (ret) {
+	                        /*Encode minrange */
+	                        ret = T_UInt32_Encode((&(pVal->minrange)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode maxrange */
+	                            ret = T_UInt32_Encode((&(pVal->maxrange)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode remission */
+	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remission.nCount, 1, 200);
+	                                	
+	                                for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++)
+	                                {
+	                                	ret = T_Float_Encode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_LaserScan_Decode(Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode start_angle */
+	    ret = T_Double_Decode((&(pVal->start_angle)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode angular_resolution */
+	        ret = T_Double_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode speed */
+	            ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode ranges */
+	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES;
+	                pVal->ranges.nCount = (long)nCount;
+	                	
+	                for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++)
+	                {
+	                	ret = T_UInt32_Decode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode);
+	                }
+	                if (ret) {
+	                    /*Decode minrange */
+	                    ret = T_UInt32_Decode((&(pVal->minrange)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode maxrange */
+	                        ret = T_UInt32_Decode((&(pVal->maxrange)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode remission */
+	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION;
+	                            pVal->remission.nCount = (long)nCount;
+	                            	
+	                            for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++)
+	                            {
+	                            	ret = T_Float_Decode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode);
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_LaserScan_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Sonar_timestamps_Initialize(Base_samples_Sonar_timestamps* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Sonar_bearings_Initialize(Base_samples_Sonar_bearings* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Angle_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Sonar_bins_Initialize(Base_samples_Sonar_bins* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Sonar_Initialize(Base_samples_Sonar* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set timestamps */
+	Base_samples_Sonar_timestamps_Initialize((&(pVal->timestamps)));
+	/*set bin_duration */
+	Base_Time_Initialize((&(pVal->bin_duration)));
+	/*set beam_width */
+	Base_Angle_Initialize((&(pVal->beam_width)));
+	/*set beam_height */
+	Base_Angle_Initialize((&(pVal->beam_height)));
+	/*set bearings */
+	Base_samples_Sonar_bearings_Initialize((&(pVal->bearings)));
+	/*set speed_of_sound */
+	T_Float_Initialize((&(pVal->speed_of_sound)));
+	/*set bin_count */
+	T_UInt32_Initialize((&(pVal->bin_count)));
+	/*set beam_count */
+	T_UInt32_Initialize((&(pVal->beam_count)));
+	/*set bins */
+	Base_samples_Sonar_bins_Initialize((&(pVal->bins)));
+}
+
+flag Base_samples_Sonar_IsConstraintValid(const Base_samples_Sonar* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_TIMESTAMPS;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->beam_width.rad) && (pVal->beam_width.rad <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH_RAD;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->beam_height.rad) && (pVal->beam_height.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT_RAD;
+            if (ret) {
+                ret = ((1 <= pVal->bearings.nCount) && (pVal->bearings.nCount <= 200));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEARINGS;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->bearings.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->bearings.arr[i1].rad) && (pVal->bearings.arr[i1].rad <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM_RAD;
+                    }
+                }
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_SPEED_OF_SOUND;
+                    if (ret) {
+                        ret = (pVal->bin_count <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BIN_COUNT;
+                        if (ret) {
+                            ret = (pVal->beam_count <= 4294967295UL);
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_COUNT;
+                            if (ret) {
+                                ret = ((1 <= pVal->bins.nCount) && (pVal->bins.nCount <= 200));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BINS;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->bins.nCount; i1++)
+                                    {
+                                    	ret = ((-3.40282346600000020000E+038 <= pVal->bins.arr[i1]) && (pVal->bins.arr[i1] <= 3.40282346600000020000E+038));
+                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BINS_ELM;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Sonar_Encode(const Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Sonar_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode timestamps */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode bin_duration */
+	            ret = Base_Time_Encode((&(pVal->bin_duration)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode beam_width */
+	                ret = Base_Angle_Encode((&(pVal->beam_width)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode beam_height */
+	                    ret = Base_Angle_Encode((&(pVal->beam_height)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode bearings */
+	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bearings.nCount, 1, 200);
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++)
+	                        {
+	                        	ret = Base_Angle_Encode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                        }
+	                        if (ret) {
+	                            /*Encode speed_of_sound */
+	                            ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode bin_count */
+	                                ret = T_UInt32_Encode((&(pVal->bin_count)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode beam_count */
+	                                    ret = T_UInt32_Encode((&(pVal->beam_count)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode bins */
+	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bins.nCount, 1, 200);
+	                                        	
+	                                        for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++)
+	                                        {
+	                                        	ret = T_Float_Encode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Sonar_Decode(Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode timestamps */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS;
+	    pVal->timestamps.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode bin_duration */
+	        ret = Base_Time_Decode((&(pVal->bin_duration)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode beam_width */
+	            ret = Base_Angle_Decode((&(pVal->beam_width)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode beam_height */
+	                ret = Base_Angle_Decode((&(pVal->beam_height)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode bearings */
+	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS;
+	                    pVal->bearings.nCount = (long)nCount;
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++)
+	                    {
+	                    	ret = Base_Angle_Decode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode);
+	                    }
+	                    if (ret) {
+	                        /*Decode speed_of_sound */
+	                        ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode bin_count */
+	                            ret = T_UInt32_Decode((&(pVal->bin_count)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode beam_count */
+	                                ret = T_UInt32_Decode((&(pVal->beam_count)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode bins */
+	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS;
+	                                    pVal->bins.nCount = (long)nCount;
+	                                    	
+	                                    for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++)
+	                                    {
+	                                    	ret = T_Float_Decode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Sonar_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_SonarScan_data_Initialize(Base_samples_SonarScan_data* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 200);
+	pVal->nCount = 1;
+
+}
+void Base_samples_SonarScan_time_beams_Initialize(Base_samples_SonarScan_time_beams* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_SonarScan_Initialize(Base_samples_SonarScan* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set data */
+	Base_samples_SonarScan_data_Initialize((&(pVal->data)));
+	/*set time_beams */
+	Base_samples_SonarScan_time_beams_Initialize((&(pVal->time_beams)));
+	/*set number_of_beams */
+	T_UInt16_Initialize((&(pVal->number_of_beams)));
+	/*set number_of_bins */
+	T_UInt16_Initialize((&(pVal->number_of_bins)));
+	/*set start_bearing */
+	Base_Angle_Initialize((&(pVal->start_bearing)));
+	/*set angular_resolution */
+	Base_Angle_Initialize((&(pVal->angular_resolution)));
+	/*set sampling_interval */
+	T_Double_Initialize((&(pVal->sampling_interval)));
+	/*set speed_of_sound */
+	T_Float_Initialize((&(pVal->speed_of_sound)));
+	/*set beamwidth_horizontal */
+	Base_Angle_Initialize((&(pVal->beamwidth_horizontal)));
+	/*set beamwidth_vertical */
+	Base_Angle_Initialize((&(pVal->beamwidth_vertical)));
+	/*set memory_layout_column */
+	T_Boolean_Initialize((&(pVal->memory_layout_column)));
+	/*set polar_coordinates */
+	T_Boolean_Initialize((&(pVal->polar_coordinates)));
+}
+
+flag Base_samples_SonarScan_IsConstraintValid(const Base_samples_SonarScan* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_DATA;
+    if (ret) {
+        ret = ((1 <= pVal->time_beams.nCount) && (pVal->time_beams.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
+        if (ret) {
+            ret = (pVal->number_of_beams <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS;
+            if (ret) {
+                ret = (pVal->number_of_bins <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS;
+                if (ret) {
+                    ret = ((-1.79769313486231570000E+308 <= pVal->start_bearing.rad) && (pVal->start_bearing.rad <= 1.79769313486231570000E+308));
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_START_BEARING_RAD;
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution.rad) && (pVal->angular_resolution.rad <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_RAD;
+                        if (ret) {
+                            ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL;
+                            if (ret) {
+                                ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND;
+                                if (ret) {
+                                    ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_horizontal.rad) && (pVal->beamwidth_horizontal.rad <= 1.79769313486231570000E+308));
+                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_RAD;
+                                    if (ret) {
+                                        ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_vertical.rad) && (pVal->beamwidth_vertical.rad <= 1.79769313486231570000E+308));
+                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_RAD;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_SonarScan_Encode(const Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_SonarScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode data */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	        {
+	        	BitStream_AppendByte0(pBitStrm, pVal->data.arr[i1]);
+	        }
+	        if (ret) {
+	            /*Encode time_beams */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time_beams.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++)
+	            {
+	            	ret = Base_Time_Encode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	            if (ret) {
+	                /*Encode number_of_beams */
+	                ret = T_UInt16_Encode((&(pVal->number_of_beams)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode number_of_bins */
+	                    ret = T_UInt16_Encode((&(pVal->number_of_bins)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode start_bearing */
+	                        ret = Base_Angle_Encode((&(pVal->start_bearing)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode angular_resolution */
+	                            ret = Base_Angle_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode sampling_interval */
+	                                ret = T_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode speed_of_sound */
+	                                    ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode beamwidth_horizontal */
+	                                        ret = Base_Angle_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode beamwidth_vertical */
+	                                            ret = Base_Angle_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
+	                                            if (ret) {
+	                                                /*Encode memory_layout_column */
+	                                                ret = T_Boolean_Encode((&(pVal->memory_layout_column)), pBitStrm, pErrCode, FALSE);
+	                                                if (ret) {
+	                                                    /*Encode polar_coordinates */
+	                                                    ret = T_Boolean_Encode((&(pVal->polar_coordinates)), pBitStrm, pErrCode, FALSE);
+	                                                }
+	                                            }
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_SonarScan_Decode(Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode data */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
+	    pVal->data.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->data.arr[i1]));
+	    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
+	    }
+	    if (ret) {
+	        /*Decode time_beams */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
+	        pVal->time_beams.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Decode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode);
+	        }
+	        if (ret) {
+	            /*Decode number_of_beams */
+	            ret = T_UInt16_Decode((&(pVal->number_of_beams)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode number_of_bins */
+	                ret = T_UInt16_Decode((&(pVal->number_of_bins)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode start_bearing */
+	                    ret = Base_Angle_Decode((&(pVal->start_bearing)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode angular_resolution */
+	                        ret = Base_Angle_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode sampling_interval */
+	                            ret = T_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode speed_of_sound */
+	                                ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode beamwidth_horizontal */
+	                                    ret = Base_Angle_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode beamwidth_vertical */
+	                                        ret = Base_Angle_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
+	                                        if (ret) {
+	                                            /*Decode memory_layout_column */
+	                                            ret = T_Boolean_Decode((&(pVal->memory_layout_column)), pBitStrm, pErrCode);
+	                                            if (ret) {
+	                                                /*Decode polar_coordinates */
+	                                                ret = T_Boolean_Decode((&(pVal->polar_coordinates)), pBitStrm, pErrCode);
+	                                            }
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_SonarScan_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_MatrixXd_data_Initialize(Wrappers_MatrixXd_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_MatrixXd_Initialize(Wrappers_MatrixXd* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set rows */
+	T_Int32_Initialize((&(pVal->rows)));
+	/*set cols */
+	T_Int32_Initialize((&(pVal->cols)));
+	/*set data */
+	Wrappers_MatrixXd_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_MatrixXd_IsConstraintValid(const Wrappers_MatrixXd* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-2147483648LL <= pVal->rows) && (pVal->rows <= 2147483647LL));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_ROWS;
+    if (ret) {
+        ret = ((-2147483648LL <= pVal->cols) && (pVal->cols <= 2147483647LL));
+        *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_COLS;
+        if (ret) {
+            ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+            *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_MatrixXd_Encode(const Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_MatrixXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode rows */
+	    ret = T_Int32_Encode((&(pVal->rows)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode cols */
+	        ret = T_Int32_Encode((&(pVal->cols)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode data */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	            {
+	            	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_MatrixXd_Decode(Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode rows */
+	ret = T_Int32_Decode((&(pVal->rows)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode cols */
+	    ret = T_Int32_Decode((&(pVal->cols)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode data */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA;
+	        pVal->data.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	        {
+	        	ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Wrappers_MatrixXd_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Dummy2Base_T_Initialize(Dummy2Base_T* pVal)
+{
+	(void)pVal;
+
+
+	DummyBase_T_Initialize(pVal);
+}
+
+flag Dummy2Base_T_IsConstraintValid(const Dummy2Base_T* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_DUMMY2BASE_T;
+
+	return ret;
+}
+
+flag Dummy2Base_T_Encode(const Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Dummy2Base_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = DummyBase_T_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Dummy2Base_T_Decode(Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = DummyBase_T_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && Dummy2Base_T_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointState_MODE_Initialize(Base_JointState_MODE* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_jointstate_mode_acceleration;
+}
+
+flag Base_JointState_MODE_IsConstraintValid(const Base_JointState_MODE* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((*(pVal)) == base_jointstate_mode_acceleration)) || (((*(pVal)) == base_jointstate_mode_effort)))) || (((*(pVal)) == base_jointstate_mode_position)))) || (((*(pVal)) == base_jointstate_mode_raw)))) || (((*(pVal)) == base_jointstate_mode_speed)))) || (((*(pVal)) == base_jointstate_mode_unset)));
+    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_MODE;
+
+	return ret;
+}
+
+flag Base_JointState_MODE_Encode(const Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointState_MODE_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_jointstate_mode_acceleration:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
+	        	break;
+	        case base_jointstate_mode_effort:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
+	        	break;
+	        case base_jointstate_mode_position:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
+	        	break;
+	        case base_jointstate_mode_raw:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
+	        	break;
+	        case base_jointstate_mode_speed:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
+	        	break;
+	        case base_jointstate_mode_unset:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_JOINTSTATE_MODE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointState_MODE_Decode(Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_jointstate_mode_acceleration;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_jointstate_mode_effort;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_jointstate_mode_position;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_jointstate_mode_raw;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_jointstate_mode_speed;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_jointstate_mode_unset;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_jointstate_mode_acceleration;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_JointState_MODE_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Time_Resolution_Initialize(Base_Time_Resolution* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_time_resolution_microseconds;
+}
+
+flag Base_Time_Resolution_IsConstraintValid(const Base_Time_Resolution* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == base_time_resolution_microseconds)) || (((*(pVal)) == base_time_resolution_milliseconds)))) || (((*(pVal)) == base_time_resolution_seconds)));
+    *pErrCode = ret ? 0 :  ERR_BASE_TIME_RESOLUTION;
+
+	return ret;
+}
+
+flag Base_Time_Resolution_Encode(const Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Time_Resolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_time_resolution_microseconds:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case base_time_resolution_milliseconds:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case base_time_resolution_seconds:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_TIME_RESOLUTION; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Time_Resolution_Decode(Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_TIME_RESOLUTION;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_time_resolution_microseconds;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_time_resolution_milliseconds;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_time_resolution_seconds;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_TIME_RESOLUTION;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_time_resolution_microseconds;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_Time_Resolution_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_geometry_SplineBase_CoordinateType_Initialize(Base_geometry_SplineBase_CoordinateType* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;
+}
+
+flag Base_geometry_SplineBase_CoordinateType_IsConstraintValid(const Base_geometry_SplineBase_CoordinateType* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((((*(pVal)) == base_geometry_splinebase_coordinatetype_derivative_to_next)) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_derivative_to_prior)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_knuckle_point)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_ordinary_point)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_second_derivative_to_next)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_second_derivative_to_prior)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_tangent_point_for_next)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_tangent_point_for_prior)));
+    *pErrCode = ret ? 0 :  ERR_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;
+
+	return ret;
+}
+
+flag Base_geometry_SplineBase_CoordinateType_Encode(const Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_geometry_splinebase_coordinatetype_derivative_to_next:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_derivative_to_prior:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_knuckle_point:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_ordinary_point:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_second_derivative_to_next:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_second_derivative_to_prior:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_tangent_point_for_next:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_tangent_point_for_prior:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_geometry_SplineBase_CoordinateType_Decode(Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_prior;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_knuckle_point;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_ordinary_point;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_second_derivative_to_next;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_second_derivative_to_prior;
+	                break;
+	            case 6:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_tangent_point_for_next;
+	                break;
+	            case 7:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_tangent_point_for_prior;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;
+}
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((*(pVal)) == base_samples_depthmap_depth_measurement_state_measurement_error)) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_too_far)))) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_too_near)))) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_valid_measurement)));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Encode(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_depthmap_depth_measurement_state_measurement_error:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	        	break;
+	        case base_samples_depthmap_depth_measurement_state_too_far:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	        	break;
+	        case base_samples_depthmap_depth_measurement_state_too_near:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	        	break;
+	        case base_samples_depthmap_depth_measurement_state_valid_measurement:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Decode(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_too_far;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_too_near;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_valid_measurement;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_PROJECTION_TYPE_Initialize(Base_samples_DepthMap_PROJECTION_TYPE* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_depthmap_projection_type_planar;
+}
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((*(pVal)) == base_samples_depthmap_projection_type_planar)) || (((*(pVal)) == base_samples_depthmap_projection_type_polar)));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_Encode(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_depthmap_projection_type_planar:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
+	        	break;
+	        case base_samples_depthmap_projection_type_polar:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_Decode(Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_depthmap_projection_type_planar;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_depthmap_projection_type_polar;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_depthmap_projection_type_planar;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_timestamps_Initialize(Base_samples_DepthMap_timestamps* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_vertical_interval_Initialize(Base_samples_DepthMap_vertical_interval* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_horizontal_interval_Initialize(Base_samples_DepthMap_horizontal_interval* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_distances_Initialize(Base_samples_DepthMap_distances* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_remissions_Initialize(Base_samples_DepthMap_remissions* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_Initialize(Base_samples_DepthMap* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set timestamps */
+	Base_samples_DepthMap_timestamps_Initialize((&(pVal->timestamps)));
+	/*set vertical_projection */
+	Base_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->vertical_projection)));
+	/*set horizontal_projection */
+	Base_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->horizontal_projection)));
+	/*set vertical_interval */
+	Base_samples_DepthMap_vertical_interval_Initialize((&(pVal->vertical_interval)));
+	/*set horizontal_interval */
+	Base_samples_DepthMap_horizontal_interval_Initialize((&(pVal->horizontal_interval)));
+	/*set vertical_size */
+	T_UInt32_Initialize((&(pVal->vertical_size)));
+	/*set horizontal_size */
+	T_UInt32_Initialize((&(pVal->horizontal_size)));
+	/*set distances */
+	Base_samples_DepthMap_distances_Initialize((&(pVal->distances)));
+	/*set remissions */
+	Base_samples_DepthMap_remissions_Initialize((&(pVal->remissions)));
+}
+
+flag Base_samples_DepthMap_IsConstraintValid(const Base_samples_DepthMap* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
+    if (ret) {
+        ret = (((pVal->vertical_projection == base_samples_depthmap_projection_type_planar)) || ((pVal->vertical_projection == base_samples_depthmap_projection_type_polar)));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION;
+        if (ret) {
+            ret = (((pVal->horizontal_projection == base_samples_depthmap_projection_type_planar)) || ((pVal->horizontal_projection == base_samples_depthmap_projection_type_polar)));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION;
+            if (ret) {
+                ret = ((1 <= pVal->vertical_interval.nCount) && (pVal->vertical_interval.nCount <= 200));
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->vertical_interval.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->vertical_interval.arr[i1]) && (pVal->vertical_interval.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = ((1 <= pVal->horizontal_interval.nCount) && (pVal->horizontal_interval.nCount <= 200));
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->horizontal_interval.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->horizontal_interval.arr[i1]) && (pVal->horizontal_interval.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = (pVal->vertical_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE;
+                        if (ret) {
+                            ret = (pVal->horizontal_size <= 4294967295UL);
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE;
+                            if (ret) {
+                                ret = ((1 <= pVal->distances.nCount) && (pVal->distances.nCount <= 200));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->distances.nCount; i1++)
+                                    {
+                                    	ret = ((-3.40282346600000020000E+038 <= pVal->distances.arr[i1]) && (pVal->distances.arr[i1] <= 3.40282346600000020000E+038));
+                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM;
+                                    }
+                                }
+                                if (ret) {
+                                    ret = ((1 <= pVal->remissions.nCount) && (pVal->remissions.nCount <= 200));
+                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
+                                    if (ret) {
+                                        for(i1 = 0; ret && i1 < pVal->remissions.nCount; i1++)
+                                        {
+                                        	ret = ((-3.40282346600000020000E+038 <= pVal->remissions.arr[i1]) && (pVal->remissions.arr[i1] <= 3.40282346600000020000E+038));
+                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_Encode(const Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_DepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode timestamps */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode vertical_projection */
+	            ret = Base_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->vertical_projection)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode horizontal_projection */
+	                ret = Base_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->horizontal_projection)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode vertical_interval */
+	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertical_interval.nCount, 1, 200);
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Encode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                    }
+	                    if (ret) {
+	                        /*Encode horizontal_interval */
+	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->horizontal_interval.nCount, 1, 200);
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++)
+	                        {
+	                        	ret = T_Double_Encode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                        }
+	                        if (ret) {
+	                            /*Encode vertical_size */
+	                            ret = T_UInt32_Encode((&(pVal->vertical_size)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode horizontal_size */
+	                                ret = T_UInt32_Encode((&(pVal->horizontal_size)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode distances */
+	                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->distances.nCount, 1, 200);
+	                                    	
+	                                    for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++)
+	                                    {
+	                                    	ret = T_Float_Encode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                    }
+	                                    if (ret) {
+	                                        /*Encode remissions */
+	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remissions.nCount, 1, 200);
+	                                        	
+	                                        for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++)
+	                                        {
+	                                        	ret = T_Float_Encode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_Decode(Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode timestamps */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
+	    pVal->timestamps.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode vertical_projection */
+	        ret = Base_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->vertical_projection)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode horizontal_projection */
+	            ret = Base_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->horizontal_projection)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode vertical_interval */
+	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
+	                pVal->vertical_interval.nCount = (long)nCount;
+	                	
+	                for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++)
+	                {
+	                	ret = T_Double_Decode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode);
+	                }
+	                if (ret) {
+	                    /*Decode horizontal_interval */
+	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
+	                    pVal->horizontal_interval.nCount = (long)nCount;
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Decode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode);
+	                    }
+	                    if (ret) {
+	                        /*Decode vertical_size */
+	                        ret = T_UInt32_Decode((&(pVal->vertical_size)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode horizontal_size */
+	                            ret = T_UInt32_Decode((&(pVal->horizontal_size)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode distances */
+	                                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES;
+	                                pVal->distances.nCount = (long)nCount;
+	                                	
+	                                for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++)
+	                                {
+	                                	ret = T_Float_Decode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode);
+	                                }
+	                                if (ret) {
+	                                    /*Decode remissions */
+	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
+	                                    pVal->remissions.nCount = (long)nCount;
+	                                    	
+	                                    for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++)
+	                                    {
+	                                    	ret = T_Float_Decode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_UNIT_AXIS_Initialize(Base_samples_DepthMap_UNIT_AXIS* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_depthmap_unit_axis_unit_x;
+}
+
+flag Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const Base_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == base_samples_depthmap_unit_axis_unit_x)) || (((*(pVal)) == base_samples_depthmap_unit_axis_unit_y)))) || (((*(pVal)) == base_samples_depthmap_unit_axis_unit_z)));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_UNIT_AXIS_Encode(const Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_depthmap_unit_axis_unit_x:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case base_samples_depthmap_unit_axis_unit_y:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case base_samples_depthmap_unit_axis_unit_z:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_UNIT_AXIS_Decode(Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_x;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_y;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_z;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_depthmap_unit_axis_unit_x;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_LASER_RANGE_ERRORS_Initialize(Base_samples_LASER_RANGE_ERRORS* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;
+}
+
+flag Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(const Base_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((*(pVal)) == base_samples_laser_range_errors_end_laser_range_errors)) || (((*(pVal)) == base_samples_laser_range_errors_max_range_error)))) || (((*(pVal)) == base_samples_laser_range_errors_measurement_error)))) || (((*(pVal)) == base_samples_laser_range_errors_other_range_errors)))) || (((*(pVal)) == base_samples_laser_range_errors_too_far)))) || (((*(pVal)) == base_samples_laser_range_errors_too_near)));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASER_RANGE_ERRORS;
+
+	return ret;
+}
+
+flag Base_samples_LASER_RANGE_ERRORS_Encode(const Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_laser_range_errors_end_laser_range_errors:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_max_range_error:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_measurement_error:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_other_range_errors:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_too_far:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_too_near:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_LASER_RANGE_ERRORS; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_LASER_RANGE_ERRORS_Decode(Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_laser_range_errors_max_range_error;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_laser_range_errors_measurement_error;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_samples_laser_range_errors_other_range_errors;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_samples_laser_range_errors_too_far;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_samples_laser_range_errors_too_near;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_mode_t_Initialize(Base_samples_frame_frame_mode_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;
+}
+
+flag Base_samples_frame_frame_mode_t_IsConstraintValid(const Base_samples_frame_frame_mode_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((((((((((((((((((((*(pVal)) == base_samples_frame_frame_mode_t_compressed_modes)) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bgr)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_grayscale)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_jpeg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_pjpg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_png)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_rgb)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_rgb32)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_undefined)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_uyvy)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_raw_modes)));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_MODE_T;
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_mode_t_Encode(const Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_frame_frame_mode_t_compressed_modes:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_bggr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_gbrg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_grbg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_rggb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bgr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_grayscale:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_jpeg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_pjpg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_png:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_rgb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_rgb32:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_undefined:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_uyvy:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_raw_modes:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 15);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_MODE_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_mode_t_Decode(Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 15);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_bggr;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_gbrg;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_grbg;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_rggb;
+	                break;
+	            case 6:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bgr;
+	                break;
+	            case 7:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_grayscale;
+	                break;
+	            case 8:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_jpeg;
+	                break;
+	            case 9:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_pjpg;
+	                break;
+	            case 10:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_png;
+	                break;
+	            case 11:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_rgb;
+	                break;
+	            case 12:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_rgb32;
+	                break;
+	            case 13:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_undefined;
+	                break;
+	            case 14:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_uyvy;
+	                break;
+	            case 15:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_raw_modes;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_status_t_Initialize(Base_samples_frame_frame_status_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_frame_frame_status_t_status_empty;
+}
+
+flag Base_samples_frame_frame_status_t_IsConstraintValid(const Base_samples_frame_frame_status_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == base_samples_frame_frame_status_t_status_empty)) || (((*(pVal)) == base_samples_frame_frame_status_t_status_invalid)))) || (((*(pVal)) == base_samples_frame_frame_status_t_status_valid)));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_STATUS_T;
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_status_t_Encode(const Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_frame_frame_status_t_status_empty:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case base_samples_frame_frame_status_t_status_invalid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case base_samples_frame_frame_status_t_status_valid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_status_t_Decode(Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_frame_frame_status_t_status_empty;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_frame_frame_status_t_status_invalid;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_frame_frame_status_t_status_valid;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_frame_frame_status_t_status_empty;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_Frame_image_Initialize(Base_samples_frame_Frame_image* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 200);
+	pVal->nCount = 1;
+
+}
+void Base_samples_frame_Frame_attributes_Initialize(Base_samples_frame_Frame_attributes* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_samples_frame_frame_attrib_t_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_frame_Frame_Initialize(Base_samples_frame_Frame* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set received_time */
+	Base_Time_Initialize((&(pVal->received_time)));
+	/*set image */
+	Base_samples_frame_Frame_image_Initialize((&(pVal->image)));
+	/*set attributes */
+	Base_samples_frame_Frame_attributes_Initialize((&(pVal->attributes)));
+	/*set size_val */
+	Base_samples_frame_frame_size_t_Initialize((&(pVal->size_val)));
+	/*set data_depth */
+	T_UInt32_Initialize((&(pVal->data_depth)));
+	/*set pixel_size */
+	T_UInt32_Initialize((&(pVal->pixel_size)));
+	/*set row_size */
+	T_UInt32_Initialize((&(pVal->row_size)));
+	/*set frame_mode */
+	Base_samples_frame_frame_mode_t_Initialize((&(pVal->frame_mode)));
+	/*set frame_status */
+	Base_samples_frame_frame_status_t_Initialize((&(pVal->frame_status)));
+}
+
+flag Base_samples_frame_Frame_IsConstraintValid(const Base_samples_frame_Frame* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->image.nCount) && (pVal->image.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_IMAGE;
+    if (ret) {
+        ret = ((1 <= pVal->attributes.nCount) && (pVal->attributes.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.arr[i1].data.nCount <= 40);
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA;
+            	if (ret) {
+            	    ret = (pVal->attributes.arr[i1].name_val.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL;
+            	}
+            }
+        }
+        if (ret) {
+            ret = (pVal->size_val.width <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_WIDTH;
+            if (ret) {
+                ret = (pVal->size_val.height <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_HEIGHT;
+            }
+            if (ret) {
+                ret = (pVal->data_depth <= 4294967295UL);
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH;
+                if (ret) {
+                    ret = (pVal->pixel_size <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE;
+                    if (ret) {
+                        ret = (pVal->row_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE;
+                        if (ret) {
+                            ret = (((((((((((((((((((((((((((((((pVal->frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE;
+                            if (ret) {
+                                ret = (((((pVal->frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->frame_status == base_samples_frame_frame_status_t_status_valid)));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_Frame_Encode(const Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_frame_Frame_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode received_time */
+	        ret = Base_Time_Encode((&(pVal->received_time)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode image */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->image.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++)
+	            {
+	            	BitStream_AppendByte0(pBitStrm, pVal->image.arr[i1]);
+	            }
+	            if (ret) {
+	                /*Encode attributes */
+	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 1, 200);
+	                	
+	                for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	                {
+	                	ret = Base_samples_frame_frame_attrib_t_Encode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                }
+	                if (ret) {
+	                    /*Encode size_val */
+	                    ret = Base_samples_frame_frame_size_t_Encode((&(pVal->size_val)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode data_depth */
+	                        ret = T_UInt32_Encode((&(pVal->data_depth)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode pixel_size */
+	                            ret = T_UInt32_Encode((&(pVal->pixel_size)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode row_size */
+	                                ret = T_UInt32_Encode((&(pVal->row_size)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode frame_mode */
+	                                    ret = Base_samples_frame_frame_mode_t_Encode((&(pVal->frame_mode)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode frame_status */
+	                                        ret = Base_samples_frame_frame_status_t_Encode((&(pVal->frame_status)), pBitStrm, pErrCode, FALSE);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_Frame_Decode(Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode received_time */
+	    ret = Base_Time_Decode((&(pVal->received_time)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode image */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
+	        pVal->image.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++)
+	        {
+	        	ret = BitStream_ReadByte(pBitStrm, &(pVal->image.arr[i1]));
+	        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
+	        }
+	        if (ret) {
+	            /*Decode attributes */
+	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
+	            pVal->attributes.nCount = (long)nCount;
+	            	
+	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	            {
+	            	ret = Base_samples_frame_frame_attrib_t_Decode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode);
+	            }
+	            if (ret) {
+	                /*Decode size_val */
+	                ret = Base_samples_frame_frame_size_t_Decode((&(pVal->size_val)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode data_depth */
+	                    ret = T_UInt32_Decode((&(pVal->data_depth)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode pixel_size */
+	                        ret = T_UInt32_Decode((&(pVal->pixel_size)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode row_size */
+	                            ret = T_UInt32_Decode((&(pVal->row_size)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode frame_mode */
+	                                ret = Base_samples_frame_frame_mode_t_Decode((&(pVal->frame_mode)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode frame_status */
+	                                    ret = Base_samples_frame_frame_status_t_Decode((&(pVal->frame_status)), pBitStrm, pErrCode);
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_frame_Frame_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_FramePair_Initialize(Base_samples_frame_FramePair* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set first */
+	Base_samples_frame_Frame_Initialize((&(pVal->first)));
+	/*set second */
+	Base_samples_frame_Frame_Initialize((&(pVal->second)));
+	/*set id */
+	T_UInt32_Initialize((&(pVal->id)));
+}
+
+flag Base_samples_frame_FramePair_IsConstraintValid(const Base_samples_frame_FramePair* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->first.image.nCount) && (pVal->first.image.nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE;
+    if (ret) {
+        ret = ((1 <= pVal->first.attributes.nCount) && (pVal->first.attributes.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->first.attributes.nCount; i1++)
+            {
+            	ret = (pVal->first.attributes.arr[i1].data.nCount <= 40);
+            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA;
+            	if (ret) {
+            	    ret = (pVal->first.attributes.arr[i1].name_val.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL;
+            	}
+            }
+        }
+        if (ret) {
+            ret = (pVal->first.size_val.width <= 65535UL);
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_WIDTH;
+            if (ret) {
+                ret = (pVal->first.size_val.height <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_HEIGHT;
+            }
+            if (ret) {
+                ret = (pVal->first.data_depth <= 4294967295UL);
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_DATA_DEPTH;
+                if (ret) {
+                    ret = (pVal->first.pixel_size <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_PIXEL_SIZE;
+                    if (ret) {
+                        ret = (pVal->first.row_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ROW_SIZE;
+                        if (ret) {
+                            ret = (((((((((((((((((((((((((((((((pVal->first.frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE;
+                            if (ret) {
+                                ret = (((((pVal->first.frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->first.frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->first.frame_status == base_samples_frame_frame_status_t_status_valid)));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->second.image.nCount) && (pVal->second.image.nCount <= 200));
+        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE;
+        if (ret) {
+            ret = ((1 <= pVal->second.attributes.nCount) && (pVal->second.attributes.nCount <= 200));
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->second.attributes.nCount; i1++)
+                {
+                	ret = (pVal->second.attributes.arr[i1].data.nCount <= 40);
+                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA;
+                	if (ret) {
+                	    ret = (pVal->second.attributes.arr[i1].name_val.nCount <= 40);
+                	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL;
+                	}
+                }
+            }
+            if (ret) {
+                ret = (pVal->second.size_val.width <= 65535UL);
+                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_WIDTH;
+                if (ret) {
+                    ret = (pVal->second.size_val.height <= 65535UL);
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_HEIGHT;
+                }
+                if (ret) {
+                    ret = (pVal->second.data_depth <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_DATA_DEPTH;
+                    if (ret) {
+                        ret = (pVal->second.pixel_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_PIXEL_SIZE;
+                        if (ret) {
+                            ret = (pVal->second.row_size <= 4294967295UL);
+                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ROW_SIZE;
+                            if (ret) {
+                                ret = (((((((((((((((((((((((((((((((pVal->second.frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
+                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE;
+                                if (ret) {
+                                    ret = (((((pVal->second.frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->second.frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->second.frame_status == base_samples_frame_frame_status_t_status_valid)));
+                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (ret) {
+            ret = (pVal->id <= 4294967295UL);
+            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_ID;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_FramePair_Encode(const Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode first */
+	        ret = Base_samples_frame_Frame_Encode((&(pVal->first)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode second */
+	            ret = Base_samples_frame_Frame_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode id */
+	                ret = T_UInt32_Encode((&(pVal->id)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_FramePair_Decode(Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode first */
+	    ret = Base_samples_frame_Frame_Decode((&(pVal->first)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode second */
+	        ret = Base_samples_frame_Frame_Decode((&(pVal->second)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode id */
+	            ret = T_UInt32_Decode((&(pVal->id)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_geometry_SplineType_Initialize(Wrappers_geometry_SplineType* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = wrappers_geometry_splinetype_degenerate;
+}
+
+flag Wrappers_geometry_SplineType_IsConstraintValid(const Wrappers_geometry_SplineType* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((*(pVal)) == wrappers_geometry_splinetype_degenerate)) || (((*(pVal)) == wrappers_geometry_splinetype_polynomial_bezier)))) || (((*(pVal)) == wrappers_geometry_splinetype_polynomial_bspline)))) || (((*(pVal)) == wrappers_geometry_splinetype_rational_bezier)))) || (((*(pVal)) == wrappers_geometry_splinetype_rational_bspline)));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINETYPE;
+
+	return ret;
+}
+
+flag Wrappers_geometry_SplineType_Encode(const Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Wrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case wrappers_geometry_splinetype_degenerate:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_polynomial_bezier:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_polynomial_bspline:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_rational_bezier:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_rational_bspline:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINETYPE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_geometry_SplineType_Decode(Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
+	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = wrappers_geometry_splinetype_degenerate;
+	                break;
+	            case 1:
+	                (*(pVal)) = wrappers_geometry_splinetype_polynomial_bezier;
+	                break;
+	            case 2:
+	                (*(pVal)) = wrappers_geometry_splinetype_polynomial_bspline;
+	                break;
+	            case 3:
+	                (*(pVal)) = wrappers_geometry_splinetype_rational_bezier;
+	                break;
+	            case 4:
+	                (*(pVal)) = wrappers_geometry_splinetype_rational_bspline;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = wrappers_geometry_splinetype_degenerate;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Wrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_geometry_Spline_knots_Initialize(Wrappers_geometry_Spline_knots* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_geometry_Spline_vertices_Initialize(Wrappers_geometry_Spline_vertices* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_geometry_Spline_Initialize(Wrappers_geometry_Spline* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set geometric_resolution */
+	T_Double_Initialize((&(pVal->geometric_resolution)));
+	/*set dimension */
+	T_Int32_Initialize((&(pVal->dimension)));
+	/*set curve_order */
+	T_Int32_Initialize((&(pVal->curve_order)));
+	/*set kind */
+	Wrappers_geometry_SplineType_Initialize((&(pVal->kind)));
+	/*set knots */
+	Wrappers_geometry_Spline_knots_Initialize((&(pVal->knots)));
+	/*set vertices */
+	Wrappers_geometry_Spline_vertices_Initialize((&(pVal->vertices)));
+}
+
+flag Wrappers_geometry_Spline_IsConstraintValid(const Wrappers_geometry_Spline* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->geometric_resolution) && (pVal->geometric_resolution <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION;
+    if (ret) {
+        ret = ((-2147483648LL <= pVal->dimension) && (pVal->dimension <= 2147483647LL));
+        *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_DIMENSION;
+        if (ret) {
+            ret = ((-2147483648LL <= pVal->curve_order) && (pVal->curve_order <= 2147483647LL));
+            *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER;
+            if (ret) {
+                ret = (((((((((pVal->kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->kind == wrappers_geometry_splinetype_rational_bspline)));
+                *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KIND;
+                if (ret) {
+                    ret = ((1 <= pVal->knots.nCount) && (pVal->knots.nCount <= 200));
+                    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->knots.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->knots.arr[i1]) && (pVal->knots.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = ((1 <= pVal->vertices.nCount) && (pVal->vertices.nCount <= 200));
+                        *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->vertices.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->vertices.arr[i1]) && (pVal->vertices.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_geometry_Spline_Encode(const Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode geometric_resolution */
+	    ret = T_Double_Encode((&(pVal->geometric_resolution)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode dimension */
+	        ret = T_Int32_Encode((&(pVal->dimension)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode curve_order */
+	            ret = T_Int32_Encode((&(pVal->curve_order)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode kind */
+	                ret = Wrappers_geometry_SplineType_Encode((&(pVal->kind)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode knots */
+	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->knots.nCount, 1, 200);
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Encode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                    }
+	                    if (ret) {
+	                        /*Encode vertices */
+	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertices.nCount, 1, 200);
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++)
+	                        {
+	                        	ret = T_Double_Encode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_geometry_Spline_Decode(Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode geometric_resolution */
+	ret = T_Double_Decode((&(pVal->geometric_resolution)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode dimension */
+	    ret = T_Int32_Decode((&(pVal->dimension)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode curve_order */
+	        ret = T_Int32_Decode((&(pVal->curve_order)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode kind */
+	            ret = Wrappers_geometry_SplineType_Decode((&(pVal->kind)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode knots */
+	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
+	                pVal->knots.nCount = (long)nCount;
+	                	
+	                for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++)
+	                {
+	                	ret = T_Double_Decode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode);
+	                }
+	                if (ret) {
+	                    /*Decode vertices */
+	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
+	                    pVal->vertices.nCount = (long)nCount;
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Decode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode);
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Wrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Trajectory_Initialize(Base_Trajectory* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set speed */
+	T_Double_Initialize((&(pVal->speed)));
+	/*set spline */
+	Wrappers_geometry_Spline_Initialize((&(pVal->spline)));
+}
+
+flag Base_Trajectory_IsConstraintValid(const Base_Trajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPEED;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_GEOMETRIC_RESOLUTION;
+        if (ret) {
+            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
+            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_DIMENSION;
+            if (ret) {
+                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
+                *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_CURVE_ORDER;
+                if (ret) {
+                    ret = (((((((((pVal->spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bspline)));
+                    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KIND;
+                    if (ret) {
+                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
+                        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KNOTS;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KNOTS_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
+                            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_VERTICES;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_VERTICES_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Trajectory_Encode(const Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode speed */
+	    ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode spline */
+	        ret = Wrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Trajectory_Decode(Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode speed */
+	ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode spline */
+	    ret = Wrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Trajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Trajectory_m_Initialize(Base_Trajectory_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set speed */
+	T_Double_Initialize((&(pVal->speed)));
+	/*set spline */
+	Wrappers_geometry_Spline_Initialize((&(pVal->spline)));
+}
+
+flag Base_Trajectory_m_IsConstraintValid(const Base_Trajectory_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPEED;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_GEOMETRIC_RESOLUTION;
+        if (ret) {
+            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
+            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_DIMENSION;
+            if (ret) {
+                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
+                *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_CURVE_ORDER;
+                if (ret) {
+                    ret = (((((((((pVal->spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bspline)));
+                    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KIND;
+                    if (ret) {
+                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
+                        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
+                            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Trajectory_m_Encode(const Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Trajectory_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode speed */
+	    ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode spline */
+	        ret = Wrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Trajectory_m_Decode(Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode speed */
+	ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode spline */
+	    ret = Wrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Trajectory_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Trajectory_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPEED;
+        	if (ret) {
+        	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.geometric_resolution) && (pVal->arr[i1].spline.geometric_resolution <= 1.79769313486231570000E+308));
+        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_GEOMETRIC_RESOLUTION;
+        	    if (ret) {
+        	        ret = ((-2147483648LL <= pVal->arr[i1].spline.dimension) && (pVal->arr[i1].spline.dimension <= 2147483647LL));
+        	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_DIMENSION;
+        	        if (ret) {
+        	            ret = ((-2147483648LL <= pVal->arr[i1].spline.curve_order) && (pVal->arr[i1].spline.curve_order <= 2147483647LL));
+        	            *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_CURVE_ORDER;
+        	            if (ret) {
+        	                ret = (((((((((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_rational_bspline)));
+        	                *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND;
+        	                if (ret) {
+        	                    ret = ((1 <= pVal->arr[i1].spline.knots.nCount) && (pVal->arr[i1].spline.knots.nCount <= 200));
+        	                    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS;
+        	                    if (ret) {
+        	                        for(i2 = 0; ret && i2 < pVal->arr[i1].spline.knots.nCount; i2++)
+        	                        {
+        	                        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.knots.arr[i2]) && (pVal->arr[i1].spline.knots.arr[i2] <= 1.79769313486231570000E+308));
+        	                        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS_ELM;
+        	                        }
+        	                    }
+        	                    if (ret) {
+        	                        ret = ((1 <= pVal->arr[i1].spline.vertices.nCount) && (pVal->arr[i1].spline.vertices.nCount <= 200));
+        	                        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES;
+        	                        if (ret) {
+        	                            for(i2 = 0; ret && i2 < pVal->arr[i1].spline.vertices.nCount; i2++)
+        	                            {
+        	                            	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.vertices.arr[i2]) && (pVal->arr[i1].spline.vertices.arr[i2] <= 1.79769313486231570000E+308));
+        	                            	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES_ELM;
+        	                            }
+        	                        }
+        	                    }
+        	                }
+        	            }
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Encode(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_Trajectory_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Decode(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_Trajectory_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/base.h b/generated/base.h
new file mode 100644
index 0000000..620a2ef
--- /dev/null
+++ b/generated/base.h
@@ -0,0 +1,4008 @@
+#ifndef GENERATED_ASN1SCC_base_H
+#define GENERATED_ASN1SCC_base_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/userdefs-base.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- Base_Angle --------------------------------------------*/
+typedef struct {
+    T_Double rad;
+
+} Base_Angle;
+
+void Base_Angle_Initialize(Base_Angle* pVal);
+
+#define ERR_BASE_ANGLE		891  /**/
+#define ERR_BASE_ANGLE_RAD		880  /**/
+flag Base_Angle_IsConstraintValid(const Base_Angle* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_ANGLE		892  /**/
+#define ERR_UPER_ENCODE_BASE_ANGLE_RAD_2		887  /**/
+#define Base_Angle_REQUIRED_BYTES_FOR_ENCODING       13
+#define Base_Angle_REQUIRED_BITS_FOR_ENCODING        104
+
+flag Base_Angle_Encode(const Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_ANGLE		893  /**/
+#define ERR_UPER_DECODE_BASE_ANGLE_RAD_2		888  /**/
+flag Base_Angle_Decode(Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_Motion2D --------------------------------------------*/
+typedef struct {
+    T_Double translation;
+    T_Double rotation;
+    Base_Angle heading;
+
+} Base_commands_Motion2D;
+
+void Base_commands_Motion2D_Initialize(Base_commands_Motion2D* pVal);
+
+#define ERR_BASE_COMMANDS_MOTION2D		1611  /**/
+#define ERR_BASE_COMMANDS_MOTION2D_TRANSLATION		1567  /**/
+#define ERR_BASE_COMMANDS_MOTION2D_ROTATION		1578  /**/
+#define ERR_BASE_COMMANDS_MOTION2D_HEADING		1600  /**/
+#define ERR_BASE_COMMANDS_MOTION2D_HEADING_RAD		1589  /**/
+flag Base_commands_Motion2D_IsConstraintValid(const Base_commands_Motion2D* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D		1612  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1574  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D_ROTATION_2		1585  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D_HEADING_2		1607  /**/
+#define Base_commands_Motion2D_REQUIRED_BYTES_FOR_ENCODING       39
+#define Base_commands_Motion2D_REQUIRED_BITS_FOR_ENCODING        312
+
+flag Base_commands_Motion2D_Encode(const Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D		1613  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1575  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D_ROTATION_2		1586  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D_HEADING_2		1608  /**/
+flag Base_commands_Motion2D_Decode(Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_PoseUpdateThreshold --------------------------------------------*/
+typedef struct {
+    T_Double distance;
+    T_Double angle;
+
+} Base_PoseUpdateThreshold;
+
+void Base_PoseUpdateThreshold_Initialize(Base_PoseUpdateThreshold* pVal);
+
+#define ERR_BASE_POSEUPDATETHRESHOLD		1029  /**/
+#define ERR_BASE_POSEUPDATETHRESHOLD_DISTANCE		1007  /**/
+#define ERR_BASE_POSEUPDATETHRESHOLD_ANGLE		1018  /**/
+flag Base_PoseUpdateThreshold_IsConstraintValid(const Base_PoseUpdateThreshold* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_POSEUPDATETHRESHOLD		1030  /**/
+#define ERR_UPER_ENCODE_BASE_POSEUPDATETHRESHOLD_DISTANCE_2		1014  /**/
+#define ERR_UPER_ENCODE_BASE_POSEUPDATETHRESHOLD_ANGLE_2		1025  /**/
+#define Base_PoseUpdateThreshold_REQUIRED_BYTES_FOR_ENCODING       26
+#define Base_PoseUpdateThreshold_REQUIRED_BITS_FOR_ENCODING        208
+
+flag Base_PoseUpdateThreshold_Encode(const Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_POSEUPDATETHRESHOLD		1031  /**/
+#define ERR_UPER_DECODE_BASE_POSEUPDATETHRESHOLD_DISTANCE_2		1015  /**/
+#define ERR_UPER_DECODE_BASE_POSEUPDATETHRESHOLD_ANGLE_2		1026  /**/
+flag Base_PoseUpdateThreshold_Decode(Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Temperature --------------------------------------------*/
+typedef struct {
+    T_Double kelvin;
+
+} Base_Temperature;
+
+void Base_Temperature_Initialize(Base_Temperature* pVal);
+
+#define ERR_BASE_TEMPERATURE		1065  /**/
+#define ERR_BASE_TEMPERATURE_KELVIN		1054  /**/
+flag Base_Temperature_IsConstraintValid(const Base_Temperature* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TEMPERATURE		1066  /**/
+#define ERR_UPER_ENCODE_BASE_TEMPERATURE_KELVIN_2		1061  /**/
+#define Base_Temperature_REQUIRED_BYTES_FOR_ENCODING       13
+#define Base_Temperature_REQUIRED_BITS_FOR_ENCODING        104
+
+flag Base_Temperature_Encode(const Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TEMPERATURE		1067  /**/
+#define ERR_UPER_DECODE_BASE_TEMPERATURE_KELVIN_2		1062  /**/
+flag Base_Temperature_Decode(Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_Speed6D --------------------------------------------*/
+typedef struct {
+    T_Double surge;
+    T_Double sway;
+    T_Double heave;
+    T_Double roll;
+    T_Double pitch;
+    T_Double yaw;
+
+} Base_commands_Speed6D;
+
+void Base_commands_Speed6D_Initialize(Base_commands_Speed6D* pVal);
+
+#define ERR_BASE_COMMANDS_SPEED6D		1684  /**/
+#define ERR_BASE_COMMANDS_SPEED6D_SURGE		1618  /**/
+#define ERR_BASE_COMMANDS_SPEED6D_SWAY		1629  /**/
+#define ERR_BASE_COMMANDS_SPEED6D_HEAVE		1640  /**/
+#define ERR_BASE_COMMANDS_SPEED6D_ROLL		1651  /**/
+#define ERR_BASE_COMMANDS_SPEED6D_PITCH		1662  /**/
+#define ERR_BASE_COMMANDS_SPEED6D_YAW		1673  /**/
+flag Base_commands_Speed6D_IsConstraintValid(const Base_commands_Speed6D* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D		1685  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_SURGE_2		1625  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_SWAY_2		1636  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_HEAVE_2		1647  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_ROLL_2		1658  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_PITCH_2		1669  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_YAW_2		1680  /**/
+#define Base_commands_Speed6D_REQUIRED_BYTES_FOR_ENCODING       78
+#define Base_commands_Speed6D_REQUIRED_BITS_FOR_ENCODING        624
+
+flag Base_commands_Speed6D_Encode(const Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D		1686  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_SURGE_2		1626  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_SWAY_2		1637  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_HEAVE_2		1648  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_ROLL_2		1659  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_PITCH_2		1670  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_YAW_2		1681  /**/
+flag Base_commands_Speed6D_Decode(Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_AngleAxisd --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[3];
+} Wrappers_AngleAxisd_axis;
+typedef struct {
+    T_Double angle;
+    Wrappers_AngleAxisd_axis axis;
+
+} Wrappers_AngleAxisd;
+
+void Wrappers_AngleAxisd_axis_Initialize(Wrappers_AngleAxisd_axis* pVal);
+void Wrappers_AngleAxisd_Initialize(Wrappers_AngleAxisd* pVal);
+
+#define ERR_WRAPPERS_ANGLEAXISD		5701  /**/
+#define ERR_WRAPPERS_ANGLEAXISD_ANGLE		5672  /**/
+#define ERR_WRAPPERS_ANGLEAXISD_AXIS		5694  /**/
+#define ERR_WRAPPERS_ANGLEAXISD_AXIS_ELM		5683  /**/
+flag Wrappers_AngleAxisd_IsConstraintValid(const Wrappers_AngleAxisd* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD		5702  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD_ANGLE_2		5679  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD_AXIS		5695  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD_AXIS_ELM_2		5690  /**/
+#define Wrappers_AngleAxisd_REQUIRED_BYTES_FOR_ENCODING       53
+#define Wrappers_AngleAxisd_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_AngleAxisd_Encode(const Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD		5703  /**/
+#define ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_ANGLE_2		5680  /**/
+#define ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS		5696  /**/
+#define ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS_ELM_2		5691  /**/
+flag Wrappers_AngleAxisd_Decode(Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector2d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[2];
+} Wrappers_Vector2d_data;
+typedef struct {
+    Wrappers_Vector2d_data data;
+
+} Wrappers_Vector2d;
+
+void Wrappers_Vector2d_data_Initialize(Wrappers_Vector2d_data* pVal);
+void Wrappers_Vector2d_Initialize(Wrappers_Vector2d* pVal);
+
+#define ERR_WRAPPERS_VECTOR2D		5726  /**/
+#define ERR_WRAPPERS_VECTOR2D_DATA		5719  /**/
+#define ERR_WRAPPERS_VECTOR2D_DATA_ELM		5708  /**/
+flag Wrappers_Vector2d_IsConstraintValid(const Wrappers_Vector2d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR2D		5727  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR2D_DATA		5720  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR2D_DATA_ELM_2		5715  /**/
+#define Wrappers_Vector2d_REQUIRED_BYTES_FOR_ENCODING       27
+#define Wrappers_Vector2d_REQUIRED_BITS_FOR_ENCODING        209
+
+flag Wrappers_Vector2d_Encode(const Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR2D		5728  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA		5721  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA_ELM_2		5716  /**/
+flag Wrappers_Vector2d_Decode(Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose2D --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector2d position;
+    T_Double orientation;
+
+} Base_Pose2D;
+
+void Base_Pose2D_Initialize(Base_Pose2D* pVal);
+
+#define ERR_BASE_POSE2D		1000  /**/
+#define ERR_BASE_POSE2D_POSITION		978  /**/
+#define ERR_BASE_POSE2D_POSITION_DATA		971  /**/
+#define ERR_BASE_POSE2D_POSITION_DATA_ELM		960  /**/
+#define ERR_BASE_POSE2D_ORIENTATION		989  /**/
+flag Base_Pose2D_IsConstraintValid(const Base_Pose2D* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_POSE2D		1001  /**/
+#define ERR_UPER_ENCODE_BASE_POSE2D_POSITION_2		985  /**/
+#define ERR_UPER_ENCODE_BASE_POSE2D_ORIENTATION_2		996  /**/
+#define Base_Pose2D_REQUIRED_BYTES_FOR_ENCODING       40
+#define Base_Pose2D_REQUIRED_BITS_FOR_ENCODING        313
+
+flag Base_Pose2D_Encode(const Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_POSE2D		1002  /**/
+#define ERR_UPER_DECODE_BASE_POSE2D_POSITION_2		986  /**/
+#define ERR_UPER_DECODE_BASE_POSE2D_ORIENTATION_2		997  /**/
+flag Base_Pose2D_Decode(Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose2D_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector2d position;
+    T_Double orientation;
+
+} Base_Pose2D_m;
+
+void Base_Pose2D_m_Initialize(Base_Pose2D_m* pVal);
+
+#define ERR_BASE_POSE2D_M		6114  /**/
+#define ERR_BASE_POSE2D_M_POSITION		6092  /**/
+#define ERR_BASE_POSE2D_M_POSITION_DATA		6085  /**/
+#define ERR_BASE_POSE2D_M_POSITION_DATA_ELM		6074  /**/
+#define ERR_BASE_POSE2D_M_ORIENTATION		6103  /**/
+flag Base_Pose2D_m_IsConstraintValid(const Base_Pose2D_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_POSE2D_M		6115  /**/
+#define ERR_UPER_ENCODE_BASE_POSE2D_M_POSITION_2		6099  /**/
+#define ERR_UPER_ENCODE_BASE_POSE2D_M_ORIENTATION_2		6110  /**/
+#define Base_Pose2D_m_REQUIRED_BYTES_FOR_ENCODING       40
+#define Base_Pose2D_m_REQUIRED_BITS_FOR_ENCODING        313
+
+flag Base_Pose2D_m_Encode(const Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_POSE2D_M		6116  /**/
+#define ERR_UPER_DECODE_BASE_POSE2D_M_POSITION_2		6100  /**/
+#define ERR_UPER_DECODE_BASE_POSE2D_M_ORIENTATION_2		6111  /**/
+flag Base_Pose2D_m_Decode(Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix2d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[4];
+} Wrappers_Matrix2d_data;
+typedef struct {
+    Wrappers_Matrix2d_data data;
+
+} Wrappers_Matrix2d;
+
+void Wrappers_Matrix2d_data_Initialize(Wrappers_Matrix2d_data* pVal);
+void Wrappers_Matrix2d_Initialize(Wrappers_Matrix2d* pVal);
+
+#define ERR_WRAPPERS_MATRIX2D		5751  /**/
+#define ERR_WRAPPERS_MATRIX2D_DATA		5744  /**/
+#define ERR_WRAPPERS_MATRIX2D_DATA_ELM		5733  /**/
+flag Wrappers_Matrix2d_IsConstraintValid(const Wrappers_Matrix2d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX2D		5752  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX2D_DATA		5745  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX2D_DATA_ELM_2		5740  /**/
+#define Wrappers_Matrix2d_REQUIRED_BYTES_FOR_ENCODING       53
+#define Wrappers_Matrix2d_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_Matrix2d_Encode(const Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX2D		5753  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA		5746  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA_ELM_2		5741  /**/
+flag Wrappers_Matrix2d_Decode(Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector3d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[3];
+} Wrappers_Vector3d_data;
+typedef struct {
+    Wrappers_Vector3d_data data;
+
+} Wrappers_Vector3d;
+
+void Wrappers_Vector3d_data_Initialize(Wrappers_Vector3d_data* pVal);
+void Wrappers_Vector3d_Initialize(Wrappers_Vector3d* pVal);
+
+#define ERR_WRAPPERS_VECTOR3D		5776  /**/
+#define ERR_WRAPPERS_VECTOR3D_DATA		5769  /**/
+#define ERR_WRAPPERS_VECTOR3D_DATA_ELM		5758  /**/
+flag Wrappers_Vector3d_IsConstraintValid(const Wrappers_Vector3d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR3D		5777  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR3D_DATA		5770  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR3D_DATA_ELM_2		5765  /**/
+#define Wrappers_Vector3d_REQUIRED_BYTES_FOR_ENCODING       40
+#define Wrappers_Vector3d_REQUIRED_BITS_FOR_ENCODING        314
+
+flag Wrappers_Vector3d_Encode(const Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR3D		5778  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA		5771  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA_ELM_2		5766  /**/
+flag Wrappers_Vector3d_Decode(Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Wrench --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+
+} Base_Wrench;
+
+void Base_Wrench_Initialize(Base_Wrench* pVal);
+
+#define ERR_BASE_WRENCH		873  /**/
+#define ERR_BASE_WRENCH_FORCE		833  /**/
+#define ERR_BASE_WRENCH_FORCE_DATA		826  /**/
+#define ERR_BASE_WRENCH_FORCE_DATA_ELM		815  /**/
+#define ERR_BASE_WRENCH_TORQUE		862  /**/
+#define ERR_BASE_WRENCH_TORQUE_DATA		855  /**/
+#define ERR_BASE_WRENCH_TORQUE_DATA_ELM		844  /**/
+flag Base_Wrench_IsConstraintValid(const Base_Wrench* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_WRENCH		874  /**/
+#define ERR_UPER_ENCODE_BASE_WRENCH_FORCE_2		840  /**/
+#define ERR_UPER_ENCODE_BASE_WRENCH_TORQUE_2		869  /**/
+#define Base_Wrench_REQUIRED_BYTES_FOR_ENCODING       79
+#define Base_Wrench_REQUIRED_BITS_FOR_ENCODING        628
+
+flag Base_Wrench_Encode(const Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_WRENCH		875  /**/
+#define ERR_UPER_DECODE_BASE_WRENCH_FORCE_2		841  /**/
+#define ERR_UPER_DECODE_BASE_WRENCH_TORQUE_2		870  /**/
+flag Base_Wrench_Decode(Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Waypoint --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    T_Double heading;
+    T_Double tol_position;
+    T_Double tol_heading;
+
+} Base_Waypoint;
+
+void Base_Waypoint_Initialize(Base_Waypoint* pVal);
+
+#define ERR_BASE_WAYPOINT		1261  /**/
+#define ERR_BASE_WAYPOINT_POSITION		1217  /**/
+#define ERR_BASE_WAYPOINT_POSITION_DATA		1210  /**/
+#define ERR_BASE_WAYPOINT_POSITION_DATA_ELM		1199  /**/
+#define ERR_BASE_WAYPOINT_HEADING		1228  /**/
+#define ERR_BASE_WAYPOINT_TOL_POSITION		1239  /**/
+#define ERR_BASE_WAYPOINT_TOL_HEADING		1250  /**/
+flag Base_Waypoint_IsConstraintValid(const Base_Waypoint* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_WAYPOINT		1262  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_POSITION_2		1224  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_HEADING_2		1235  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_TOL_POSITION_2		1246  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_TOL_HEADING_2		1257  /**/
+#define Base_Waypoint_REQUIRED_BYTES_FOR_ENCODING       79
+#define Base_Waypoint_REQUIRED_BITS_FOR_ENCODING        626
+
+flag Base_Waypoint_Encode(const Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_WAYPOINT		1263  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_POSITION_2		1225  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_HEADING_2		1236  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_TOL_POSITION_2		1247  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_TOL_HEADING_2		1258  /**/
+flag Base_Waypoint_Decode(Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Waypoint_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    T_Double heading;
+    T_Double tol_position;
+    T_Double tol_heading;
+
+} Base_Waypoint_m;
+
+void Base_Waypoint_m_Initialize(Base_Waypoint_m* pVal);
+
+#define ERR_BASE_WAYPOINT_M		6458  /**/
+#define ERR_BASE_WAYPOINT_M_POSITION		6414  /**/
+#define ERR_BASE_WAYPOINT_M_POSITION_DATA		6407  /**/
+#define ERR_BASE_WAYPOINT_M_POSITION_DATA_ELM		6396  /**/
+#define ERR_BASE_WAYPOINT_M_HEADING		6425  /**/
+#define ERR_BASE_WAYPOINT_M_TOL_POSITION		6436  /**/
+#define ERR_BASE_WAYPOINT_M_TOL_HEADING		6447  /**/
+flag Base_Waypoint_m_IsConstraintValid(const Base_Waypoint_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_M		6459  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_M_POSITION_2		6421  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_M_HEADING_2		6432  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_M_TOL_POSITION_2		6443  /**/
+#define ERR_UPER_ENCODE_BASE_WAYPOINT_M_TOL_HEADING_2		6454  /**/
+#define Base_Waypoint_m_REQUIRED_BYTES_FOR_ENCODING       79
+#define Base_Waypoint_m_REQUIRED_BITS_FOR_ENCODING        626
+
+flag Base_Waypoint_m_Encode(const Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_WAYPOINT_M		6460  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_M_POSITION_2		6422  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_M_HEADING_2		6433  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_M_TOL_POSITION_2		6444  /**/
+#define ERR_UPER_DECODE_BASE_WAYPOINT_M_TOL_HEADING_2		6455  /**/
+flag Base_Waypoint_m_Decode(Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_Waypoint_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_Waypoint;
+
+void Std_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal);
+
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT		301  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM		290  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION		246  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA		239  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA_ELM		228  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_HEADING		257  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_POSITION		268  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_HEADING		279  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT		302  /**/
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_2		297  /**/
+#define Std_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BYTES_FOR_ENCODING       15651
+#define Std_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BITS_FOR_ENCODING        125208
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Encode(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT		303  /**/
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_2		298  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Decode(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Wrench_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+
+} Base_Wrench_m;
+
+void Base_Wrench_m_Initialize(Base_Wrench_m* pVal);
+
+#define ERR_BASE_WRENCH_M		6523  /**/
+#define ERR_BASE_WRENCH_M_FORCE		6483  /**/
+#define ERR_BASE_WRENCH_M_FORCE_DATA		6476  /**/
+#define ERR_BASE_WRENCH_M_FORCE_DATA_ELM		6465  /**/
+#define ERR_BASE_WRENCH_M_TORQUE		6512  /**/
+#define ERR_BASE_WRENCH_M_TORQUE_DATA		6505  /**/
+#define ERR_BASE_WRENCH_M_TORQUE_DATA_ELM		6494  /**/
+flag Base_Wrench_m_IsConstraintValid(const Base_Wrench_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_WRENCH_M		6524  /**/
+#define ERR_UPER_ENCODE_BASE_WRENCH_M_FORCE_2		6490  /**/
+#define ERR_UPER_ENCODE_BASE_WRENCH_M_TORQUE_2		6519  /**/
+#define Base_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       79
+#define Base_Wrench_m_REQUIRED_BITS_FOR_ENCODING        628
+
+flag Base_Wrench_m_Encode(const Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_WRENCH_M		6525  /**/
+#define ERR_UPER_DECODE_BASE_WRENCH_M_FORCE_2		6491  /**/
+#define ERR_UPER_DECODE_BASE_WRENCH_M_TORQUE_2		6520  /**/
+flag Base_Wrench_m_Decode(Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_Wrench_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_Wrench;
+
+void Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal);
+
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH		377  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM		366  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE		326  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA		319  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA_ELM		308  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE		355  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA		348  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA_ELM		337  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH		378  /**/
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_2		373  /**/
+#define Std_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BYTES_FOR_ENCODING       15701
+#define Std_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BITS_FOR_ENCODING        125608
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH		379  /**/
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_2		374  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix3d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[9];
+} Wrappers_Matrix3d_data;
+typedef struct {
+    Wrappers_Matrix3d_data data;
+
+} Wrappers_Matrix3d;
+
+void Wrappers_Matrix3d_data_Initialize(Wrappers_Matrix3d_data* pVal);
+void Wrappers_Matrix3d_Initialize(Wrappers_Matrix3d* pVal);
+
+#define ERR_WRAPPERS_MATRIX3D		5801  /**/
+#define ERR_WRAPPERS_MATRIX3D_DATA		5794  /**/
+#define ERR_WRAPPERS_MATRIX3D_DATA_ELM		5783  /**/
+flag Wrappers_Matrix3d_IsConstraintValid(const Wrappers_Matrix3d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX3D		5802  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX3D_DATA		5795  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX3D_DATA_ELM_2		5790  /**/
+#define Wrappers_Matrix3d_REQUIRED_BYTES_FOR_ENCODING       118
+#define Wrappers_Matrix3d_REQUIRED_BITS_FOR_ENCODING        940
+
+flag Wrappers_Matrix3d_Encode(const Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX3D		5803  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA		5796  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA_ELM_2		5791  /**/
+flag Wrappers_Matrix3d_Decode(Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector4d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[4];
+} Wrappers_Vector4d_data;
+typedef struct {
+    Wrappers_Vector4d_data data;
+
+} Wrappers_Vector4d;
+
+void Wrappers_Vector4d_data_Initialize(Wrappers_Vector4d_data* pVal);
+void Wrappers_Vector4d_Initialize(Wrappers_Vector4d* pVal);
+
+#define ERR_WRAPPERS_VECTOR4D		5826  /**/
+#define ERR_WRAPPERS_VECTOR4D_DATA		5819  /**/
+#define ERR_WRAPPERS_VECTOR4D_DATA_ELM		5808  /**/
+flag Wrappers_Vector4d_IsConstraintValid(const Wrappers_Vector4d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR4D		5827  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR4D_DATA		5820  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR4D_DATA_ELM_2		5815  /**/
+#define Wrappers_Vector4d_REQUIRED_BYTES_FOR_ENCODING       53
+#define Wrappers_Vector4d_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_Vector4d_Encode(const Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR4D		5828  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA		5821  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA_ELM_2		5816  /**/
+flag Wrappers_Vector4d_Decode(Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector4d arr[200];
+} Std_vector_Wrappers_Vector4d;
+
+void Std_vector_Wrappers_Vector4d_Initialize(Std_vector_Wrappers_Vector4d* pVal);
+
+#define ERR_STD_VECTOR_WRAPPERS_VECTOR4D		413  /**/
+#define ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM		402  /**/
+#define ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA		395  /**/
+#define ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA_ELM		384  /**/
+flag Std_vector_Wrappers_Vector4d_IsConstraintValid(const Std_vector_Wrappers_Vector4d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_STD_VECTOR_WRAPPERS_VECTOR4D		414  /**/
+#define ERR_UPER_ENCODE_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_2		409  /**/
+#define Std_vector_Wrappers_Vector4d_REQUIRED_BYTES_FOR_ENCODING       10451
+#define Std_vector_Wrappers_Vector4d_REQUIRED_BITS_FOR_ENCODING        83608
+
+flag Std_vector_Wrappers_Vector4d_Encode(const Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D		415  /**/
+#define ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_2		410  /**/
+flag Std_vector_Wrappers_Vector4d_Decode(Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix4d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[16];
+} Wrappers_Matrix4d_data;
+typedef struct {
+    Wrappers_Matrix4d_data data;
+
+} Wrappers_Matrix4d;
+
+void Wrappers_Matrix4d_data_Initialize(Wrappers_Matrix4d_data* pVal);
+void Wrappers_Matrix4d_Initialize(Wrappers_Matrix4d* pVal);
+
+#define ERR_WRAPPERS_MATRIX4D		5851  /**/
+#define ERR_WRAPPERS_MATRIX4D_DATA		5844  /**/
+#define ERR_WRAPPERS_MATRIX4D_DATA_ELM		5833  /**/
+flag Wrappers_Matrix4d_IsConstraintValid(const Wrappers_Matrix4d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX4D		5852  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX4D_DATA		5845  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX4D_DATA_ELM_2		5840  /**/
+#define Wrappers_Matrix4d_REQUIRED_BYTES_FOR_ENCODING       209
+#define Wrappers_Matrix4d_REQUIRED_BITS_FOR_ENCODING        1668
+
+flag Wrappers_Matrix4d_Encode(const Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX4D		5853  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA		5846  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA_ELM_2		5841  /**/
+flag Wrappers_Matrix4d_Decode(Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector6d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[6];
+} Wrappers_Vector6d_data;
+typedef struct {
+    Wrappers_Vector6d_data data;
+
+} Wrappers_Vector6d;
+
+void Wrappers_Vector6d_data_Initialize(Wrappers_Vector6d_data* pVal);
+void Wrappers_Vector6d_Initialize(Wrappers_Vector6d* pVal);
+
+#define ERR_WRAPPERS_VECTOR6D		5876  /**/
+#define ERR_WRAPPERS_VECTOR6D_DATA		5869  /**/
+#define ERR_WRAPPERS_VECTOR6D_DATA_ELM		5858  /**/
+flag Wrappers_Vector6d_IsConstraintValid(const Wrappers_Vector6d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR6D		5877  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR6D_DATA		5870  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTOR6D_DATA_ELM_2		5865  /**/
+#define Wrappers_Vector6d_REQUIRED_BYTES_FOR_ENCODING       79
+#define Wrappers_Vector6d_REQUIRED_BITS_FOR_ENCODING        627
+
+flag Wrappers_Vector6d_Encode(const Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR6D		5878  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA		5871  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA_ELM_2		5866  /**/
+flag Wrappers_Vector6d_Decode(Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix6d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[36];
+} Wrappers_Matrix6d_data;
+typedef struct {
+    Wrappers_Matrix6d_data data;
+
+} Wrappers_Matrix6d;
+
+void Wrappers_Matrix6d_data_Initialize(Wrappers_Matrix6d_data* pVal);
+void Wrappers_Matrix6d_Initialize(Wrappers_Matrix6d* pVal);
+
+#define ERR_WRAPPERS_MATRIX6D		5901  /**/
+#define ERR_WRAPPERS_MATRIX6D_DATA		5894  /**/
+#define ERR_WRAPPERS_MATRIX6D_DATA_ELM		5883  /**/
+flag Wrappers_Matrix6d_IsConstraintValid(const Wrappers_Matrix6d* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX6D		5902  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX6D_DATA		5895  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIX6D_DATA_ELM_2		5890  /**/
+#define Wrappers_Matrix6d_REQUIRED_BYTES_FOR_ENCODING       469
+#define Wrappers_Matrix6d_REQUIRED_BITS_FOR_ENCODING        3750
+
+flag Wrappers_Matrix6d_Encode(const Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX6D		5903  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA		5896  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA_ELM_2		5891  /**/
+flag Wrappers_Matrix6d_Decode(Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TwistWithCovariance --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d vel;
+    Wrappers_Vector3d rot;
+    Wrappers_Matrix6d cov;
+
+} Base_TwistWithCovariance;
+
+void Base_TwistWithCovariance_Initialize(Base_TwistWithCovariance* pVal);
+
+#define ERR_BASE_TWISTWITHCOVARIANCE		808  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_VEL		739  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA		732  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA_ELM		721  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_ROT		768  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA		761  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA_ELM		750  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_COV		797  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA		790  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA_ELM		779  /**/
+flag Base_TwistWithCovariance_IsConstraintValid(const Base_TwistWithCovariance* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE		809  /**/
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_VEL_2		746  /**/
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_ROT_2		775  /**/
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_COV_2		804  /**/
+#define Base_TwistWithCovariance_REQUIRED_BYTES_FOR_ENCODING       548
+#define Base_TwistWithCovariance_REQUIRED_BITS_FOR_ENCODING        4378
+
+flag Base_TwistWithCovariance_Encode(const Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE		810  /**/
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_VEL_2		747  /**/
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_ROT_2		776  /**/
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_COV_2		805  /**/
+flag Base_TwistWithCovariance_Decode(Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TwistWithCovariance_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d vel;
+    Wrappers_Vector3d rot;
+    Wrappers_Matrix6d cov;
+
+} Base_TwistWithCovariance_m;
+
+void Base_TwistWithCovariance_m_Initialize(Base_TwistWithCovariance_m* pVal);
+
+#define ERR_BASE_TWISTWITHCOVARIANCE_M		6389  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_VEL		6320  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA		6313  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA_ELM		6302  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_ROT		6349  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA		6342  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA_ELM		6331  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_COV		6378  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA		6371  /**/
+#define ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA_ELM		6360  /**/
+flag Base_TwistWithCovariance_m_IsConstraintValid(const Base_TwistWithCovariance_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M		6390  /**/
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M_VEL_2		6327  /**/
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M_ROT_2		6356  /**/
+#define ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M_COV_2		6385  /**/
+#define Base_TwistWithCovariance_m_REQUIRED_BYTES_FOR_ENCODING       548
+#define Base_TwistWithCovariance_m_REQUIRED_BITS_FOR_ENCODING        4378
+
+flag Base_TwistWithCovariance_m_Encode(const Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M		6391  /**/
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M_VEL_2		6328  /**/
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M_ROT_2		6357  /**/
+#define ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M_COV_2		6386  /**/
+flag Base_TwistWithCovariance_m_Decode(Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Quaterniond --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[3];
+} Wrappers_Quaterniond_im;
+typedef struct {
+    Wrappers_Quaterniond_im im;
+    T_Double re;
+
+} Wrappers_Quaterniond;
+
+void Wrappers_Quaterniond_im_Initialize(Wrappers_Quaterniond_im* pVal);
+void Wrappers_Quaterniond_Initialize(Wrappers_Quaterniond* pVal);
+
+#define ERR_WRAPPERS_QUATERNIOND		5984  /**/
+#define ERR_WRAPPERS_QUATERNIOND_IM		5966  /**/
+#define ERR_WRAPPERS_QUATERNIOND_IM_ELM		5955  /**/
+#define ERR_WRAPPERS_QUATERNIOND_RE		5973  /**/
+flag Wrappers_Quaterniond_IsConstraintValid(const Wrappers_Quaterniond* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND		5985  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND_IM		5967  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND_IM_ELM_2		5962  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND_RE_2		5980  /**/
+#define Wrappers_Quaterniond_REQUIRED_BYTES_FOR_ENCODING       53
+#define Wrappers_Quaterniond_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_Quaterniond_Encode(const Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_QUATERNIOND		5986  /**/
+#define ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM		5968  /**/
+#define ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM_ELM_2		5963  /**/
+#define ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_RE_2		5981  /**/
+flag Wrappers_Quaterniond_Decode(Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    Wrappers_Quaterniond orientation;
+
+} Base_Pose;
+
+void Base_Pose_Initialize(Base_Pose* pVal);
+
+#define ERR_BASE_POSE		609  /**/
+#define ERR_BASE_POSE_POSITION		558  /**/
+#define ERR_BASE_POSE_POSITION_DATA		551  /**/
+#define ERR_BASE_POSE_POSITION_DATA_ELM		540  /**/
+#define ERR_BASE_POSE_ORIENTATION		598  /**/
+#define ERR_BASE_POSE_ORIENTATION_IM		580  /**/
+#define ERR_BASE_POSE_ORIENTATION_IM_ELM		569  /**/
+#define ERR_BASE_POSE_ORIENTATION_RE		587  /**/
+flag Base_Pose_IsConstraintValid(const Base_Pose* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_POSE		610  /**/
+#define ERR_UPER_ENCODE_BASE_POSE_POSITION_2		565  /**/
+#define ERR_UPER_ENCODE_BASE_POSE_ORIENTATION_2		605  /**/
+#define Base_Pose_REQUIRED_BYTES_FOR_ENCODING       92
+#define Base_Pose_REQUIRED_BITS_FOR_ENCODING        732
+
+flag Base_Pose_Encode(const Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_POSE		611  /**/
+#define ERR_UPER_DECODE_BASE_POSE_POSITION_2		566  /**/
+#define ERR_UPER_DECODE_BASE_POSE_ORIENTATION_2		606  /**/
+flag Base_Pose_Decode(Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TransformWithCovariance --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d translation;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix6d cov;
+
+} Base_TransformWithCovariance;
+
+void Base_TransformWithCovariance_Initialize(Base_TransformWithCovariance* pVal);
+
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE		714  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION		634  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA		627  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA_ELM		616  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION		674  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM		656  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM_ELM		645  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_RE		663  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_COV		703  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA		696  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA_ELM		685  /**/
+flag Base_TransformWithCovariance_IsConstraintValid(const Base_TransformWithCovariance* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE		715  /**/
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_2		641  /**/
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_2		681  /**/
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_COV_2		710  /**/
+#define Base_TransformWithCovariance_REQUIRED_BYTES_FOR_ENCODING       561
+#define Base_TransformWithCovariance_REQUIRED_BITS_FOR_ENCODING        4482
+
+flag Base_TransformWithCovariance_Encode(const Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE		716  /**/
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_2		642  /**/
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_2		682  /**/
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_COV_2		711  /**/
+flag Base_TransformWithCovariance_Decode(Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    Wrappers_Quaterniond orientation;
+
+} Base_Pose_m;
+
+void Base_Pose_m_Initialize(Base_Pose_m* pVal);
+
+#define ERR_BASE_POSE_M		6190  /**/
+#define ERR_BASE_POSE_M_POSITION		6139  /**/
+#define ERR_BASE_POSE_M_POSITION_DATA		6132  /**/
+#define ERR_BASE_POSE_M_POSITION_DATA_ELM		6121  /**/
+#define ERR_BASE_POSE_M_ORIENTATION		6179  /**/
+#define ERR_BASE_POSE_M_ORIENTATION_IM		6161  /**/
+#define ERR_BASE_POSE_M_ORIENTATION_IM_ELM		6150  /**/
+#define ERR_BASE_POSE_M_ORIENTATION_RE		6168  /**/
+flag Base_Pose_m_IsConstraintValid(const Base_Pose_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_POSE_M		6191  /**/
+#define ERR_UPER_ENCODE_BASE_POSE_M_POSITION_2		6146  /**/
+#define ERR_UPER_ENCODE_BASE_POSE_M_ORIENTATION_2		6186  /**/
+#define Base_Pose_m_REQUIRED_BYTES_FOR_ENCODING       92
+#define Base_Pose_m_REQUIRED_BITS_FOR_ENCODING        732
+
+flag Base_Pose_m_Encode(const Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_POSE_M		6192  /**/
+#define ERR_UPER_DECODE_BASE_POSE_M_POSITION_2		6147  /**/
+#define ERR_UPER_DECODE_BASE_POSE_M_ORIENTATION_2		6187  /**/
+flag Base_Pose_m_Decode(Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TransformWithCovariance_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d translation;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix6d cov;
+
+} Base_TransformWithCovariance_m;
+
+void Base_TransformWithCovariance_m_Initialize(Base_TransformWithCovariance_m* pVal);
+
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M		6295  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION		6215  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA		6208  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA_ELM		6197  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION		6255  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM		6237  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM_ELM		6226  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_RE		6244  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV		6284  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA		6277  /**/
+#define ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA_ELM		6266  /**/
+flag Base_TransformWithCovariance_m_IsConstraintValid(const Base_TransformWithCovariance_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M		6296  /**/
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_2		6222  /**/
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_2		6262  /**/
+#define ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M_COV_2		6291  /**/
+#define Base_TransformWithCovariance_m_REQUIRED_BYTES_FOR_ENCODING       561
+#define Base_TransformWithCovariance_m_REQUIRED_BITS_FOR_ENCODING        4482
+
+flag Base_TransformWithCovariance_m_Encode(const Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M		6297  /**/
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_2		6223  /**/
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_2		6263  /**/
+#define ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_COV_2		6292  /**/
+flag Base_TransformWithCovariance_m_Decode(Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_VectorXd --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_VectorXd_data;
+typedef struct {
+    Wrappers_VectorXd_data data;
+
+} Wrappers_VectorXd;
+
+void Wrappers_VectorXd_data_Initialize(Wrappers_VectorXd_data* pVal);
+void Wrappers_VectorXd_Initialize(Wrappers_VectorXd* pVal);
+
+#define ERR_WRAPPERS_VECTORXD		6009  /**/
+#define ERR_WRAPPERS_VECTORXD_DATA		6002  /**/
+#define ERR_WRAPPERS_VECTORXD_DATA_ELM		5991  /**/
+flag Wrappers_VectorXd_IsConstraintValid(const Wrappers_VectorXd* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_VECTORXD		6010  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTORXD_DATA		6003  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_VECTORXD_DATA_ELM_2		5998  /**/
+#define Wrappers_VectorXd_REQUIRED_BYTES_FOR_ENCODING       2601
+#define Wrappers_VectorXd_REQUIRED_BITS_FOR_ENCODING        20808
+
+flag Wrappers_VectorXd_Encode(const Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_VECTORXD		6011  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA		6004  /**/
+#define ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA_ELM_2		5999  /**/
+flag Wrappers_VectorXd_Decode(Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointState --------------------------------------------*/
+typedef struct {
+    T_Double position;
+    T_Float speed;
+    T_Float effort;
+    T_Float raw;
+    T_Float acceleration;
+
+} Base_JointState;
+
+void Base_JointState_Initialize(Base_JointState* pVal);
+
+#define ERR_BASE_JOINTSTATE		953  /**/
+#define ERR_BASE_JOINTSTATE_POSITION		898  /**/
+#define ERR_BASE_JOINTSTATE_SPEED		909  /**/
+#define ERR_BASE_JOINTSTATE_EFFORT		920  /**/
+#define ERR_BASE_JOINTSTATE_RAW		931  /**/
+#define ERR_BASE_JOINTSTATE_ACCELERATION		942  /**/
+flag Base_JointState_IsConstraintValid(const Base_JointState* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTSTATE		954  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTATE_POSITION_2		905  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTATE_SPEED_2		916  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTATE_EFFORT_2		927  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTATE_RAW_2		938  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTATE_ACCELERATION_2		949  /**/
+#define Base_JointState_REQUIRED_BYTES_FOR_ENCODING       65
+#define Base_JointState_REQUIRED_BITS_FOR_ENCODING        520
+
+flag Base_JointState_Encode(const Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTSTATE		955  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTATE_POSITION_2		906  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTATE_SPEED_2		917  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTATE_EFFORT_2		928  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTATE_RAW_2		939  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTATE_ACCELERATION_2		950  /**/
+flag Base_JointState_Decode(Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointState arr[200];
+} Base_JointTrajectory;
+
+void Base_JointTrajectory_Initialize(Base_JointTrajectory* pVal);
+
+#define ERR_BASE_JOINTTRAJECTORY		152  /**/
+#define ERR_BASE_JOINTTRAJECTORY_ELM		141  /**/
+#define ERR_BASE_JOINTTRAJECTORY_ELM_POSITION		86  /**/
+#define ERR_BASE_JOINTTRAJECTORY_ELM_SPEED		97  /**/
+#define ERR_BASE_JOINTTRAJECTORY_ELM_EFFORT		108  /**/
+#define ERR_BASE_JOINTTRAJECTORY_ELM_RAW		119  /**/
+#define ERR_BASE_JOINTTRAJECTORY_ELM_ACCELERATION		130  /**/
+flag Base_JointTrajectory_IsConstraintValid(const Base_JointTrajectory* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTTRAJECTORY		153  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRAJECTORY_ELM_2		148  /**/
+#define Base_JointTrajectory_REQUIRED_BYTES_FOR_ENCODING       13001
+#define Base_JointTrajectory_REQUIRED_BITS_FOR_ENCODING        104008
+
+flag Base_JointTrajectory_Encode(const Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTTRAJECTORY		154  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRAJECTORY_ELM_2		149  /**/
+flag Base_JointTrajectory_Decode(Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointLimitRange --------------------------------------------*/
+typedef struct {
+    Base_JointState min;
+    Base_JointState max;
+
+} Base_JointLimitRange;
+
+void Base_JointLimitRange_Initialize(Base_JointLimitRange* pVal);
+
+#define ERR_BASE_JOINTLIMITRANGE		1400  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MIN		1323  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MIN_POSITION		1268  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MIN_SPEED		1279  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MIN_EFFORT		1290  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MIN_RAW		1301  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MIN_ACCELERATION		1312  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MAX		1389  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MAX_POSITION		1334  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MAX_SPEED		1345  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MAX_EFFORT		1356  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MAX_RAW		1367  /**/
+#define ERR_BASE_JOINTLIMITRANGE_MAX_ACCELERATION		1378  /**/
+flag Base_JointLimitRange_IsConstraintValid(const Base_JointLimitRange* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITRANGE		1401  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITRANGE_MIN_2		1330  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITRANGE_MAX_2		1396  /**/
+#define Base_JointLimitRange_REQUIRED_BYTES_FOR_ENCODING       130
+#define Base_JointLimitRange_REQUIRED_BITS_FOR_ENCODING        1040
+
+flag Base_JointLimitRange_Encode(const Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTLIMITRANGE		1402  /**/
+#define ERR_UPER_DECODE_BASE_JOINTLIMITRANGE_MIN_2		1331  /**/
+#define ERR_UPER_DECODE_BASE_JOINTLIMITRANGE_MAX_2		1397  /**/
+flag Base_JointLimitRange_Decode(Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pressure --------------------------------------------*/
+typedef struct {
+    T_Float pascal;
+
+} Base_Pressure;
+
+void Base_Pressure_Initialize(Base_Pressure* pVal);
+
+#define ERR_BASE_PRESSURE		1047  /**/
+#define ERR_BASE_PRESSURE_PASCAL		1036  /**/
+flag Base_Pressure_IsConstraintValid(const Base_Pressure* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_PRESSURE		1048  /**/
+#define ERR_UPER_ENCODE_BASE_PRESSURE_PASCAL_2		1043  /**/
+#define Base_Pressure_REQUIRED_BYTES_FOR_ENCODING       13
+#define Base_Pressure_REQUIRED_BITS_FOR_ENCODING        104
+
+flag Base_Pressure_Encode(const Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_PRESSURE		1049  /**/
+#define ERR_UPER_DECODE_BASE_PRESSURE_PASCAL_2		1044  /**/
+flag Base_Pressure_Decode(Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Time --------------------------------------------*/
+typedef struct {
+    T_Int64 microseconds;
+
+} Base_Time;
+
+void Base_Time_Initialize(Base_Time* pVal);
+
+#define ERR_BASE_TIME		1083  /**/
+#define ERR_BASE_TIME_MICROSECONDS		1072  /**/
+flag Base_Time_IsConstraintValid(const Base_Time* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TIME		1084  /**/
+#define ERR_UPER_ENCODE_BASE_TIME_MICROSECONDS_2		1079  /**/
+#define Base_Time_REQUIRED_BYTES_FOR_ENCODING       8
+#define Base_Time_REQUIRED_BITS_FOR_ENCODING        64
+
+flag Base_Time_Encode(const Base_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TIME		1085  /**/
+#define ERR_UPER_DECODE_BASE_TIME_MICROSECONDS_2		1080  /**/
+flag Base_Time_Decode(Base_Time* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TimeStamped_Base_commands_Motion2D --------------------------------------------*/
+typedef struct {
+    T_Double translation;
+    T_Double rotation;
+    Base_Angle heading;
+    Base_Time time;
+
+} Base_TimeStamped_Base_commands_Motion2D;
+
+void Base_TimeStamped_Base_commands_Motion2D_Initialize(Base_TimeStamped_Base_commands_Motion2D* pVal);
+
+#define ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D		1473  /**/
+#define ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION		1407  /**/
+#define ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION		1418  /**/
+#define ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING		1440  /**/
+#define ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_RAD		1429  /**/
+#define ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME		1462  /**/
+#define ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_MICROSECONDS		1451  /**/
+flag Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const Base_TimeStamped_Base_commands_Motion2D* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D		1474  /**/
+#define ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1414  /**/
+#define ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION_2		1425  /**/
+#define ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_2		1447  /**/
+#define ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_2		1469  /**/
+#define Base_TimeStamped_Base_commands_Motion2D_REQUIRED_BYTES_FOR_ENCODING       47
+#define Base_TimeStamped_Base_commands_Motion2D_REQUIRED_BITS_FOR_ENCODING        376
+
+flag Base_TimeStamped_Base_commands_Motion2D_Encode(const Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D		1475  /**/
+#define ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1415  /**/
+#define ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION_2		1426  /**/
+#define ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_2		1448  /**/
+#define ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_2		1470  /**/
+flag Base_TimeStamped_Base_commands_Motion2D_Decode(Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_LinearAngular6DCommand --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d linear;
+    Wrappers_Vector3d angular;
+
+} Base_LinearAngular6DCommand;
+
+void Base_LinearAngular6DCommand_Initialize(Base_LinearAngular6DCommand* pVal);
+
+#define ERR_BASE_LINEARANGULAR6DCOMMAND		1560  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_TIME		1491  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_TIME_MICROSECONDS		1480  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR		1520  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA		1513  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA_ELM		1502  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR		1549  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA		1542  /**/
+#define ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA_ELM		1531  /**/
+flag Base_LinearAngular6DCommand_IsConstraintValid(const Base_LinearAngular6DCommand* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND		1561  /**/
+#define ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND_TIME_2		1498  /**/
+#define ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND_LINEAR_2		1527  /**/
+#define ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_2		1556  /**/
+#define Base_LinearAngular6DCommand_REQUIRED_BYTES_FOR_ENCODING       87
+#define Base_LinearAngular6DCommand_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_LinearAngular6DCommand_Encode(const Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND		1562  /**/
+#define ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND_TIME_2		1499  /**/
+#define ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND_LINEAR_2		1528  /**/
+#define ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_2		1557  /**/
+flag Base_LinearAngular6DCommand_Decode(Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_BodyState --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Base_TransformWithCovariance pose;
+    Base_TwistWithCovariance velocity;
+
+} Base_samples_BodyState;
+
+void Base_samples_BodyState_Initialize(Base_samples_BodyState* pVal);
+
+#define ERR_BASE_SAMPLES_BODYSTATE		1920  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_TIME		1702  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_TIME_MICROSECONDS		1691  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE		1811  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION		1731  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA		1724  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA_ELM		1713  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION		1771  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM		1753  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM_ELM		1742  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_RE		1760  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_COV		1800  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA		1793  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA_ELM		1782  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY		1909  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL		1840  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA		1833  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA_ELM		1822  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT		1869  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA		1862  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA_ELM		1851  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV		1898  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA		1891  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA_ELM		1880  /**/
+flag Base_samples_BodyState_IsConstraintValid(const Base_samples_BodyState* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE		1921  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_TIME_2		1709  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_POSE_2		1818  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_VELOCITY_2		1916  /**/
+#define Base_samples_BodyState_REQUIRED_BYTES_FOR_ENCODING       1116
+#define Base_samples_BodyState_REQUIRED_BITS_FOR_ENCODING        8924
+
+flag Base_samples_BodyState_Encode(const Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE		1922  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_TIME_2		1710  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_POSE_2		1819  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_2		1917  /**/
+flag Base_samples_BodyState_Decode(Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_IMUSensors --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acc;
+    Wrappers_Vector3d gyro;
+    Wrappers_Vector3d mag;
+
+} Base_samples_IMUSensors;
+
+void Base_samples_IMUSensors_Initialize(Base_samples_IMUSensors* pVal);
+
+#define ERR_BASE_SAMPLES_IMUSENSORS		2036  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_TIME		1938  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_TIME_MICROSECONDS		1927  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_ACC		1967  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA		1960  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA_ELM		1949  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_GYRO		1996  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA		1989  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA_ELM		1978  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_MAG		2025  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA		2018  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA_ELM		2007  /**/
+flag Base_samples_IMUSensors_IsConstraintValid(const Base_samples_IMUSensors* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS		2037  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_TIME_2		1945  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_ACC_2		1974  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_GYRO_2		2003  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_MAG_2		2032  /**/
+#define Base_samples_IMUSensors_REQUIRED_BYTES_FOR_ENCODING       126
+#define Base_samples_IMUSensors_REQUIRED_BITS_FOR_ENCODING        1006
+
+flag Base_samples_IMUSensors_Encode(const Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS		2038  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_TIME_2		1946  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_ACC_2		1975  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_GYRO_2		2004  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_MAG_2		2033  /**/
+flag Base_samples_IMUSensors_Decode(Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Motion2D --------------------------------------------*/
+typedef struct {
+    T_Double translation;
+    T_Double rotation;
+    Base_Angle heading;
+    Base_Time time;
+
+} Base_samples_Motion2D;
+
+void Base_samples_Motion2D_Initialize(Base_samples_Motion2D* pVal);
+
+#define ERR_BASE_SAMPLES_MOTION2D		2109  /**/
+#define ERR_BASE_SAMPLES_MOTION2D_TRANSLATION		2043  /**/
+#define ERR_BASE_SAMPLES_MOTION2D_ROTATION		2054  /**/
+#define ERR_BASE_SAMPLES_MOTION2D_HEADING		2076  /**/
+#define ERR_BASE_SAMPLES_MOTION2D_HEADING_RAD		2065  /**/
+#define ERR_BASE_SAMPLES_MOTION2D_TIME		2098  /**/
+#define ERR_BASE_SAMPLES_MOTION2D_TIME_MICROSECONDS		2087  /**/
+flag Base_samples_Motion2D_IsConstraintValid(const Base_samples_Motion2D* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D		2110  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_TRANSLATION_2		2050  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_ROTATION_2		2061  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_HEADING_2		2083  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_TIME_2		2105  /**/
+#define Base_samples_Motion2D_REQUIRED_BYTES_FOR_ENCODING       47
+#define Base_samples_Motion2D_REQUIRED_BITS_FOR_ENCODING        376
+
+flag Base_samples_Motion2D_Encode(const Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D		2111  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_TRANSLATION_2		2051  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_ROTATION_2		2062  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_HEADING_2		2084  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_TIME_2		2106  /**/
+flag Base_samples_Motion2D_Decode(Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Pressure --------------------------------------------*/
+typedef struct {
+    T_Float pascal;
+    Base_Time time;
+
+} Base_samples_Pressure;
+
+void Base_samples_Pressure_Initialize(Base_samples_Pressure* pVal);
+
+#define ERR_BASE_SAMPLES_PRESSURE		2149  /**/
+#define ERR_BASE_SAMPLES_PRESSURE_PASCAL		2116  /**/
+#define ERR_BASE_SAMPLES_PRESSURE_TIME		2138  /**/
+#define ERR_BASE_SAMPLES_PRESSURE_TIME_MICROSECONDS		2127  /**/
+flag Base_samples_Pressure_IsConstraintValid(const Base_samples_Pressure* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_PRESSURE		2150  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_PRESSURE_PASCAL_2		2123  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_PRESSURE_TIME_2		2145  /**/
+#define Base_samples_Pressure_REQUIRED_BYTES_FOR_ENCODING       21
+#define Base_samples_Pressure_REQUIRED_BITS_FOR_ENCODING        168
+
+flag Base_samples_Pressure_Encode(const Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_PRESSURE		2151  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_PRESSURE_PASCAL_2		2124  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_PRESSURE_TIME_2		2146  /**/
+flag Base_samples_Pressure_Decode(Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyAcceleration --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acceleration;
+    Wrappers_Matrix3d cov_acceleration;
+    Wrappers_Vector3d angular_acceleration;
+    Wrappers_Matrix3d cov_angular_acceleration;
+
+} Base_samples_RigidBodyAcceleration;
+
+void Base_samples_RigidBodyAcceleration_Initialize(Base_samples_RigidBodyAcceleration* pVal);
+
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION		2294  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME		2167  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_MICROSECONDS		2156  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION		2196  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA		2189  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA_ELM		2178  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION		2225  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA		2218  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA_ELM		2207  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION		2254  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA		2247  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA_ELM		2236  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION		2283  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA		2276  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA_ELM		2265  /**/
+flag Base_samples_RigidBodyAcceleration_IsConstraintValid(const Base_samples_RigidBodyAcceleration* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION		2295  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_2		2174  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_2		2203  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_2		2232  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_2		2261  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_2		2290  /**/
+#define Base_samples_RigidBodyAcceleration_REQUIRED_BYTES_FOR_ENCODING       322
+#define Base_samples_RigidBodyAcceleration_REQUIRED_BITS_FOR_ENCODING        2572
+
+flag Base_samples_RigidBodyAcceleration_Encode(const Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION		2296  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_2		2175  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_2		2204  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_2		2233  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_2		2262  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_2		2291  /**/
+flag Base_samples_RigidBodyAcceleration_Decode(Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrench --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+    Base_Time time;
+
+} Base_samples_Wrench;
+
+void Base_samples_Wrench_Initialize(Base_samples_Wrench* pVal);
+
+#define ERR_BASE_SAMPLES_WRENCH		2381  /**/
+#define ERR_BASE_SAMPLES_WRENCH_FORCE		2319  /**/
+#define ERR_BASE_SAMPLES_WRENCH_FORCE_DATA		2312  /**/
+#define ERR_BASE_SAMPLES_WRENCH_FORCE_DATA_ELM		2301  /**/
+#define ERR_BASE_SAMPLES_WRENCH_TORQUE		2348  /**/
+#define ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA		2341  /**/
+#define ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA_ELM		2330  /**/
+#define ERR_BASE_SAMPLES_WRENCH_TIME		2370  /**/
+#define ERR_BASE_SAMPLES_WRENCH_TIME_MICROSECONDS		2359  /**/
+flag Base_samples_Wrench_IsConstraintValid(const Base_samples_Wrench* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH		2382  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_FORCE_2		2326  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_TORQUE_2		2355  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_TIME_2		2377  /**/
+#define Base_samples_Wrench_REQUIRED_BYTES_FOR_ENCODING       87
+#define Base_samples_Wrench_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_samples_Wrench_Encode(const Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH		2383  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_FORCE_2		2327  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_TORQUE_2		2356  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_TIME_2		2378  /**/
+flag Base_samples_Wrench_Decode(Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Pointcloud --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector3d arr[200];
+} Base_samples_Pointcloud_points;
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector4d arr[200];
+} Base_samples_Pointcloud_colors;
+typedef struct {
+    Base_Time time;
+    Base_samples_Pointcloud_points points;
+    Base_samples_Pointcloud_colors colors;
+
+} Base_samples_Pointcloud;
+
+void Base_samples_Pointcloud_points_Initialize(Base_samples_Pointcloud_points* pVal);
+void Base_samples_Pointcloud_colors_Initialize(Base_samples_Pointcloud_colors* pVal);
+void Base_samples_Pointcloud_Initialize(Base_samples_Pointcloud* pVal);
+
+#define ERR_BASE_SAMPLES_POINTCLOUD		3900  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_TIME		3817  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_TIME_MICROSECONDS		3806  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_POINTS		3857  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM		3846  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA		3839  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA_ELM		3828  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_COLORS		3893  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM		3882  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA		3875  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA_ELM		3864  /**/
+flag Base_samples_Pointcloud_IsConstraintValid(const Base_samples_Pointcloud* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD		3901  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_TIME_2		3824  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_POINTS		3858  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_2		3853  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_COLORS		3894  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_2		3889  /**/
+#define Base_samples_Pointcloud_REQUIRED_BYTES_FOR_ENCODING       18310
+#define Base_samples_Pointcloud_REQUIRED_BITS_FOR_ENCODING        146480
+
+flag Base_samples_Pointcloud_Encode(const Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD		3902  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_TIME_2		3825  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS		3859  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_2		3854  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS		3895  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_2		3890  /**/
+flag Base_samples_Pointcloud_Decode(Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_SonarBeam --------------------------------------------*/
+typedef struct {
+    int nCount;
+
+    byte arr[200];
+} Base_samples_SonarBeam_beam;
+
+typedef struct {
+    Base_Time time;
+    Base_Angle bearing;
+    T_Double sampling_interval;
+    T_Float speed_of_sound;
+    T_Float beamwidth_horizontal;
+    T_Float beamwidth_vertical;
+    Base_samples_SonarBeam_beam beam;
+
+} Base_samples_SonarBeam;
+
+void Base_samples_SonarBeam_beam_Initialize(Base_samples_SonarBeam_beam* pVal);
+void Base_samples_SonarBeam_Initialize(Base_samples_SonarBeam* pVal);
+
+#define ERR_BASE_SAMPLES_SONARBEAM		4500  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_TIME		4416  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_TIME_MICROSECONDS		4405  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_BEARING		4438  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_BEARING_RAD		4427  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL		4449  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND		4460  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL		4471  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL		4482  /**/
+#define ERR_BASE_SAMPLES_SONARBEAM_BEAM		4493  /**/
+flag Base_samples_SonarBeam_IsConstraintValid(const Base_samples_SonarBeam* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM		4501  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_TIME_2		4423  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEARING_2		4445  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL_2		4456  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND_2		4467  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL_2		4478  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL_2		4489  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEAM		4494  /**/
+#define Base_samples_SonarBeam_REQUIRED_BYTES_FOR_ENCODING       274
+#define Base_samples_SonarBeam_REQUIRED_BITS_FOR_ENCODING        2192
+
+flag Base_samples_SonarBeam_Encode(const Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM		4502  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_TIME_2		4424  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEARING_2		4446  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL_2		4457  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND_2		4468  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL_2		4479  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL_2		4490  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM		4495  /**/
+flag Base_samples_SonarBeam_Decode(Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_LinearAngular6DCommand_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d linear;
+    Wrappers_Vector3d angular;
+
+} Base_commands_LinearAngular6DCommand_m;
+
+void Base_commands_LinearAngular6DCommand_m_Initialize(Base_commands_LinearAngular6DCommand_m* pVal);
+
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M		6610  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME		6541  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_MICROSECONDS		6530  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR		6570  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA		6563  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA_ELM		6552  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR		6599  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA		6592  /**/
+#define ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA_ELM		6581  /**/
+flag Base_commands_LinearAngular6DCommand_m_IsConstraintValid(const Base_commands_LinearAngular6DCommand_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M		6611  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_2		6548  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_2		6577  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_2		6606  /**/
+#define Base_commands_LinearAngular6DCommand_m_REQUIRED_BYTES_FOR_ENCODING       87
+#define Base_commands_LinearAngular6DCommand_m_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_commands_LinearAngular6DCommand_m_Encode(const Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M		6612  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_2		6549  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_2		6578  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_2		6607  /**/
+flag Base_commands_LinearAngular6DCommand_m_Decode(Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_BodyState_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Base_TransformWithCovariance_m pose;
+    Base_TwistWithCovariance_m velocity;
+
+} Base_samples_BodyState_m;
+
+void Base_samples_BodyState_m_Initialize(Base_samples_BodyState_m* pVal);
+
+#define ERR_BASE_SAMPLES_BODYSTATE_M		6846  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_TIME		6628  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_TIME_MICROSECONDS		6617  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE		6737  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION		6657  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA		6650  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA_ELM		6639  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION		6697  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM		6679  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM_ELM		6668  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_RE		6686  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV		6726  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA		6719  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA_ELM		6708  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY		6835  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL		6766  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA		6759  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA_ELM		6748  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT		6795  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA		6788  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA_ELM		6777  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV		6824  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA		6817  /**/
+#define ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA_ELM		6806  /**/
+flag Base_samples_BodyState_m_IsConstraintValid(const Base_samples_BodyState_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M		6847  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M_TIME_2		6635  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M_POSE_2		6744  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_2		6842  /**/
+#define Base_samples_BodyState_m_REQUIRED_BYTES_FOR_ENCODING       1116
+#define Base_samples_BodyState_m_REQUIRED_BITS_FOR_ENCODING        8924
+
+flag Base_samples_BodyState_m_Encode(const Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M		6848  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M_TIME_2		6636  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_2		6745  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_2		6843  /**/
+flag Base_samples_BodyState_m_Decode(Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_IMUSensors_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acc;
+    Wrappers_Vector3d gyro;
+    Wrappers_Vector3d mag;
+
+} Base_samples_IMUSensors_m;
+
+void Base_samples_IMUSensors_m_Initialize(Base_samples_IMUSensors_m* pVal);
+
+#define ERR_BASE_SAMPLES_IMUSENSORS_M		6962  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_TIME		6864  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_TIME_MICROSECONDS		6853  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_ACC		6893  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA		6886  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA_ELM		6875  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO		6922  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA		6915  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA_ELM		6904  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_MAG		6951  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA		6944  /**/
+#define ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA_ELM		6933  /**/
+flag Base_samples_IMUSensors_m_IsConstraintValid(const Base_samples_IMUSensors_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M		6963  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_TIME_2		6871  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_ACC_2		6900  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_GYRO_2		6929  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_MAG_2		6958  /**/
+#define Base_samples_IMUSensors_m_REQUIRED_BYTES_FOR_ENCODING       126
+#define Base_samples_IMUSensors_m_REQUIRED_BITS_FOR_ENCODING        1006
+
+flag Base_samples_IMUSensors_m_Encode(const Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M		6964  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_TIME_2		6872  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_ACC_2		6901  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_GYRO_2		6930  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_MAG_2		6959  /**/
+flag Base_samples_IMUSensors_m_Decode(Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyAcceleration_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acceleration;
+    Wrappers_Matrix3d cov_acceleration;
+    Wrappers_Vector3d angular_acceleration;
+    Wrappers_Matrix3d cov_angular_acceleration;
+
+} Base_samples_RigidBodyAcceleration_m;
+
+void Base_samples_RigidBodyAcceleration_m_Initialize(Base_samples_RigidBodyAcceleration_m* pVal);
+
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M		7107  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME		6980  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_MICROSECONDS		6969  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION		7009  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA		7002  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA_ELM		6991  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION		7038  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA		7031  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA_ELM		7020  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION		7067  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA		7060  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA_ELM		7049  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION		7096  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA		7089  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA_ELM		7078  /**/
+flag Base_samples_RigidBodyAcceleration_m_IsConstraintValid(const Base_samples_RigidBodyAcceleration_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M		7108  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_2		6987  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_2		7016  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_2		7045  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_2		7074  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_2		7103  /**/
+#define Base_samples_RigidBodyAcceleration_m_REQUIRED_BYTES_FOR_ENCODING       322
+#define Base_samples_RigidBodyAcceleration_m_REQUIRED_BITS_FOR_ENCODING        2572
+
+flag Base_samples_RigidBodyAcceleration_m_Encode(const Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M		7109  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_2		6988  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_2		7017  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_2		7046  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_2		7075  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_2		7104  /**/
+flag Base_samples_RigidBodyAcceleration_m_Decode(Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrench_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+    Base_Time time;
+
+} Base_samples_Wrench_m;
+
+void Base_samples_Wrench_m_Initialize(Base_samples_Wrench_m* pVal);
+
+#define ERR_BASE_SAMPLES_WRENCH_M		7488  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_FORCE		7426  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA		7419  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA_ELM		7408  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_TORQUE		7455  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA		7448  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA_ELM		7437  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_TIME		7477  /**/
+#define ERR_BASE_SAMPLES_WRENCH_M_TIME_MICROSECONDS		7466  /**/
+flag Base_samples_Wrench_m_IsConstraintValid(const Base_samples_Wrench_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M		7489  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M_FORCE_2		7433  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M_TORQUE_2		7462  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M_TIME_2		7484  /**/
+#define Base_samples_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       87
+#define Base_samples_Wrench_m_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_samples_Wrench_m_Encode(const Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M		7490  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M_FORCE_2		7434  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M_TORQUE_2		7463  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M_TIME_2		7485  /**/
+flag Base_samples_Wrench_m_Decode(Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Pointcloud_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector3d arr[200];
+} Base_samples_Pointcloud_m_points;
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector4d arr[200];
+} Base_samples_Pointcloud_m_colors;
+typedef struct {
+    Base_Time time;
+    Base_samples_Pointcloud_m_points points;
+    Base_samples_Pointcloud_m_colors colors;
+
+} Base_samples_Pointcloud_m;
+
+void Base_samples_Pointcloud_m_points_Initialize(Base_samples_Pointcloud_m_points* pVal);
+void Base_samples_Pointcloud_m_colors_Initialize(Base_samples_Pointcloud_m_colors* pVal);
+void Base_samples_Pointcloud_m_Initialize(Base_samples_Pointcloud_m* pVal);
+
+#define ERR_BASE_SAMPLES_POINTCLOUD_M		7890  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_TIME		7807  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_TIME_MICROSECONDS		7796  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS		7847  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM		7836  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA		7829  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA_ELM		7818  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS		7883  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM		7872  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA		7865  /**/
+#define ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA_ELM		7854  /**/
+flag Base_samples_Pointcloud_m_IsConstraintValid(const Base_samples_Pointcloud_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M		7891  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_TIME_2		7814  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_POINTS		7848  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_2		7843  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_COLORS		7884  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_2		7879  /**/
+#define Base_samples_Pointcloud_m_REQUIRED_BYTES_FOR_ENCODING       18310
+#define Base_samples_Pointcloud_m_REQUIRED_BITS_FOR_ENCODING        146480
+
+flag Base_samples_Pointcloud_m_Encode(const Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M		7892  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_TIME_2		7815  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS		7849  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_2		7844  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS		7885  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_2		7880  /**/
+flag Base_samples_Pointcloud_m_Decode(Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_frame_size_t --------------------------------------------*/
+typedef struct {
+    T_UInt16 width;
+    T_UInt16 height;
+
+} Base_samples_frame_frame_size_t;
+
+void Base_samples_frame_frame_size_t_Initialize(Base_samples_frame_frame_size_t* pVal);
+
+#define ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T		2410  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH		2388  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT		2399  /**/
+flag Base_samples_frame_frame_size_t_IsConstraintValid(const Base_samples_frame_frame_size_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T		2411  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH_2		2395  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT_2		2406  /**/
+#define Base_samples_frame_frame_size_t_REQUIRED_BYTES_FOR_ENCODING       4
+#define Base_samples_frame_frame_size_t_REQUIRED_BITS_FOR_ENCODING        32
+
+flag Base_samples_frame_frame_size_t_Encode(const Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T		2412  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH_2		2396  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT_2		2407  /**/
+flag Base_samples_frame_frame_size_t_Decode(Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_DistanceImage --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_DistanceImage_data;
+typedef struct {
+    Base_Time time;
+    T_UInt16 width;
+    T_UInt16 height;
+    T_Float scale_x;
+    T_Float scale_y;
+    T_Float center_x;
+    T_Float center_y;
+    Base_samples_DistanceImage_data data;
+
+} Base_samples_DistanceImage;
+
+void Base_samples_DistanceImage_data_Initialize(Base_samples_DistanceImage_data* pVal);
+void Base_samples_DistanceImage_Initialize(Base_samples_DistanceImage* pVal);
+
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE		3555  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_TIME		3460  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_TIME_MICROSECONDS		3449  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_WIDTH		3471  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT		3482  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X		3493  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y		3504  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X		3515  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y		3526  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA		3548  /**/
+#define ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM		3537  /**/
+flag Base_samples_DistanceImage_IsConstraintValid(const Base_samples_DistanceImage* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE		3556  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_TIME_2		3467  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_WIDTH_2		3478  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT_2		3489  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X_2		3500  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y_2		3511  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X_2		3522  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y_2		3533  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_DATA		3549  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM_2		3544  /**/
+#define Base_samples_DistanceImage_REQUIRED_BYTES_FOR_ENCODING       2665
+#define Base_samples_DistanceImage_REQUIRED_BITS_FOR_ENCODING        21320
+
+flag Base_samples_DistanceImage_Encode(const Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE		3557  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_TIME_2		3468  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_WIDTH_2		3479  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT_2		3490  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X_2		3501  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y_2		3512  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X_2		3523  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y_2		3534  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA		3550  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM_2		3545  /**/
+flag Base_samples_DistanceImage_Decode(Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointLimits --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointLimits_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointLimitRange arr[200];
+} Base_JointLimits_elements;
+typedef struct {
+    Base_JointLimits_names names;
+    Base_JointLimits_elements elements;
+
+} Base_JointLimits;
+
+void Base_JointLimits_names_Initialize(Base_JointLimits_names* pVal);
+void Base_JointLimits_elements_Initialize(Base_JointLimits_elements* pVal);
+void Base_JointLimits_Initialize(Base_JointLimits* pVal);
+
+#define ERR_BASE_JOINTLIMITS		2585  /**/
+#define ERR_BASE_JOINTLIMITS_NAMES		2428  /**/
+#define ERR_BASE_JOINTLIMITS_NAMES_ELM		2417  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS		2578  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM		2567  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN		2490  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_POSITION		2435  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_SPEED		2446  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_EFFORT		2457  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_RAW		2468  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_ACCELERATION		2479  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX		2556  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_POSITION		2501  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_SPEED		2512  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_EFFORT		2523  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_RAW		2534  /**/
+#define ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_ACCELERATION		2545  /**/
+flag Base_JointLimits_IsConstraintValid(const Base_JointLimits* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITS		2586  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITS_NAMES		2429  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITS_NAMES_ELM_2		2424  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITS_ELEMENTS		2579  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTLIMITS_ELEMENTS_ELM_2		2574  /**/
+#define Base_JointLimits_REQUIRED_BYTES_FOR_ENCODING       34152
+#define Base_JointLimits_REQUIRED_BITS_FOR_ENCODING        273216
+
+flag Base_JointLimits_Encode(const Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTLIMITS		2587  /**/
+#define ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES		2430  /**/
+#define ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES_ELM_2		2425  /**/
+#define ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS		2580  /**/
+#define ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_2		2575  /**/
+flag Base_JointLimits_Decode(Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransform --------------------------------------------*/
+typedef struct {
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d rotationaxis;
+
+} Base_JointTransform;
+
+void Base_JointTransform_Initialize(Base_JointTransform* pVal);
+
+#define ERR_BASE_JOINTTRANSFORM		2643  /**/
+#define ERR_BASE_JOINTTRANSFORM_SOURCEFRAME		2592  /**/
+#define ERR_BASE_JOINTTRANSFORM_TARGETFRAME		2603  /**/
+#define ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS		2632  /**/
+#define ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA		2625  /**/
+#define ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA_ELM		2614  /**/
+flag Base_JointTransform_IsConstraintValid(const Base_JointTransform* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM		2644  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_SOURCEFRAME_2		2599  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_TARGETFRAME_2		2610  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_ROTATIONAXIS_2		2639  /**/
+#define Base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       121
+#define Base_JointTransform_REQUIRED_BITS_FOR_ENCODING        966
+
+flag Base_JointTransform_Encode(const Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM		2645  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM_SOURCEFRAME_2		2600  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM_TARGETFRAME_2		2611  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM_ROTATIONAXIS_2		2640  /**/
+flag Base_JointTransform_Decode(Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransformVector --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointTransformVector_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTransform arr[200];
+} Base_JointTransformVector_elements;
+typedef struct {
+    Base_JointTransformVector_names names;
+    Base_JointTransformVector_elements elements;
+
+} Base_JointTransformVector;
+
+void Base_JointTransformVector_names_Initialize(Base_JointTransformVector_names* pVal);
+void Base_JointTransformVector_elements_Initialize(Base_JointTransformVector_elements* pVal);
+void Base_JointTransformVector_Initialize(Base_JointTransformVector* pVal);
+
+#define ERR_BASE_JOINTTRANSFORMVECTOR		4965  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_NAMES		4889  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM		4878  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS		4958  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM		4947  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME		4896  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME		4907  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS		4936  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA		4929  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		4918  /**/
+flag Base_JointTransformVector_IsConstraintValid(const Base_JointTransformVector* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR		4966  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_NAMES		4890  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM_2		4885  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS		4959  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_2		4954  /**/
+#define Base_JointTransformVector_REQUIRED_BYTES_FOR_ENCODING       32302
+#define Base_JointTransformVector_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_JointTransformVector_Encode(const Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR		4967  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES		4891  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM_2		4886  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS		4960  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_2		4955  /**/
+flag Base_JointTransformVector_Decode(Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointTransform --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointTransform_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTransform arr[200];
+} Base_NamedVector_Base_JointTransform_elements;
+typedef struct {
+    Base_NamedVector_Base_JointTransform_names names;
+    Base_NamedVector_Base_JointTransform_elements elements;
+
+} Base_NamedVector_Base_JointTransform;
+
+void Base_NamedVector_Base_JointTransform_names_Initialize(Base_NamedVector_Base_JointTransform_names* pVal);
+void Base_NamedVector_Base_JointTransform_elements_Initialize(Base_NamedVector_Base_JointTransform_elements* pVal);
+void Base_NamedVector_Base_JointTransform_Initialize(Base_NamedVector_Base_JointTransform* pVal);
+
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM		5059  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES		4983  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM		4972  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS		5052  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM		5041  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME		4990  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME		5001  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS		5030  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA		5023  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		5012  /**/
+flag Base_NamedVector_Base_JointTransform_IsConstraintValid(const Base_NamedVector_Base_JointTransform* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM		5060  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES		4984  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM_2		4979  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS		5053  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_2		5048  /**/
+#define Base_NamedVector_Base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       32302
+#define Base_NamedVector_Base_JointTransform_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_NamedVector_Base_JointTransform_Encode(const Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM		5061  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES		4985  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM_2		4980  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS		5054  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_2		5049  /**/
+flag Base_NamedVector_Base_JointTransform_Decode(Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointsTrajectory --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointsTrajectory_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTrajectory arr[200];
+} Base_JointsTrajectory_elements;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_JointsTrajectory_times_val;
+typedef struct {
+    Base_JointsTrajectory_names names;
+    Base_JointsTrajectory_elements elements;
+    Base_JointsTrajectory_times_val times_val;
+
+} Base_JointsTrajectory;
+
+void Base_JointsTrajectory_names_Initialize(Base_JointsTrajectory_names* pVal);
+void Base_JointsTrajectory_elements_Initialize(Base_JointsTrajectory_elements* pVal);
+void Base_JointsTrajectory_times_val_Initialize(Base_JointsTrajectory_times_val* pVal);
+void Base_JointsTrajectory_Initialize(Base_JointsTrajectory* pVal);
+
+#define ERR_BASE_JOINTSTRAJECTORY		2781  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_NAMES		2661  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_NAMES_ELM		2650  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS		2745  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM		2734  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM		2723  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_POSITION		2668  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_SPEED		2679  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT		2690  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_RAW		2701  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION		2712  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL		2774  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM		2763  /**/
+#define ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_MICROSECONDS		2752  /**/
+flag Base_JointsTrajectory_IsConstraintValid(const Base_JointsTrajectory* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY		2782  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_NAMES		2662  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_NAMES_ELM_2		2657  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_ELEMENTS		2746  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_2		2741  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_TIMES_VAL		2775  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_2		2770  /**/
+#define Base_JointsTrajectory_REQUIRED_BYTES_FOR_ENCODING       2609953
+#define Base_JointsTrajectory_REQUIRED_BITS_FOR_ENCODING        20879624
+
+flag Base_JointsTrajectory_Encode(const Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY		2783  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES		2663  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES_ELM_2		2658  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS		2747  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_2		2742  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL		2776  /**/
+#define ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_2		2771  /**/
+flag Base_JointsTrajectory_Decode(Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointLimitRange --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointLimitRange_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointLimitRange arr[200];
+} Base_NamedVector_Base_JointLimitRange_elements;
+typedef struct {
+    Base_NamedVector_Base_JointLimitRange_names names;
+    Base_NamedVector_Base_JointLimitRange_elements elements;
+
+} Base_NamedVector_Base_JointLimitRange;
+
+void Base_NamedVector_Base_JointLimitRange_names_Initialize(Base_NamedVector_Base_JointLimitRange_names* pVal);
+void Base_NamedVector_Base_JointLimitRange_elements_Initialize(Base_NamedVector_Base_JointLimitRange_elements* pVal);
+void Base_NamedVector_Base_JointLimitRange_Initialize(Base_NamedVector_Base_JointLimitRange* pVal);
+
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE		2956  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES		2799  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM		2788  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS		2949  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM		2938  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN		2861  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_POSITION		2806  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_SPEED		2817  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_EFFORT		2828  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_RAW		2839  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_ACCELERATION		2850  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX		2927  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_POSITION		2872  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_SPEED		2883  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_EFFORT		2894  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_RAW		2905  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_ACCELERATION		2916  /**/
+flag Base_NamedVector_Base_JointLimitRange_IsConstraintValid(const Base_NamedVector_Base_JointLimitRange* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE		2957  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES		2800  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM_2		2795  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS		2950  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_2		2945  /**/
+#define Base_NamedVector_Base_JointLimitRange_REQUIRED_BYTES_FOR_ENCODING       34152
+#define Base_NamedVector_Base_JointLimitRange_REQUIRED_BITS_FOR_ENCODING        273216
+
+flag Base_NamedVector_Base_JointLimitRange_Encode(const Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE		2958  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES		2801  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM_2		2796  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS		2951  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_2		2946  /**/
+flag Base_NamedVector_Base_JointLimitRange_Decode(Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointState --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointState_names;
+typedef struct {
+    Base_NamedVector_Base_JointState_names names;
+    Base_JointTrajectory elements;
+
+} Base_NamedVector_Base_JointState;
+
+void Base_NamedVector_Base_JointState_names_Initialize(Base_NamedVector_Base_JointState_names* pVal);
+void Base_NamedVector_Base_JointState_Initialize(Base_NamedVector_Base_JointState* pVal);
+
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE		3058  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES		2974  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM		2963  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS		3047  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM		3036  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_POSITION		2981  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_SPEED		2992  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_EFFORT		3003  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_RAW		3014  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_ACCELERATION		3025  /**/
+flag Base_NamedVector_Base_JointState_IsConstraintValid(const Base_NamedVector_Base_JointState* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE		3059  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES		2975  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM_2		2970  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_2		3054  /**/
+#define Base_NamedVector_Base_JointState_REQUIRED_BYTES_FOR_ENCODING       21152
+#define Base_NamedVector_Base_JointState_REQUIRED_BITS_FOR_ENCODING        169216
+
+flag Base_NamedVector_Base_JointState_Encode(const Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE		3060  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES		2976  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM_2		2971  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_2		3055  /**/
+flag Base_NamedVector_Base_JointState_Decode(Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_Wrench --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_Wrench_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Wrench arr[200];
+} Base_NamedVector_Base_Wrench_elements;
+typedef struct {
+    Base_NamedVector_Base_Wrench_names names;
+    Base_NamedVector_Base_Wrench_elements elements;
+
+} Base_NamedVector_Base_Wrench;
+
+void Base_NamedVector_Base_Wrench_names_Initialize(Base_NamedVector_Base_Wrench_names* pVal);
+void Base_NamedVector_Base_Wrench_elements_Initialize(Base_NamedVector_Base_Wrench_elements* pVal);
+void Base_NamedVector_Base_Wrench_Initialize(Base_NamedVector_Base_Wrench* pVal);
+
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH		3159  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES		3076  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM		3065  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS		3152  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM		3141  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE		3101  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA		3094  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA_ELM		3083  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE		3130  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA		3123  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA_ELM		3112  /**/
+flag Base_NamedVector_Base_Wrench_IsConstraintValid(const Base_NamedVector_Base_Wrench* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH		3160  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES		3077  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM_2		3072  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS		3153  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_2		3148  /**/
+#define Base_NamedVector_Base_Wrench_REQUIRED_BYTES_FOR_ENCODING       23852
+#define Base_NamedVector_Base_Wrench_REQUIRED_BITS_FOR_ENCODING        190816
+
+flag Base_NamedVector_Base_Wrench_Encode(const Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH		3161  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES		3078  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM_2		3073  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS		3154  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_2		3149  /**/
+flag Base_NamedVector_Base_Wrench_Decode(Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointTrajectory --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointTrajectory_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTrajectory arr[200];
+} Base_NamedVector_Base_JointTrajectory_elements;
+typedef struct {
+    Base_NamedVector_Base_JointTrajectory_names names;
+    Base_NamedVector_Base_JointTrajectory_elements elements;
+
+} Base_NamedVector_Base_JointTrajectory;
+
+void Base_NamedVector_Base_JointTrajectory_names_Initialize(Base_NamedVector_Base_JointTrajectory_names* pVal);
+void Base_NamedVector_Base_JointTrajectory_elements_Initialize(Base_NamedVector_Base_JointTrajectory_elements* pVal);
+void Base_NamedVector_Base_JointTrajectory_Initialize(Base_NamedVector_Base_JointTrajectory* pVal);
+
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY		3268  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES		3177  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM		3166  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS		3261  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM		3250  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM		3239  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_POSITION		3184  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_SPEED		3195  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT		3206  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_RAW		3217  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION		3228  /**/
+flag Base_NamedVector_Base_JointTrajectory_IsConstraintValid(const Base_NamedVector_Base_JointTrajectory* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY		3269  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES		3178  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM_2		3173  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS		3262  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_2		3257  /**/
+#define Base_NamedVector_Base_JointTrajectory_REQUIRED_BYTES_FOR_ENCODING       2608352
+#define Base_NamedVector_Base_JointTrajectory_REQUIRED_BITS_FOR_ENCODING        20866816
+
+flag Base_NamedVector_Base_JointTrajectory_Encode(const Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY		3270  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES		3179  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM_2		3174  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS		3263  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_2		3258  /**/
+flag Base_NamedVector_Base_JointTrajectory_Decode(Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_Joints --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_commands_Joints_names;
+typedef struct {
+    Base_commands_Joints_names names;
+    Base_JointTrajectory elements;
+    Base_Time time;
+
+} Base_commands_Joints;
+
+void Base_commands_Joints_names_Initialize(Base_commands_Joints_names* pVal);
+void Base_commands_Joints_Initialize(Base_commands_Joints* pVal);
+
+#define ERR_BASE_COMMANDS_JOINTS		3679  /**/
+#define ERR_BASE_COMMANDS_JOINTS_NAMES		3573  /**/
+#define ERR_BASE_COMMANDS_JOINTS_NAMES_ELM		3562  /**/
+#define ERR_BASE_COMMANDS_JOINTS_ELEMENTS		3646  /**/
+#define ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM		3635  /**/
+#define ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_POSITION		3580  /**/
+#define ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_SPEED		3591  /**/
+#define ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_EFFORT		3602  /**/
+#define ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_RAW		3613  /**/
+#define ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_ACCELERATION		3624  /**/
+#define ERR_BASE_COMMANDS_JOINTS_TIME		3668  /**/
+#define ERR_BASE_COMMANDS_JOINTS_TIME_MICROSECONDS		3657  /**/
+flag Base_commands_Joints_IsConstraintValid(const Base_commands_Joints* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS		3680  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_NAMES		3574  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_NAMES_ELM_2		3569  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_ELEMENTS_2		3653  /**/
+#define ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_TIME_2		3675  /**/
+#define Base_commands_Joints_REQUIRED_BYTES_FOR_ENCODING       21160
+#define Base_commands_Joints_REQUIRED_BITS_FOR_ENCODING        169280
+
+flag Base_commands_Joints_Encode(const Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_COMMANDS_JOINTS		3681  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES		3575  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES_ELM_2		3570  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS_2		3654  /**/
+#define ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_TIME_2		3676  /**/
+flag Base_commands_Joints_Decode(Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyState --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d position;
+    Wrappers_Matrix3d cov_position;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix3d cov_orientation;
+    Wrappers_Vector3d velocity;
+    Wrappers_Matrix3d cov_velocity;
+    Wrappers_Vector3d angular_velocity;
+    Wrappers_Matrix3d cov_angular_velocity;
+
+} Base_samples_RigidBodyState;
+
+void Base_samples_RigidBodyState_Initialize(Base_samples_RigidBodyState* pVal);
+
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE		4194  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_TIME		3918  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_TIME_MICROSECONDS		3907  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME		3929  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME		3940  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION		3969  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA		3962  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA_ELM		3951  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION		3998  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA		3991  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA_ELM		3980  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION		4038  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM		4020  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM_ELM		4009  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_RE		4027  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION		4067  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA		4060  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA_ELM		4049  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY		4096  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA		4089  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA_ELM		4078  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY		4125  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA		4118  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA_ELM		4107  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY		4154  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA		4147  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA_ELM		4136  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY		4183  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA		4176  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA_ELM		4165  /**/
+flag Base_samples_RigidBodyState_IsConstraintValid(const Base_samples_RigidBodyState* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE		4195  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_TIME_2		3925  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME_2		3936  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME_2		3947  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_2		3976  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_2		4005  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_2		4045  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_2		4074  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_2		4103  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_2		4132  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_2		4161  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_2		4190  /**/
+#define Base_samples_RigidBodyState_REQUIRED_BYTES_FOR_ENCODING       730
+#define Base_samples_RigidBodyState_REQUIRED_BITS_FOR_ENCODING        5836
+
+flag Base_samples_RigidBodyState_Encode(const Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE		4196  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_TIME_2		3926  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME_2		3937  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME_2		3948  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_2		3977  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_2		4006  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_2		4046  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_2		4075  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_2		4104  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_2		4133  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_2		4162  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_2		4191  /**/
+flag Base_samples_RigidBodyState_Decode(Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrenches --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_samples_Wrenches_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Wrench arr[200];
+} Base_samples_Wrenches_elements;
+typedef struct {
+    Base_samples_Wrenches_names names;
+    Base_samples_Wrenches_elements elements;
+    Base_Time time;
+
+} Base_samples_Wrenches;
+
+void Base_samples_Wrenches_names_Initialize(Base_samples_Wrenches_names* pVal);
+void Base_samples_Wrenches_elements_Initialize(Base_samples_Wrenches_elements* pVal);
+void Base_samples_Wrenches_Initialize(Base_samples_Wrenches* pVal);
+
+#define ERR_BASE_SAMPLES_WRENCHES		4842  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_NAMES		4737  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_NAMES_ELM		4726  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS		4813  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM		4802  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE		4762  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA		4755  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA_ELM		4744  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE		4791  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA		4784  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA_ELM		4773  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_TIME		4831  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_TIME_MICROSECONDS		4820  /**/
+flag Base_samples_Wrenches_IsConstraintValid(const Base_samples_Wrenches* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES		4843  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_NAMES		4738  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_NAMES_ELM_2		4733  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_ELEMENTS		4814  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_2		4809  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_TIME_2		4838  /**/
+#define Base_samples_Wrenches_REQUIRED_BYTES_FOR_ENCODING       23860
+#define Base_samples_Wrenches_REQUIRED_BITS_FOR_ENCODING        190880
+
+flag Base_samples_Wrenches_Encode(const Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES		4844  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES		4739  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES_ELM_2		4734  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS		4815  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_2		4810  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_TIME_2		4839  /**/
+flag Base_samples_Wrenches_Decode(Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_frame_attrib_t --------------------------------------------*/
+typedef struct {
+    T_String data;
+    T_String name_val;
+
+} Base_samples_frame_frame_attrib_t;
+
+void Base_samples_frame_frame_attrib_t_Initialize(Base_samples_frame_frame_attrib_t* pVal);
+
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T		4871  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA		4849  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL		4860  /**/
+flag Base_samples_frame_frame_attrib_t_IsConstraintValid(const Base_samples_frame_frame_attrib_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T		4872  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA_2		4856  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL_2		4867  /**/
+#define Base_samples_frame_frame_attrib_t_REQUIRED_BYTES_FOR_ENCODING       82
+#define Base_samples_frame_frame_attrib_t_REQUIRED_BITS_FOR_ENCODING        652
+
+flag Base_samples_frame_frame_attrib_t_Encode(const Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T		4873  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA_2		4857  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL_2		4868  /**/
+flag Base_samples_frame_frame_attrib_t_Decode(Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransform_m --------------------------------------------*/
+typedef struct {
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d rotationaxis;
+
+} Base_JointTransform_m;
+
+void Base_JointTransform_m_Initialize(Base_JointTransform_m* pVal);
+
+#define ERR_BASE_JOINTTRANSFORM_M		6067  /**/
+#define ERR_BASE_JOINTTRANSFORM_M_SOURCEFRAME		6016  /**/
+#define ERR_BASE_JOINTTRANSFORM_M_TARGETFRAME		6027  /**/
+#define ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS		6056  /**/
+#define ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA		6049  /**/
+#define ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA_ELM		6038  /**/
+flag Base_JointTransform_m_IsConstraintValid(const Base_JointTransform_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M		6068  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M_SOURCEFRAME_2		6023  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M_TARGETFRAME_2		6034  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_2		6063  /**/
+#define Base_JointTransform_m_REQUIRED_BYTES_FOR_ENCODING       121
+#define Base_JointTransform_m_REQUIRED_BITS_FOR_ENCODING        966
+
+flag Base_JointTransform_m_Encode(const Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M		6069  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M_SOURCEFRAME_2		6024  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M_TARGETFRAME_2		6035  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_2		6064  /**/
+flag Base_JointTransform_m_Decode(Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTransform_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_JointTransform;
+
+void Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal);
+
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM		221  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM		210  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME		159  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME		170  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS		199  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA		192  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA_ELM		181  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM		222  /**/
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_2		217  /**/
+#define Std_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       24151
+#define Std_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BITS_FOR_ENCODING        193208
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM		223  /**/
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_2		218  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransformVector_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointTransformVector_m_names;
+typedef struct {
+    Base_JointTransformVector_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_JointTransform elements;
+
+} Base_JointTransformVector_m;
+
+void Base_JointTransformVector_m_names_Initialize(Base_JointTransformVector_m_names* pVal);
+void Base_JointTransformVector_m_Initialize(Base_JointTransformVector_m* pVal);
+
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M		7586  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES		7506  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM		7495  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS		7575  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM		7564  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME		7513  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME		7524  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS		7553  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA		7546  /**/
+#define ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		7535  /**/
+flag Base_JointTransformVector_m_IsConstraintValid(const Base_JointTransformVector_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M		7587  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES		7507  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM_2		7502  /**/
+#define ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_2		7582  /**/
+#define Base_JointTransformVector_m_REQUIRED_BYTES_FOR_ENCODING       32302
+#define Base_JointTransformVector_m_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_JointTransformVector_m_Encode(const Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M		7588  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES		7508  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM_2		7503  /**/
+#define ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_2		7583  /**/
+flag Base_JointTransformVector_m_Decode(Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_base_JointTransform_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_base_JointTransform_m_names;
+typedef struct {
+    Base_NamedVector_base_JointTransform_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_JointTransform elements;
+
+} Base_NamedVector_base_JointTransform_m;
+
+void Base_NamedVector_base_JointTransform_m_names_Initialize(Base_NamedVector_base_JointTransform_m_names* pVal);
+void Base_NamedVector_base_JointTransform_m_Initialize(Base_NamedVector_base_JointTransform_m* pVal);
+
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M		7684  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES		7604  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM		7593  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS		7673  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM		7662  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME		7611  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME		7622  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS		7651  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA		7644  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		7633  /**/
+flag Base_NamedVector_base_JointTransform_m_IsConstraintValid(const Base_NamedVector_base_JointTransform_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M		7685  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES		7605  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM_2		7600  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_2		7680  /**/
+#define Base_NamedVector_base_JointTransform_m_REQUIRED_BYTES_FOR_ENCODING       32302
+#define Base_NamedVector_base_JointTransform_m_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_NamedVector_base_JointTransform_m_Encode(const Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M		7686  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES		7606  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM_2		7601  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_2		7681  /**/
+flag Base_NamedVector_base_JointTransform_m_Decode(Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyState_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d position;
+    Wrappers_Matrix3d cov_position;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix3d cov_orientation;
+    Wrappers_Vector3d velocity;
+    Wrappers_Matrix3d cov_velocity;
+    Wrappers_Vector3d angular_velocity;
+    Wrappers_Matrix3d cov_angular_velocity;
+
+} Base_samples_RigidBodyState_m;
+
+void Base_samples_RigidBodyState_m_Initialize(Base_samples_RigidBodyState_m* pVal);
+
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M		7401  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME		7125  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_MICROSECONDS		7114  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME		7136  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME		7147  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION		7176  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA		7169  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA_ELM		7158  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION		7205  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA		7198  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA_ELM		7187  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION		7245  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM		7227  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM_ELM		7216  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_RE		7234  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION		7274  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA		7267  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA_ELM		7256  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY		7303  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA		7296  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA_ELM		7285  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY		7332  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA		7325  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA_ELM		7314  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY		7361  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA		7354  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA_ELM		7343  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY		7390  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA		7383  /**/
+#define ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA_ELM		7372  /**/
+flag Base_samples_RigidBodyState_m_IsConstraintValid(const Base_samples_RigidBodyState_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M		7402  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_2		7132  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME_2		7143  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME_2		7154  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_2		7183  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_2		7212  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_2		7252  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_2		7281  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_2		7310  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_2		7339  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_2		7368  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_2		7397  /**/
+#define Base_samples_RigidBodyState_m_REQUIRED_BYTES_FOR_ENCODING       730
+#define Base_samples_RigidBodyState_m_REQUIRED_BITS_FOR_ENCODING        5836
+
+flag Base_samples_RigidBodyState_m_Encode(const Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M		7403  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_2		7133  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME_2		7144  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME_2		7155  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_2		7184  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_2		7213  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_2		7253  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_2		7282  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_2		7311  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_2		7340  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_2		7369  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_2		7398  /**/
+flag Base_samples_RigidBodyState_m_Decode(Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_base_Wrench_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_base_Wrench_m_names;
+typedef struct {
+    Base_NamedVector_base_Wrench_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_Wrench elements;
+
+} Base_NamedVector_base_Wrench_m;
+
+void Base_NamedVector_base_Wrench_m_names_Initialize(Base_NamedVector_base_Wrench_m_names* pVal);
+void Base_NamedVector_base_Wrench_m_Initialize(Base_NamedVector_base_Wrench_m* pVal);
+
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M		7789  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES		7702  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM		7691  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS		7778  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM		7767  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE		7727  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA		7720  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA_ELM		7709  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE		7756  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA		7749  /**/
+#define ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA_ELM		7738  /**/
+flag Base_NamedVector_base_Wrench_m_IsConstraintValid(const Base_NamedVector_base_Wrench_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M		7790  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES		7703  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM_2		7698  /**/
+#define ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_2		7785  /**/
+#define Base_NamedVector_base_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       23852
+#define Base_NamedVector_base_Wrench_m_REQUIRED_BITS_FOR_ENCODING        190816
+
+flag Base_NamedVector_base_Wrench_m_Encode(const Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M		7791  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES		7704  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM_2		7699  /**/
+#define ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_2		7786  /**/
+flag Base_NamedVector_base_Wrench_m_Decode(Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrenches_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_samples_Wrenches_m_names;
+typedef struct {
+    Base_samples_Wrenches_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_Wrench elements;
+    Base_Time time;
+
+} Base_samples_Wrenches_m;
+
+void Base_samples_Wrenches_m_names_Initialize(Base_samples_Wrenches_m_names* pVal);
+void Base_samples_Wrenches_m_Initialize(Base_samples_Wrenches_m* pVal);
+
+#define ERR_BASE_SAMPLES_WRENCHES_M		8017  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_NAMES		7908  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_NAMES_ELM		7897  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS		7984  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM		7973  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE		7933  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA		7926  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA_ELM		7915  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE		7962  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA		7955  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA_ELM		7944  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_TIME		8006  /**/
+#define ERR_BASE_SAMPLES_WRENCHES_M_TIME_MICROSECONDS		7995  /**/
+flag Base_samples_Wrenches_m_IsConstraintValid(const Base_samples_Wrenches_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M		8018  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_NAMES		7909  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_NAMES_ELM_2		7904  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_2		7991  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_TIME_2		8013  /**/
+#define Base_samples_Wrenches_m_REQUIRED_BYTES_FOR_ENCODING       23860
+#define Base_samples_Wrenches_m_REQUIRED_BITS_FOR_ENCODING        190880
+
+flag Base_samples_Wrenches_m_Encode(const Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M		8019  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES		7910  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES_ELM_2		7905  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_2		7992  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_TIME_2		8014  /**/
+flag Base_samples_Wrenches_m_Decode(Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_LaserScan --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_UInt32 arr[200];
+} Base_samples_LaserScan_ranges;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_LaserScan_remission;
+typedef struct {
+    Base_Time time;
+    T_Double start_angle;
+    T_Double angular_resolution;
+    T_Double speed;
+    Base_samples_LaserScan_ranges ranges;
+    T_UInt32 minrange;
+    T_UInt32 maxrange;
+    Base_samples_LaserScan_remission remission;
+
+} Base_samples_LaserScan;
+
+void Base_samples_LaserScan_ranges_Initialize(Base_samples_LaserScan_ranges* pVal);
+void Base_samples_LaserScan_remission_Initialize(Base_samples_LaserScan_remission* pVal);
+void Base_samples_LaserScan_Initialize(Base_samples_LaserScan* pVal);
+
+#define ERR_BASE_SAMPLES_LASERSCAN		3799  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_TIME		3697  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_TIME_MICROSECONDS		3686  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_START_ANGLE		3708  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION		3719  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_SPEED		3730  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_RANGES		3752  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_RANGES_ELM		3741  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_MINRANGE		3759  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_MAXRANGE		3770  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_REMISSION		3792  /**/
+#define ERR_BASE_SAMPLES_LASERSCAN_REMISSION_ELM		3781  /**/
+flag Base_samples_LaserScan_IsConstraintValid(const Base_samples_LaserScan* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN		3800  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_TIME_2		3704  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_START_ANGLE_2		3715  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION_2		3726  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_SPEED_2		3737  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_RANGES		3753  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_RANGES_ELM_2		3748  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_MINRANGE_2		3766  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_MAXRANGE_2		3777  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_REMISSION		3793  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_REMISSION_ELM_2		3788  /**/
+#define Base_samples_LaserScan_REQUIRED_BYTES_FOR_ENCODING       3457
+#define Base_samples_LaserScan_REQUIRED_BITS_FOR_ENCODING        27656
+
+flag Base_samples_LaserScan_Encode(const Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN		3801  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_TIME_2		3705  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_START_ANGLE_2		3716  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION_2		3727  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_SPEED_2		3738  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES		3754  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES_ELM_2		3749  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_MINRANGE_2		3767  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_MAXRANGE_2		3778  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION		3794  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION_ELM_2		3789  /**/
+flag Base_samples_LaserScan_Decode(Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Sonar --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_samples_Sonar_timestamps;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Angle arr[200];
+} Base_samples_Sonar_bearings;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_Sonar_bins;
+typedef struct {
+    Base_Time time;
+    Base_samples_Sonar_timestamps timestamps;
+    Base_Time bin_duration;
+    Base_Angle beam_width;
+    Base_Angle beam_height;
+    Base_samples_Sonar_bearings bearings;
+    T_Float speed_of_sound;
+    T_UInt32 bin_count;
+    T_UInt32 beam_count;
+    Base_samples_Sonar_bins bins;
+
+} Base_samples_Sonar;
+
+void Base_samples_Sonar_timestamps_Initialize(Base_samples_Sonar_timestamps* pVal);
+void Base_samples_Sonar_bearings_Initialize(Base_samples_Sonar_bearings* pVal);
+void Base_samples_Sonar_bins_Initialize(Base_samples_Sonar_bins* pVal);
+void Base_samples_Sonar_Initialize(Base_samples_Sonar* pVal);
+
+#define ERR_BASE_SAMPLES_SONAR		4398  /**/
+#define ERR_BASE_SAMPLES_SONAR_TIME		4212  /**/
+#define ERR_BASE_SAMPLES_SONAR_TIME_MICROSECONDS		4201  /**/
+#define ERR_BASE_SAMPLES_SONAR_TIMESTAMPS		4245  /**/
+#define ERR_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM		4234  /**/
+#define ERR_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_MICROSECONDS		4223  /**/
+#define ERR_BASE_SAMPLES_SONAR_BIN_DURATION		4263  /**/
+#define ERR_BASE_SAMPLES_SONAR_BIN_DURATION_MICROSECONDS		4252  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH		4285  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH_RAD		4274  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT		4307  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT_RAD		4296  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEARINGS		4340  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM		4329  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM_RAD		4318  /**/
+#define ERR_BASE_SAMPLES_SONAR_SPEED_OF_SOUND		4347  /**/
+#define ERR_BASE_SAMPLES_SONAR_BIN_COUNT		4358  /**/
+#define ERR_BASE_SAMPLES_SONAR_BEAM_COUNT		4369  /**/
+#define ERR_BASE_SAMPLES_SONAR_BINS		4391  /**/
+#define ERR_BASE_SAMPLES_SONAR_BINS_ELM		4380  /**/
+flag Base_samples_Sonar_IsConstraintValid(const Base_samples_Sonar* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR		4399  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_TIME_2		4219  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_TIMESTAMPS		4246  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_2		4241  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BIN_DURATION_2		4270  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEAM_WIDTH_2		4292  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEAM_HEIGHT_2		4314  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEARINGS		4341  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEARINGS_ELM_2		4336  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_SPEED_OF_SOUND_2		4354  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BIN_COUNT_2		4365  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEAM_COUNT_2		4376  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BINS		4392  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BINS_ELM_2		4387  /**/
+#define Base_samples_Sonar_REQUIRED_BYTES_FOR_ENCODING       6866
+#define Base_samples_Sonar_REQUIRED_BITS_FOR_ENCODING        54928
+
+flag Base_samples_Sonar_Encode(const Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR		4400  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIME_2		4220  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS		4247  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_2		4242  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BIN_DURATION_2		4271  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEAM_WIDTH_2		4293  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEAM_HEIGHT_2		4315  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS		4342  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS_ELM_2		4337  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_SPEED_OF_SOUND_2		4355  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BIN_COUNT_2		4366  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEAM_COUNT_2		4377  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS		4393  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS_ELM_2		4388  /**/
+flag Base_samples_Sonar_Decode(Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_SonarScan --------------------------------------------*/
+typedef struct {
+    int nCount;
+
+    byte arr[200];
+} Base_samples_SonarScan_data;
+
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_samples_SonarScan_time_beams;
+typedef struct {
+    Base_Time time;
+    Base_samples_SonarScan_data data;
+    Base_samples_SonarScan_time_beams time_beams;
+    T_UInt16 number_of_beams;
+    T_UInt16 number_of_bins;
+    Base_Angle start_bearing;
+    Base_Angle angular_resolution;
+    T_Double sampling_interval;
+    T_Float speed_of_sound;
+    Base_Angle beamwidth_horizontal;
+    Base_Angle beamwidth_vertical;
+    T_Boolean memory_layout_column;
+    T_Boolean polar_coordinates;
+
+} Base_samples_SonarScan;
+
+void Base_samples_SonarScan_data_Initialize(Base_samples_SonarScan_data* pVal);
+void Base_samples_SonarScan_time_beams_Initialize(Base_samples_SonarScan_time_beams* pVal);
+void Base_samples_SonarScan_Initialize(Base_samples_SonarScan* pVal);
+
+#define ERR_BASE_SAMPLES_SONARSCAN		4719  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_TIME		4518  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_TIME_MICROSECONDS		4507  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_DATA		4529  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS		4558  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM		4547  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_MICROSECONDS		4536  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS		4565  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS		4576  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_START_BEARING		4598  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_START_BEARING_RAD		4587  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION		4620  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_RAD		4609  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL		4631  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND		4642  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL		4664  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_RAD		4653  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL		4686  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_RAD		4675  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN		4697  /**/
+#define ERR_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES		4708  /**/
+flag Base_samples_SonarScan_IsConstraintValid(const Base_samples_SonarScan* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN		4720  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_TIME_2		4525  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_DATA		4530  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS		4559  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_2		4554  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS_2		4572  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS_2		4583  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_START_BEARING_2		4605  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_2		4627  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL_2		4638  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND_2		4649  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_2		4671  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_2		4693  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN_2		4704  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES_2		4715  /**/
+#define Base_samples_SonarScan_REQUIRED_BYTES_FOR_ENCODING       1893
+#define Base_samples_SonarScan_REQUIRED_BITS_FOR_ENCODING        15138
+
+flag Base_samples_SonarScan_Encode(const Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN		4721  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_2		4526  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA		4531  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS		4560  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_2		4555  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS_2		4573  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS_2		4584  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_START_BEARING_2		4606  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_2		4628  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL_2		4639  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND_2		4650  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_2		4672  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_2		4694  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN_2		4705  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES_2		4716  /**/
+flag Base_samples_SonarScan_Decode(Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_MatrixXd --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_MatrixXd_data;
+typedef struct {
+    T_Int32 rows;
+    T_Int32 cols;
+    Wrappers_MatrixXd_data data;
+
+} Wrappers_MatrixXd;
+
+void Wrappers_MatrixXd_data_Initialize(Wrappers_MatrixXd_data* pVal);
+void Wrappers_MatrixXd_Initialize(Wrappers_MatrixXd* pVal);
+
+#define ERR_WRAPPERS_MATRIXXD		5948  /**/
+#define ERR_WRAPPERS_MATRIXXD_ROWS		5908  /**/
+#define ERR_WRAPPERS_MATRIXXD_COLS		5919  /**/
+#define ERR_WRAPPERS_MATRIXXD_DATA		5941  /**/
+#define ERR_WRAPPERS_MATRIXXD_DATA_ELM		5930  /**/
+flag Wrappers_MatrixXd_IsConstraintValid(const Wrappers_MatrixXd* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIXXD		5949  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_ROWS_2		5915  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_COLS_2		5926  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_DATA		5942  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_DATA_ELM_2		5937  /**/
+#define Wrappers_MatrixXd_REQUIRED_BYTES_FOR_ENCODING       2609
+#define Wrappers_MatrixXd_REQUIRED_BITS_FOR_ENCODING        20872
+
+flag Wrappers_MatrixXd_Encode(const Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_MATRIXXD		5950  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIXXD_ROWS_2		5916  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIXXD_COLS_2		5927  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA		5943  /**/
+#define ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA_ELM_2		5938  /**/
+flag Wrappers_MatrixXd_Decode(Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef DummyBase_T Dummy2Base_T;
+
+
+void Dummy2Base_T_Initialize(Dummy2Base_T* pVal);
+
+#define ERR_DUMMY2BASE_T		1  /**/
+flag Dummy2Base_T_IsConstraintValid(const Dummy2Base_T* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_DUMMY2BASE_T_2_2		12  /**/
+#define Dummy2Base_T_REQUIRED_BYTES_FOR_ENCODING       4
+#define Dummy2Base_T_REQUIRED_BITS_FOR_ENCODING        32
+
+flag Dummy2Base_T_Encode(const Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_DUMMY2BASE_T_2_2		13  /**/
+flag Dummy2Base_T_Decode(Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_jointstate_mode_acceleration = 0,
+    base_jointstate_mode_effort = 1,
+    base_jointstate_mode_position = 2,
+    base_jointstate_mode_raw = 3,
+    base_jointstate_mode_speed = 4,
+    base_jointstate_mode_unset = 5
+} Base_JointState_MODE;
+
+// please use the following macros to avoid breaking code.
+#define Base_JointState_MODE_base_jointstate_mode_acceleration base_jointstate_mode_acceleration
+#define Base_JointState_MODE_base_jointstate_mode_effort base_jointstate_mode_effort
+#define Base_JointState_MODE_base_jointstate_mode_position base_jointstate_mode_position
+#define Base_JointState_MODE_base_jointstate_mode_raw base_jointstate_mode_raw
+#define Base_JointState_MODE_base_jointstate_mode_speed base_jointstate_mode_speed
+#define Base_JointState_MODE_base_jointstate_mode_unset base_jointstate_mode_unset
+
+void Base_JointState_MODE_Initialize(Base_JointState_MODE* pVal);
+
+#define ERR_BASE_JOINTSTATE_MODE		16  /**/
+flag Base_JointState_MODE_IsConstraintValid(const Base_JointState_MODE* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_JOINTSTATE_MODE		17  /**/
+#define Base_JointState_MODE_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_JointState_MODE_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Base_JointState_MODE_Encode(const Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_JOINTSTATE_MODE		18  /**/
+flag Base_JointState_MODE_Decode(Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_time_resolution_microseconds = 0,
+    base_time_resolution_milliseconds = 1,
+    base_time_resolution_seconds = 2
+} Base_Time_Resolution;
+
+// please use the following macros to avoid breaking code.
+#define Base_Time_Resolution_base_time_resolution_microseconds base_time_resolution_microseconds
+#define Base_Time_Resolution_base_time_resolution_milliseconds base_time_resolution_milliseconds
+#define Base_Time_Resolution_base_time_resolution_seconds base_time_resolution_seconds
+
+void Base_Time_Resolution_Initialize(Base_Time_Resolution* pVal);
+
+#define ERR_BASE_TIME_RESOLUTION		23  /**/
+flag Base_Time_Resolution_IsConstraintValid(const Base_Time_Resolution* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TIME_RESOLUTION		24  /**/
+#define Base_Time_Resolution_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_Time_Resolution_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_Time_Resolution_Encode(const Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TIME_RESOLUTION		25  /**/
+flag Base_Time_Resolution_Decode(Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_geometry_splinebase_coordinatetype_derivative_to_next = 0,
+    base_geometry_splinebase_coordinatetype_derivative_to_prior = 1,
+    base_geometry_splinebase_coordinatetype_knuckle_point = 2,
+    base_geometry_splinebase_coordinatetype_ordinary_point = 3,
+    base_geometry_splinebase_coordinatetype_second_derivative_to_next = 4,
+    base_geometry_splinebase_coordinatetype_second_derivative_to_prior = 5,
+    base_geometry_splinebase_coordinatetype_tangent_point_for_next = 6,
+    base_geometry_splinebase_coordinatetype_tangent_point_for_prior = 7
+} Base_geometry_SplineBase_CoordinateType;
+
+// please use the following macros to avoid breaking code.
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_derivative_to_next base_geometry_splinebase_coordinatetype_derivative_to_next
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_derivative_to_prior base_geometry_splinebase_coordinatetype_derivative_to_prior
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_knuckle_point base_geometry_splinebase_coordinatetype_knuckle_point
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_ordinary_point base_geometry_splinebase_coordinatetype_ordinary_point
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_second_derivative_to_next base_geometry_splinebase_coordinatetype_second_derivative_to_next
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_second_derivative_to_prior base_geometry_splinebase_coordinatetype_second_derivative_to_prior
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_tangent_point_for_next base_geometry_splinebase_coordinatetype_tangent_point_for_next
+#define Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_tangent_point_for_prior base_geometry_splinebase_coordinatetype_tangent_point_for_prior
+
+void Base_geometry_SplineBase_CoordinateType_Initialize(Base_geometry_SplineBase_CoordinateType* pVal);
+
+#define ERR_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE		30  /**/
+flag Base_geometry_SplineBase_CoordinateType_IsConstraintValid(const Base_geometry_SplineBase_CoordinateType* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE		31  /**/
+#define Base_geometry_SplineBase_CoordinateType_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_geometry_SplineBase_CoordinateType_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Base_geometry_SplineBase_CoordinateType_Encode(const Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE		32  /**/
+flag Base_geometry_SplineBase_CoordinateType_Decode(Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_depthmap_depth_measurement_state_measurement_error = 0,
+    base_samples_depthmap_depth_measurement_state_too_far = 1,
+    base_samples_depthmap_depth_measurement_state_too_near = 2,
+    base_samples_depthmap_depth_measurement_state_valid_measurement = 3
+} Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE;
+
+// please use the following macros to avoid breaking code.
+#define Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_measurement_error base_samples_depthmap_depth_measurement_state_measurement_error
+#define Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_too_far base_samples_depthmap_depth_measurement_state_too_far
+#define Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_too_near base_samples_depthmap_depth_measurement_state_too_near
+#define Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_valid_measurement base_samples_depthmap_depth_measurement_state_valid_measurement
+
+void Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal);
+
+#define ERR_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE		37  /**/
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE		38  /**/
+#define Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Encode(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE		39  /**/
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Decode(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_depthmap_projection_type_planar = 0,
+    base_samples_depthmap_projection_type_polar = 1
+} Base_samples_DepthMap_PROJECTION_TYPE;
+
+// please use the following macros to avoid breaking code.
+#define Base_samples_DepthMap_PROJECTION_TYPE_base_samples_depthmap_projection_type_planar base_samples_depthmap_projection_type_planar
+#define Base_samples_DepthMap_PROJECTION_TYPE_base_samples_depthmap_projection_type_polar base_samples_depthmap_projection_type_polar
+
+void Base_samples_DepthMap_PROJECTION_TYPE_Initialize(Base_samples_DepthMap_PROJECTION_TYPE* pVal);
+
+#define ERR_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE		44  /**/
+flag Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE		45  /**/
+#define Base_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BITS_FOR_ENCODING        1
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_Encode(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE		46  /**/
+flag Base_samples_DepthMap_PROJECTION_TYPE_Decode(Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_DepthMap --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_samples_DepthMap_timestamps;
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Base_samples_DepthMap_vertical_interval;
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Base_samples_DepthMap_horizontal_interval;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_DepthMap_distances;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_DepthMap_remissions;
+typedef struct {
+    Base_Time time;
+    Base_samples_DepthMap_timestamps timestamps;
+    Base_samples_DepthMap_PROJECTION_TYPE vertical_projection;
+    Base_samples_DepthMap_PROJECTION_TYPE horizontal_projection;
+    Base_samples_DepthMap_vertical_interval vertical_interval;
+    Base_samples_DepthMap_horizontal_interval horizontal_interval;
+    T_UInt32 vertical_size;
+    T_UInt32 horizontal_size;
+    Base_samples_DepthMap_distances distances;
+    Base_samples_DepthMap_remissions remissions;
+
+} Base_samples_DepthMap;
+
+void Base_samples_DepthMap_timestamps_Initialize(Base_samples_DepthMap_timestamps* pVal);
+void Base_samples_DepthMap_vertical_interval_Initialize(Base_samples_DepthMap_vertical_interval* pVal);
+void Base_samples_DepthMap_horizontal_interval_Initialize(Base_samples_DepthMap_horizontal_interval* pVal);
+void Base_samples_DepthMap_distances_Initialize(Base_samples_DepthMap_distances* pVal);
+void Base_samples_DepthMap_remissions_Initialize(Base_samples_DepthMap_remissions* pVal);
+void Base_samples_DepthMap_Initialize(Base_samples_DepthMap* pVal);
+
+#define ERR_BASE_SAMPLES_DEPTHMAP		3442  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_TIME		3286  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_TIME_MICROSECONDS		3275  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS		3319  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM		3308  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_MICROSECONDS		3297  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION		3326  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION		3337  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL		3359  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM		3348  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL		3377  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM		3366  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE		3384  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE		3395  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES		3417  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM		3406  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS		3435  /**/
+#define ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM		3424  /**/
+flag Base_samples_DepthMap_IsConstraintValid(const Base_samples_DepthMap* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP		3443  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_TIME_2		3293  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS		3320  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_2		3315  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION_2		3333  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION_2		3344  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL		3360  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM_2		3355  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL		3378  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM_2		3373  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE_2		3391  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE_2		3402  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DISTANCES		3418  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM_2		3413  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS		3436  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM_2		3431  /**/
+#define Base_samples_DepthMap_REQUIRED_BYTES_FOR_ENCODING       12022
+#define Base_samples_DepthMap_REQUIRED_BITS_FOR_ENCODING        96170
+
+flag Base_samples_DepthMap_Encode(const Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP		3444  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIME_2		3294  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS		3321  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_2		3316  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION_2		3334  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION_2		3345  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL		3361  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM_2		3356  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL		3379  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM_2		3374  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE_2		3392  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE_2		3403  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES		3419  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM_2		3414  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS		3437  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM_2		3432  /**/
+flag Base_samples_DepthMap_Decode(Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_depthmap_unit_axis_unit_x = 0,
+    base_samples_depthmap_unit_axis_unit_y = 1,
+    base_samples_depthmap_unit_axis_unit_z = 2
+} Base_samples_DepthMap_UNIT_AXIS;
+
+// please use the following macros to avoid breaking code.
+#define Base_samples_DepthMap_UNIT_AXIS_base_samples_depthmap_unit_axis_unit_x base_samples_depthmap_unit_axis_unit_x
+#define Base_samples_DepthMap_UNIT_AXIS_base_samples_depthmap_unit_axis_unit_y base_samples_depthmap_unit_axis_unit_y
+#define Base_samples_DepthMap_UNIT_AXIS_base_samples_depthmap_unit_axis_unit_z base_samples_depthmap_unit_axis_unit_z
+
+void Base_samples_DepthMap_UNIT_AXIS_Initialize(Base_samples_DepthMap_UNIT_AXIS* pVal);
+
+#define ERR_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS		51  /**/
+flag Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const Base_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS		52  /**/
+#define Base_samples_DepthMap_UNIT_AXIS_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_samples_DepthMap_UNIT_AXIS_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_samples_DepthMap_UNIT_AXIS_Encode(const Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS		53  /**/
+flag Base_samples_DepthMap_UNIT_AXIS_Decode(Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_laser_range_errors_end_laser_range_errors = 0,
+    base_samples_laser_range_errors_max_range_error = 1,
+    base_samples_laser_range_errors_measurement_error = 2,
+    base_samples_laser_range_errors_other_range_errors = 3,
+    base_samples_laser_range_errors_too_far = 4,
+    base_samples_laser_range_errors_too_near = 5
+} Base_samples_LASER_RANGE_ERRORS;
+
+// please use the following macros to avoid breaking code.
+#define Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_end_laser_range_errors base_samples_laser_range_errors_end_laser_range_errors
+#define Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_max_range_error base_samples_laser_range_errors_max_range_error
+#define Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_measurement_error base_samples_laser_range_errors_measurement_error
+#define Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_other_range_errors base_samples_laser_range_errors_other_range_errors
+#define Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_too_far base_samples_laser_range_errors_too_far
+#define Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_too_near base_samples_laser_range_errors_too_near
+
+void Base_samples_LASER_RANGE_ERRORS_Initialize(Base_samples_LASER_RANGE_ERRORS* pVal);
+
+#define ERR_BASE_SAMPLES_LASER_RANGE_ERRORS		58  /**/
+flag Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(const Base_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_LASER_RANGE_ERRORS		59  /**/
+#define Base_samples_LASER_RANGE_ERRORS_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_samples_LASER_RANGE_ERRORS_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Base_samples_LASER_RANGE_ERRORS_Encode(const Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS		60  /**/
+flag Base_samples_LASER_RANGE_ERRORS_Decode(Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_frame_frame_mode_t_compressed_modes = 0,
+    base_samples_frame_frame_mode_t_mode_bayer = 1,
+    base_samples_frame_frame_mode_t_mode_bayer_bggr = 2,
+    base_samples_frame_frame_mode_t_mode_bayer_gbrg = 3,
+    base_samples_frame_frame_mode_t_mode_bayer_grbg = 4,
+    base_samples_frame_frame_mode_t_mode_bayer_rggb = 5,
+    base_samples_frame_frame_mode_t_mode_bgr = 6,
+    base_samples_frame_frame_mode_t_mode_grayscale = 7,
+    base_samples_frame_frame_mode_t_mode_jpeg = 8,
+    base_samples_frame_frame_mode_t_mode_pjpg = 9,
+    base_samples_frame_frame_mode_t_mode_png = 10,
+    base_samples_frame_frame_mode_t_mode_rgb = 11,
+    base_samples_frame_frame_mode_t_mode_rgb32 = 12,
+    base_samples_frame_frame_mode_t_mode_undefined = 13,
+    base_samples_frame_frame_mode_t_mode_uyvy = 14,
+    base_samples_frame_frame_mode_t_raw_modes = 15
+} Base_samples_frame_frame_mode_t;
+
+// please use the following macros to avoid breaking code.
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_compressed_modes base_samples_frame_frame_mode_t_compressed_modes
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer base_samples_frame_frame_mode_t_mode_bayer
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_bggr base_samples_frame_frame_mode_t_mode_bayer_bggr
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_gbrg base_samples_frame_frame_mode_t_mode_bayer_gbrg
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_grbg base_samples_frame_frame_mode_t_mode_bayer_grbg
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_rggb base_samples_frame_frame_mode_t_mode_bayer_rggb
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bgr base_samples_frame_frame_mode_t_mode_bgr
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_grayscale base_samples_frame_frame_mode_t_mode_grayscale
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_jpeg base_samples_frame_frame_mode_t_mode_jpeg
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_pjpg base_samples_frame_frame_mode_t_mode_pjpg
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_png base_samples_frame_frame_mode_t_mode_png
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_rgb base_samples_frame_frame_mode_t_mode_rgb
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_rgb32 base_samples_frame_frame_mode_t_mode_rgb32
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_undefined base_samples_frame_frame_mode_t_mode_undefined
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_uyvy base_samples_frame_frame_mode_t_mode_uyvy
+#define Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_raw_modes base_samples_frame_frame_mode_t_raw_modes
+
+void Base_samples_frame_frame_mode_t_Initialize(Base_samples_frame_frame_mode_t* pVal);
+
+#define ERR_BASE_SAMPLES_FRAME_FRAME_MODE_T		65  /**/
+flag Base_samples_frame_frame_mode_t_IsConstraintValid(const Base_samples_frame_frame_mode_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_MODE_T		66  /**/
+#define Base_samples_frame_frame_mode_t_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_samples_frame_frame_mode_t_REQUIRED_BITS_FOR_ENCODING        4
+
+flag Base_samples_frame_frame_mode_t_Encode(const Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T		67  /**/
+flag Base_samples_frame_frame_mode_t_Decode(Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_frame_frame_status_t_status_empty = 0,
+    base_samples_frame_frame_status_t_status_invalid = 1,
+    base_samples_frame_frame_status_t_status_valid = 2
+} Base_samples_frame_frame_status_t;
+
+// please use the following macros to avoid breaking code.
+#define Base_samples_frame_frame_status_t_base_samples_frame_frame_status_t_status_empty base_samples_frame_frame_status_t_status_empty
+#define Base_samples_frame_frame_status_t_base_samples_frame_frame_status_t_status_invalid base_samples_frame_frame_status_t_status_invalid
+#define Base_samples_frame_frame_status_t_base_samples_frame_frame_status_t_status_valid base_samples_frame_frame_status_t_status_valid
+
+void Base_samples_frame_frame_status_t_Initialize(Base_samples_frame_frame_status_t* pVal);
+
+#define ERR_BASE_SAMPLES_FRAME_FRAME_STATUS_T		72  /**/
+flag Base_samples_frame_frame_status_t_IsConstraintValid(const Base_samples_frame_frame_status_t* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T		73  /**/
+#define Base_samples_frame_frame_status_t_REQUIRED_BYTES_FOR_ENCODING       1
+#define Base_samples_frame_frame_status_t_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_samples_frame_frame_status_t_Encode(const Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T		74  /**/
+flag Base_samples_frame_frame_status_t_Decode(Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_Frame --------------------------------------------*/
+typedef struct {
+    int nCount;
+
+    byte arr[200];
+} Base_samples_frame_Frame_image;
+
+
+
+typedef struct {
+    int nCount;
+
+    Base_samples_frame_frame_attrib_t arr[200];
+} Base_samples_frame_Frame_attributes;
+typedef struct {
+    Base_Time time;
+    Base_Time received_time;
+    Base_samples_frame_Frame_image image;
+    Base_samples_frame_Frame_attributes attributes;
+    Base_samples_frame_frame_size_t size_val;
+    T_UInt32 data_depth;
+    T_UInt32 pixel_size;
+    T_UInt32 row_size;
+    Base_samples_frame_frame_mode_t frame_mode;
+    Base_samples_frame_frame_status_t frame_status;
+
+} Base_samples_frame_Frame;
+
+void Base_samples_frame_Frame_image_Initialize(Base_samples_frame_Frame_image* pVal);
+void Base_samples_frame_Frame_attributes_Initialize(Base_samples_frame_Frame_attributes* pVal);
+void Base_samples_frame_Frame_Initialize(Base_samples_frame_Frame* pVal);
+
+#define ERR_BASE_SAMPLES_FRAME_FRAME		5245  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_TIME		5077  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_TIME_MICROSECONDS		5066  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME		5099  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_MICROSECONDS		5088  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_IMAGE		5110  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES		5150  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM		5139  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA		5117  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL		5128  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL		5179  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_WIDTH		5157  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_HEIGHT		5168  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH		5190  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE		5201  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE		5212  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE		5223  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS		5234  /**/
+flag Base_samples_frame_Frame_IsConstraintValid(const Base_samples_frame_Frame* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME		5246  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_TIME_2		5084  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_2		5106  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_IMAGE		5111  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES		5151  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_2		5146  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_2		5186  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH_2		5197  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE_2		5208  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE_2		5219  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE_2		5230  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS_2		5241  /**/
+#define Base_samples_frame_Frame_REQUIRED_BYTES_FOR_ENCODING       16535
+#define Base_samples_frame_Frame_REQUIRED_BITS_FOR_ENCODING        132278
+
+flag Base_samples_frame_Frame_Encode(const Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME		5247  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_TIME_2		5085  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_2		5107  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE		5112  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES		5152  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_2		5147  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_2		5187  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH_2		5198  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE_2		5209  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE_2		5220  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE_2		5231  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS_2		5242  /**/
+flag Base_samples_frame_Frame_Decode(Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_FramePair --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Base_samples_frame_Frame first;
+    Base_samples_frame_Frame second;
+    T_UInt32 id;
+
+} Base_samples_frame_FramePair;
+
+void Base_samples_frame_FramePair_Initialize(Base_samples_frame_FramePair* pVal);
+
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR		5665  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME		5263  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_MICROSECONDS		5252  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST		5453  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_TIME		5285  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_TIME_MICROSECONDS		5274  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_RECEIVED_TIME		5307  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_RECEIVED_TIME_MICROSECONDS		5296  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE		5318  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES		5358  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM		5347  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA		5325  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL		5336  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL		5387  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_WIDTH		5365  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_HEIGHT		5376  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_DATA_DEPTH		5398  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_PIXEL_SIZE		5409  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ROW_SIZE		5420  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE		5431  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS		5442  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND		5643  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_TIME		5475  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_TIME_MICROSECONDS		5464  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_RECEIVED_TIME		5497  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_RECEIVED_TIME_MICROSECONDS		5486  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE		5508  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES		5548  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM		5537  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA		5515  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL		5526  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL		5577  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_WIDTH		5555  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_HEIGHT		5566  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_DATA_DEPTH		5588  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_PIXEL_SIZE		5599  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ROW_SIZE		5610  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE		5621  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS		5632  /**/
+#define ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_ID		5654  /**/
+flag Base_samples_frame_FramePair_IsConstraintValid(const Base_samples_frame_FramePair* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR		5666  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_2		5270  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_2		5460  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_2		5650  /**/
+#define ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_ID_2		5661  /**/
+#define Base_samples_frame_FramePair_REQUIRED_BYTES_FOR_ENCODING       33082
+#define Base_samples_frame_FramePair_REQUIRED_BITS_FOR_ENCODING        264652
+
+flag Base_samples_frame_FramePair_Encode(const Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR		5667  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_2		5271  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_2		5461  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_2		5651  /**/
+#define ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_ID_2		5662  /**/
+flag Base_samples_frame_FramePair_Decode(Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    wrappers_geometry_splinetype_degenerate = 0,
+    wrappers_geometry_splinetype_polynomial_bezier = 1,
+    wrappers_geometry_splinetype_polynomial_bspline = 2,
+    wrappers_geometry_splinetype_rational_bezier = 3,
+    wrappers_geometry_splinetype_rational_bspline = 4
+} Wrappers_geometry_SplineType;
+
+// please use the following macros to avoid breaking code.
+#define Wrappers_geometry_SplineType_wrappers_geometry_splinetype_degenerate wrappers_geometry_splinetype_degenerate
+#define Wrappers_geometry_SplineType_wrappers_geometry_splinetype_polynomial_bezier wrappers_geometry_splinetype_polynomial_bezier
+#define Wrappers_geometry_SplineType_wrappers_geometry_splinetype_polynomial_bspline wrappers_geometry_splinetype_polynomial_bspline
+#define Wrappers_geometry_SplineType_wrappers_geometry_splinetype_rational_bezier wrappers_geometry_splinetype_rational_bezier
+#define Wrappers_geometry_SplineType_wrappers_geometry_splinetype_rational_bspline wrappers_geometry_splinetype_rational_bspline
+
+void Wrappers_geometry_SplineType_Initialize(Wrappers_geometry_SplineType* pVal);
+
+#define ERR_WRAPPERS_GEOMETRY_SPLINETYPE		79  /**/
+flag Wrappers_geometry_SplineType_IsConstraintValid(const Wrappers_geometry_SplineType* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINETYPE		80  /**/
+#define Wrappers_geometry_SplineType_REQUIRED_BYTES_FOR_ENCODING       1
+#define Wrappers_geometry_SplineType_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Wrappers_geometry_SplineType_Encode(const Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE		81  /**/
+flag Wrappers_geometry_SplineType_Decode(Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_geometry_Spline --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_geometry_Spline_knots;
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_geometry_Spline_vertices;
+typedef struct {
+    T_Double geometric_resolution;
+    T_Int32 dimension;
+    T_Int32 curve_order;
+    Wrappers_geometry_SplineType kind;
+    Wrappers_geometry_Spline_knots knots;
+    Wrappers_geometry_Spline_vertices vertices;
+
+} Wrappers_geometry_Spline;
+
+void Wrappers_geometry_Spline_knots_Initialize(Wrappers_geometry_Spline_knots* pVal);
+void Wrappers_geometry_Spline_vertices_Initialize(Wrappers_geometry_Spline_vertices* pVal);
+void Wrappers_geometry_Spline_Initialize(Wrappers_geometry_Spline* pVal);
+
+#define ERR_WRAPPERS_GEOMETRY_SPLINE		8104  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION		8024  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_DIMENSION		8035  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER		8046  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_KIND		8057  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS		8079  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM		8068  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES		8097  /**/
+#define ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM		8086  /**/
+flag Wrappers_geometry_Spline_IsConstraintValid(const Wrappers_geometry_Spline* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE		8105  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION_2		8031  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_DIMENSION_2		8042  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER_2		8053  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_KIND_2		8064  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS		8080  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM_2		8075  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES		8098  /**/
+#define ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM_2		8093  /**/
+#define Wrappers_geometry_Spline_REQUIRED_BYTES_FOR_ENCODING       5224
+#define Wrappers_geometry_Spline_REQUIRED_BITS_FOR_ENCODING        41787
+
+flag Wrappers_geometry_Spline_Encode(const Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE		8106  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION_2		8032  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_DIMENSION_2		8043  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER_2		8054  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KIND_2		8065  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS		8081  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM_2		8076  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES		8099  /**/
+#define ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM_2		8094  /**/
+flag Wrappers_geometry_Spline_Decode(Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Trajectory --------------------------------------------*/
+typedef struct {
+    T_Double speed;
+    Wrappers_geometry_Spline spline;
+
+} Base_Trajectory;
+
+void Base_Trajectory_Initialize(Base_Trajectory* pVal);
+
+#define ERR_BASE_TRAJECTORY		1192  /**/
+#define ERR_BASE_TRAJECTORY_SPEED		1090  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE		1181  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_GEOMETRIC_RESOLUTION		1101  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_DIMENSION		1112  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_CURVE_ORDER		1123  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_KIND		1134  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_KNOTS		1156  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_KNOTS_ELM		1145  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_VERTICES		1174  /**/
+#define ERR_BASE_TRAJECTORY_SPLINE_VERTICES_ELM		1163  /**/
+flag Base_Trajectory_IsConstraintValid(const Base_Trajectory* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TRAJECTORY		1193  /**/
+#define ERR_UPER_ENCODE_BASE_TRAJECTORY_SPEED_2		1097  /**/
+#define ERR_UPER_ENCODE_BASE_TRAJECTORY_SPLINE_2		1188  /**/
+#define Base_Trajectory_REQUIRED_BYTES_FOR_ENCODING       5237
+#define Base_Trajectory_REQUIRED_BITS_FOR_ENCODING        41891
+
+flag Base_Trajectory_Encode(const Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TRAJECTORY		1194  /**/
+#define ERR_UPER_DECODE_BASE_TRAJECTORY_SPEED_2		1098  /**/
+#define ERR_UPER_DECODE_BASE_TRAJECTORY_SPLINE_2		1189  /**/
+flag Base_Trajectory_Decode(Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Trajectory_m --------------------------------------------*/
+typedef struct {
+    T_Double speed;
+    Wrappers_geometry_Spline spline;
+
+} Base_Trajectory_m;
+
+void Base_Trajectory_m_Initialize(Base_Trajectory_m* pVal);
+
+#define ERR_BASE_TRAJECTORY_M		8213  /**/
+#define ERR_BASE_TRAJECTORY_M_SPEED		8111  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE		8202  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_GEOMETRIC_RESOLUTION		8122  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_DIMENSION		8133  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_CURVE_ORDER		8144  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_KIND		8155  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS		8177  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS_ELM		8166  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES		8195  /**/
+#define ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES_ELM		8184  /**/
+flag Base_Trajectory_m_IsConstraintValid(const Base_Trajectory_m* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_BASE_TRAJECTORY_M		8214  /**/
+#define ERR_UPER_ENCODE_BASE_TRAJECTORY_M_SPEED_2		8118  /**/
+#define ERR_UPER_ENCODE_BASE_TRAJECTORY_M_SPLINE_2		8209  /**/
+#define Base_Trajectory_m_REQUIRED_BYTES_FOR_ENCODING       5237
+#define Base_Trajectory_m_REQUIRED_BITS_FOR_ENCODING        41891
+
+flag Base_Trajectory_m_Encode(const Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_BASE_TRAJECTORY_M		8215  /**/
+#define ERR_UPER_DECODE_BASE_TRAJECTORY_M_SPEED_2		8119  /**/
+#define ERR_UPER_DECODE_BASE_TRAJECTORY_M_SPLINE_2		8210  /**/
+flag Base_Trajectory_m_Decode(Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_Trajectory_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_Trajectory;
+
+void Std_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal);
+
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY		533  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM		522  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPEED		420  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE		511  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_GEOMETRIC_RESOLUTION		431  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_DIMENSION		442  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_CURVE_ORDER		453  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND		464  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS		486  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS_ELM		475  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES		504  /**/
+#define ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES_ELM		493  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY		534  /**/
+#define ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_2		529  /**/
+#define Std_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BYTES_FOR_ENCODING       1047276
+#define Std_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BITS_FOR_ENCODING        8378208
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Encode(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY		535  /**/
+#define ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_2		530  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Decode(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Analog.hpp b/generated/include/i3ds_asn1/Analog.hpp
new file mode 100644
index 0000000..98c5aa5
--- /dev/null
+++ b/generated/include/i3ds_asn1/Analog.hpp
@@ -0,0 +1,92 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Analog_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Analog_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Sensor.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_UInt8 SeriesCount;
+
+
+void SeriesCount_Initialize(SeriesCount* pVal);
+
+#define i3ds_asn1_ERR_SERIESCOUNT		8344  /**/
+flag SeriesCount_IsConstraintValid(const SeriesCount* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SERIESCOUNT_2		8351  /**/
+#define i3ds_asn1_SeriesCount_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_SeriesCount_REQUIRED_BITS_FOR_ENCODING        8
+
+flag SeriesCount_Encode(const SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SERIESCOUNT_2		8352  /**/
+flag SeriesCount_Decode(SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- AnalogSeriesDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    T_UInt8 series_count;
+    T_UInt32 batch_size;
+
+} AnalogSeriesDescriptor;
+
+void AnalogSeriesDescriptor_Initialize(AnalogSeriesDescriptor* pVal);
+
+#define i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR		8506  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES		8465  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_TIMESTAMP		8355  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_VALIDITY		8370  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		8458  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		8447  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		8381  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		8436  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		8392  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		8403  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		8414  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		8425  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_SERIES_COUNT		8476  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_BATCH_SIZE		8491  /**/
+flag AnalogSeriesDescriptor_IsConstraintValid(const AnalogSeriesDescriptor* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR		8507  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_2		8472  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR_SERIES_COUNT_2_2		8487  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_ANALOGSERIESDESCRIPTOR_BATCH_SIZE_2_2		8502  /**/
+#define i3ds_asn1_AnalogSeriesDescriptor_REQUIRED_BYTES_FOR_ENCODING       71
+#define i3ds_asn1_AnalogSeriesDescriptor_REQUIRED_BITS_FOR_ENCODING        565
+
+flag AnalogSeriesDescriptor_Encode(const AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR		8508  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_2		8473  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR_SERIES_COUNT_2_2		8488  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_ANALOGSERIESDESCRIPTOR_BATCH_SIZE_2_2		8503  /**/
+flag AnalogSeriesDescriptor_Decode(AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Camera.hpp b/generated/include/i3ds_asn1/Camera.hpp
new file mode 100644
index 0000000..7ab529a
--- /dev/null
+++ b/generated/include/i3ds_asn1/Camera.hpp
@@ -0,0 +1,320 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Camera_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Camera_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_Float SensorGain;
+
+
+void SensorGain_Initialize(SensorGain* pVal);
+
+#define i3ds_asn1_ERR_SENSORGAIN		9445  /**/
+flag SensorGain_IsConstraintValid(const SensorGain* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SENSORGAIN_2		9452  /**/
+#define i3ds_asn1_SensorGain_REQUIRED_BYTES_FOR_ENCODING       13
+#define i3ds_asn1_SensorGain_REQUIRED_BITS_FOR_ENCODING        104
+
+flag SensorGain_Encode(const SensorGain* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SENSORGAIN_2		9453  /**/
+flag SensorGain_Decode(SensorGain* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt16 PatternSequence;
+
+
+void PatternSequence_Initialize(PatternSequence* pVal);
+
+#define i3ds_asn1_ERR_PATTERNSEQUENCE		9658  /**/
+flag PatternSequence_IsConstraintValid(const PatternSequence* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_PATTERNSEQUENCE_2		9665  /**/
+#define i3ds_asn1_PatternSequence_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_PatternSequence_REQUIRED_BITS_FOR_ENCODING        16
+
+flag PatternSequence_Encode(const PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_PATTERNSEQUENCE_2		9666  /**/
+flag PatternSequence_Decode(PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt16 PatternID;
+
+
+void PatternID_Initialize(PatternID* pVal);
+
+#define i3ds_asn1_ERR_PATTERNID		9669  /**/
+flag PatternID_IsConstraintValid(const PatternID* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_PATTERNID_2		9676  /**/
+#define i3ds_asn1_PatternID_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_PatternID_REQUIRED_BITS_FOR_ENCODING        16
+
+flag PatternID_Encode(const PatternID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_PATTERNID_2		9677  /**/
+flag PatternID_Decode(PatternID* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt8 FlashStrength;
+
+
+void FlashStrength_Initialize(FlashStrength* pVal);
+
+#define i3ds_asn1_ERR_FLASHSTRENGTH		9541  /**/
+flag FlashStrength_IsConstraintValid(const FlashStrength* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_FLASHSTRENGTH_2		9548  /**/
+#define i3ds_asn1_FlashStrength_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_FlashStrength_REQUIRED_BITS_FOR_ENCODING        8
+
+flag FlashStrength_Encode(const FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_FLASHSTRENGTH_2		9549  /**/
+flag FlashStrength_Decode(FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt32 ShutterTime;
+
+
+void ShutterTime_Initialize(ShutterTime* pVal);
+
+#define i3ds_asn1_ERR_SHUTTERTIME		9434  /**/
+flag ShutterTime_IsConstraintValid(const ShutterTime* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SHUTTERTIME_2		9441  /**/
+#define i3ds_asn1_ShutterTime_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_ShutterTime_REQUIRED_BITS_FOR_ENCODING        32
+
+flag ShutterTime_Encode(const ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SHUTTERTIME_2		9442  /**/
+flag ShutterTime_Decode(ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraExposure --------------------------------------------*/
+typedef struct {
+    T_UInt32 shutter;
+    T_Float gain;
+
+} CameraExposure;
+
+void CameraExposure_Initialize(CameraExposure* pVal);
+
+#define i3ds_asn1_ERR_CAMERAEXPOSURE		9486  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAEXPOSURE_SHUTTER		9456  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAEXPOSURE_GAIN		9471  /**/
+flag CameraExposure_IsConstraintValid(const CameraExposure* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CAMERAEXPOSURE		9487  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAEXPOSURE_SHUTTER_2_2		9467  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAEXPOSURE_GAIN_2_2		9482  /**/
+#define i3ds_asn1_CameraExposure_REQUIRED_BYTES_FOR_ENCODING       17
+#define i3ds_asn1_CameraExposure_REQUIRED_BITS_FOR_ENCODING        136
+
+flag CameraExposure_Encode(const CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CAMERAEXPOSURE		9488  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAEXPOSURE_SHUTTER_2_2		9468  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAEXPOSURE_GAIN_2_2		9483  /**/
+flag CameraExposure_Decode(CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraAutoExposure --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    T_UInt32 max_shutter;
+    T_Float max_gain;
+
+} CameraAutoExposure;
+
+void CameraAutoExposure_Initialize(CameraAutoExposure* pVal);
+
+#define i3ds_asn1_ERR_CAMERAAUTOEXPOSURE		9534  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAAUTOEXPOSURE_ENABLE		9493  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAAUTOEXPOSURE_MAX_SHUTTER		9504  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAAUTOEXPOSURE_MAX_GAIN		9519  /**/
+flag CameraAutoExposure_IsConstraintValid(const CameraAutoExposure* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE		9535  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE_ENABLE_2		9500  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE_MAX_SHUTTER_2_2		9515  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAAUTOEXPOSURE_MAX_GAIN_2_2		9530  /**/
+#define i3ds_asn1_CameraAutoExposure_REQUIRED_BYTES_FOR_ENCODING       18
+#define i3ds_asn1_CameraAutoExposure_REQUIRED_BITS_FOR_ENCODING        137
+
+flag CameraAutoExposure_Encode(const CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CAMERAAUTOEXPOSURE		9536  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAAUTOEXPOSURE_ENABLE_2		9501  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAAUTOEXPOSURE_MAX_SHUTTER_2_2		9516  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAAUTOEXPOSURE_MAX_GAIN_2_2		9531  /**/
+flag CameraAutoExposure_Decode(CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraFlash --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    T_UInt8 strength;
+
+} CameraFlash;
+
+void CameraFlash_Initialize(CameraFlash* pVal);
+
+#define i3ds_asn1_ERR_CAMERAFLASH		9578  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAFLASH_ENABLE		9552  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAFLASH_STRENGTH		9563  /**/
+flag CameraFlash_IsConstraintValid(const CameraFlash* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CAMERAFLASH		9579  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAFLASH_ENABLE_2		9559  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAFLASH_STRENGTH_2_2		9574  /**/
+#define i3ds_asn1_CameraFlash_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_CameraFlash_REQUIRED_BITS_FOR_ENCODING        9
+
+flag CameraFlash_Encode(const CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CAMERAFLASH		9580  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAFLASH_ENABLE_2		9560  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAFLASH_STRENGTH_2_2		9575  /**/
+flag CameraFlash_Decode(CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PlanarRegion region;
+
+} CameraRegion;
+
+void CameraRegion_Initialize(CameraRegion* pVal);
+
+#define i3ds_asn1_ERR_CAMERAREGION		9651  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_ENABLE		9585  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION		9640  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_OFFSET_X		9596  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_OFFSET_Y		9607  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_SIZE_X		9618  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_SIZE_Y		9629  /**/
+flag CameraRegion_IsConstraintValid(const CameraRegion* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CAMERAREGION		9652  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAREGION_ENABLE_2		9592  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAREGION_REGION_2		9647  /**/
+#define i3ds_asn1_CameraRegion_REQUIRED_BYTES_FOR_ENCODING       9
+#define i3ds_asn1_CameraRegion_REQUIRED_BITS_FOR_ENCODING        65
+
+flag CameraRegion_Encode(const CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CAMERAREGION		9653  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAREGION_ENABLE_2		9593  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAREGION_REGION_2		9648  /**/
+flag CameraRegion_Decode(CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraPattern --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    T_UInt16 pattern_sequence;
+
+} CameraPattern;
+
+void CameraPattern_Initialize(CameraPattern* pVal);
+
+#define i3ds_asn1_ERR_CAMERAPATTERN		9706  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAPATTERN_ENABLE		9680  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERAPATTERN_PATTERN_SEQUENCE		9691  /**/
+flag CameraPattern_IsConstraintValid(const CameraPattern* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CAMERAPATTERN		9707  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAPATTERN_ENABLE_2		9687  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERAPATTERN_PATTERN_SEQUENCE_2_2		9702  /**/
+#define i3ds_asn1_CameraPattern_REQUIRED_BYTES_FOR_ENCODING       3
+#define i3ds_asn1_CameraPattern_REQUIRED_BITS_FOR_ENCODING        17
+
+flag CameraPattern_Encode(const CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CAMERAPATTERN		9708  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAPATTERN_ENABLE_2		9688  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERAPATTERN_PATTERN_SEQUENCE_2_2		9703  /**/
+flag CameraPattern_Decode(CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CameraConfiguration --------------------------------------------*/
+typedef struct {
+    T_UInt32 shutter;
+    T_Float gain;
+    T_Boolean auto_exposure_enabled;
+    T_UInt32 max_shutter;
+    T_Float max_gain;
+    T_Boolean region_enabled;
+    PlanarRegion region;
+    T_Boolean flash_enabled;
+    T_UInt8 flash_strength;
+    T_Boolean pattern_enabled;
+    T_UInt16 pattern_sequence;
+
+} CameraConfiguration;
+
+void CameraConfiguration_Initialize(CameraConfiguration* pVal);
+
+#define i3ds_asn1_ERR_CAMERACONFIGURATION		9902  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_SHUTTER		9713  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_GAIN		9728  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_AUTO_EXPOSURE_ENABLED		9743  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_MAX_SHUTTER		9754  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_MAX_GAIN		9769  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_ENABLED		9784  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION		9839  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_OFFSET_X		9795  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_OFFSET_Y		9806  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_SIZE_X		9817  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_SIZE_Y		9828  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_FLASH_ENABLED		9850  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_FLASH_STRENGTH		9861  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_PATTERN_ENABLED		9876  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_PATTERN_SEQUENCE		9887  /**/
+flag CameraConfiguration_IsConstraintValid(const CameraConfiguration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION		9903  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_SHUTTER_2_2		9724  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_GAIN_2_2		9739  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_AUTO_EXPOSURE_ENABLED_2		9750  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_MAX_SHUTTER_2_2		9765  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_MAX_GAIN_2_2		9780  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_REGION_ENABLED_2		9791  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_REGION_2		9846  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_FLASH_ENABLED_2		9857  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_FLASH_STRENGTH_2_2		9872  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_PATTERN_ENABLED_2		9883  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CAMERACONFIGURATION_PATTERN_SEQUENCE_2_2		9898  /**/
+#define i3ds_asn1_CameraConfiguration_REQUIRED_BYTES_FOR_ENCODING       46
+#define i3ds_asn1_CameraConfiguration_REQUIRED_BITS_FOR_ENCODING        364
+
+flag CameraConfiguration_Encode(const CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION		9904  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_SHUTTER_2_2		9725  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_GAIN_2_2		9740  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_AUTO_EXPOSURE_ENABLED_2		9751  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_MAX_SHUTTER_2_2		9766  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_MAX_GAIN_2_2		9781  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_REGION_ENABLED_2		9792  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_REGION_2		9847  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_FLASH_ENABLED_2		9858  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_FLASH_STRENGTH_2_2		9873  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_PATTERN_ENABLED_2		9884  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CAMERACONFIGURATION_PATTERN_SEQUENCE_2_2		9899  /**/
+flag CameraConfiguration_Decode(CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Common.hpp b/generated/include/i3ds_asn1/Common.hpp
new file mode 100644
index 0000000..c1e762d
--- /dev/null
+++ b/generated/include/i3ds_asn1/Common.hpp
@@ -0,0 +1,140 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Common_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Common_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_Int64 Timepoint;
+
+
+void Timepoint_Initialize(Timepoint* pVal);
+
+#define i3ds_asn1_ERR_TIMEPOINT		8527  /**/
+flag Timepoint_IsConstraintValid(const Timepoint* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TIMEPOINT_2		8534  /**/
+#define i3ds_asn1_Timepoint_REQUIRED_BYTES_FOR_ENCODING       8
+#define i3ds_asn1_Timepoint_REQUIRED_BITS_FOR_ENCODING        64
+
+flag Timepoint_Encode(const Timepoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TIMEPOINT_2		8535  /**/
+flag Timepoint_Decode(Timepoint* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint NodeID;
+
+
+void NodeID_Initialize(NodeID* pVal);
+
+#define i3ds_asn1_ERR_NODEID		8513  /**/
+flag NodeID_IsConstraintValid(const NodeID* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_NODEID		8514  /**/
+#define i3ds_asn1_NodeID_REQUIRED_BYTES_FOR_ENCODING       3
+#define i3ds_asn1_NodeID_REQUIRED_BITS_FOR_ENCODING        24
+
+flag NodeID_Encode(const NodeID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_NODEID		8515  /**/
+flag NodeID_Decode(NodeID* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint EndpointID;
+
+
+void EndpointID_Initialize(EndpointID* pVal);
+
+#define i3ds_asn1_ERR_ENDPOINTID		8520  /**/
+flag EndpointID_IsConstraintValid(const EndpointID* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_ENDPOINTID		8521  /**/
+#define i3ds_asn1_EndpointID_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_EndpointID_REQUIRED_BITS_FOR_ENCODING        8
+
+flag EndpointID_Encode(const EndpointID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_ENDPOINTID		8522  /**/
+flag EndpointID_Decode(EndpointID* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    success = 0,
+    error_node_id = 1,
+    error_endpoint_id = 2,
+    error_unsupported = 3,
+    error_state = 4,
+    error_value = 5,
+    error_other = 6
+} ResultCode;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_ResultCode_success success
+#define i3ds_asn1_ResultCode_error_node_id error_node_id
+#define i3ds_asn1_ResultCode_error_endpoint_id error_endpoint_id
+#define i3ds_asn1_ResultCode_error_unsupported error_unsupported
+#define i3ds_asn1_ResultCode_error_state error_state
+#define i3ds_asn1_ResultCode_error_value error_value
+#define i3ds_asn1_ResultCode_error_other error_other
+
+void ResultCode_Initialize(ResultCode* pVal);
+
+#define i3ds_asn1_ERR_RESULTCODE		8538  /**/
+flag ResultCode_IsConstraintValid(const ResultCode* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_RESULTCODE		8539  /**/
+#define i3ds_asn1_ResultCode_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_ResultCode_REQUIRED_BITS_FOR_ENCODING        3
+
+flag ResultCode_Encode(const ResultCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_RESULTCODE		8540  /**/
+flag ResultCode_Decode(ResultCode* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- CommandResponse --------------------------------------------*/
+typedef struct {
+    ResultCode result;
+    T_String message;
+
+} CommandResponse;
+
+void CommandResponse_Initialize(CommandResponse* pVal);
+
+#define i3ds_asn1_ERR_COMMANDRESPONSE		8567  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_COMMANDRESPONSE_RESULT		8545  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_COMMANDRESPONSE_MESSAGE		8556  /**/
+flag CommandResponse_IsConstraintValid(const CommandResponse* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_COMMANDRESPONSE		8568  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_COMMANDRESPONSE_RESULT_2		8552  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_COMMANDRESPONSE_MESSAGE_2		8563  /**/
+#define i3ds_asn1_CommandResponse_REQUIRED_BYTES_FOR_ENCODING       42
+#define i3ds_asn1_CommandResponse_REQUIRED_BITS_FOR_ENCODING        329
+
+flag CommandResponse_Encode(const CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_COMMANDRESPONSE		8569  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_COMMANDRESPONSE_RESULT_2		8553  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_COMMANDRESPONSE_MESSAGE_2		8564  /**/
+flag CommandResponse_Decode(CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/DepthMap.hpp b/generated/include/i3ds_asn1/DepthMap.hpp
new file mode 100644
index 0000000..9aa891b
--- /dev/null
+++ b/generated/include/i3ds_asn1/DepthMap.hpp
@@ -0,0 +1,105 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_DepthMap_H
+#define i3ds_asn1_GENERATED_ASN1SCC_DepthMap_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/Region.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    depth_f = 0
+} Depth_format_t;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Depth_format_t_depth_f depth_f
+
+void Depth_format_t_Initialize(Depth_format_t* pVal);
+
+#define i3ds_asn1_ERR_DEPTH_FORMAT_T		8874  /**/
+flag Depth_format_t_IsConstraintValid(const Depth_format_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_DEPTH_FORMAT_T		8875  /**/
+#define i3ds_asn1_Depth_format_t_REQUIRED_BYTES_FOR_ENCODING       0
+#define i3ds_asn1_Depth_format_t_REQUIRED_BITS_FOR_ENCODING        0
+
+flag Depth_format_t_Encode(const Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_DEPTH_FORMAT_T		8876  /**/
+flag Depth_format_t_Decode(Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- DepthMapDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Depth_format_t depth_format;
+    T_UInt8 depth_size;
+    T_UInt16 width;
+    T_UInt16 height;
+
+} DepthMapDescriptor;
+
+void DepthMapDescriptor_Initialize(DepthMapDescriptor* pVal);
+
+#define i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR		9046  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES		8991  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_TIMESTAMP		8881  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_VALIDITY		8896  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		8984  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		8973  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		8907  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		8962  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		8918  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		8929  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		8940  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		8951  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT		9002  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_DEPTH_SIZE		9013  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_WIDTH		9024  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_HEIGHT		9035  /**/
+flag DepthMapDescriptor_IsConstraintValid(const DepthMapDescriptor* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR		9047  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_ATTRIBUTES_2		8998  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT_2		9009  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_DEPTH_SIZE_2		9020  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_WIDTH_2		9031  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_DEPTHMAPDESCRIPTOR_HEIGHT_2		9042  /**/
+#define i3ds_asn1_DepthMapDescriptor_REQUIRED_BYTES_FOR_ENCODING       71
+#define i3ds_asn1_DepthMapDescriptor_REQUIRED_BITS_FOR_ENCODING        565
+
+flag DepthMapDescriptor_Encode(const DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR		9048  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_ATTRIBUTES_2		8999  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT_2		9010  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_DEPTH_SIZE_2		9021  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_WIDTH_2		9032  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_DEPTHMAPDESCRIPTOR_HEIGHT_2		9043  /**/
+flag DepthMapDescriptor_Decode(DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Flash.hpp b/generated/include/i3ds_asn1/Flash.hpp
new file mode 100644
index 0000000..8c27f4a
--- /dev/null
+++ b/generated/include/i3ds_asn1/Flash.hpp
@@ -0,0 +1,60 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Flash_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Flash_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Camera.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- FlashSetup --------------------------------------------*/
+typedef struct {
+    T_UInt32 duration;
+    T_UInt8 strength;
+
+} FlashSetup;
+
+void FlashSetup_Initialize(FlashSetup* pVal);
+
+#define i3ds_asn1_ERR_FLASHSETUP		11709  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FLASHSETUP_DURATION		11679  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FLASHSETUP_STRENGTH		11694  /**/
+flag FlashSetup_IsConstraintValid(const FlashSetup* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_FLASHSETUP		11710  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FLASHSETUP_DURATION_2_2		11690  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FLASHSETUP_STRENGTH_2_2		11705  /**/
+#define i3ds_asn1_FlashSetup_REQUIRED_BYTES_FOR_ENCODING       5
+#define i3ds_asn1_FlashSetup_REQUIRED_BITS_FOR_ENCODING        40
+
+flag FlashSetup_Encode(const FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_FLASHSETUP		11711  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FLASHSETUP_DURATION_2_2		11691  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FLASHSETUP_STRENGTH_2_2		11706  /**/
+flag FlashSetup_Decode(FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Frame.hpp b/generated/include/i3ds_asn1/Frame.hpp
new file mode 100644
index 0000000..dc5a615
--- /dev/null
+++ b/generated/include/i3ds_asn1/Frame.hpp
@@ -0,0 +1,139 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Frame_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Frame_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    mode_undefined = 0,
+    mode_mono = 1,
+    mode_rgb = 2,
+    mode_bgr = 3,
+    mode_uyvy = 4,
+    mode_rgba = 5,
+    mode_bayer_rggb = 6,
+    mode_bayer_grbg = 7,
+    mode_bayer_bggr = 8,
+    mode_bayer_gbrg = 9,
+    mode_pjpg = 10,
+    mode_jpeg = 11,
+    mode_png = 12,
+    mode_tiff = 13
+} Frame_mode_t;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Frame_mode_t_mode_undefined mode_undefined
+#define i3ds_asn1_Frame_mode_t_mode_mono mode_mono
+#define i3ds_asn1_Frame_mode_t_mode_rgb mode_rgb
+#define i3ds_asn1_Frame_mode_t_mode_bgr mode_bgr
+#define i3ds_asn1_Frame_mode_t_mode_uyvy mode_uyvy
+#define i3ds_asn1_i3ds_asn1_Frame_mode_t_mode_rgba mode_rgba
+#define i3ds_asn1_Frame_mode_t_mode_bayer_rggb mode_bayer_rggb
+#define i3ds_asn1_Frame_mode_t_mode_bayer_grbg mode_bayer_grbg
+#define i3ds_asn1_Frame_mode_t_mode_bayer_bggr mode_bayer_bggr
+#define i3ds_asn1_Frame_mode_t_mode_bayer_gbrg mode_bayer_gbrg
+#define i3ds_asn1_Frame_mode_t_mode_pjpg mode_pjpg
+#define i3ds_asn1_Frame_mode_t_mode_jpeg mode_jpeg
+#define i3ds_asn1_Frame_mode_t_mode_png mode_png
+#define i3ds_asn1_Frame_mode_t_mode_tiff mode_tiff
+
+void Frame_mode_t_Initialize(Frame_mode_t* pVal);
+
+#define i3ds_asn1_ERR_FRAME_MODE_T		9909  /**/
+flag Frame_mode_t_IsConstraintValid(const Frame_mode_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_FRAME_MODE_T		9910  /**/
+#define i3ds_asn1_Frame_mode_t_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Frame_mode_t_REQUIRED_BITS_FOR_ENCODING        4
+
+flag Frame_mode_t_Encode(const Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_FRAME_MODE_T		9911  /**/
+flag Frame_mode_t_Decode(Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- FrameDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Frame_mode_t frame_mode;
+    T_UInt8 data_depth;
+    T_UInt8 pixel_size;
+    PlanarRegion region;
+    T_UInt8 image_count;
+
+} FrameDescriptor;
+
+void FrameDescriptor_Initialize(FrameDescriptor* pVal);
+
+#define i3ds_asn1_ERR_FRAMEDESCRIPTOR		10136  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES		10026  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_TIMESTAMP		9916  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_VALIDITY		9931  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		10019  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		10008  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		9942  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		9997  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		9953  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		9964  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		9975  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		9986  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_FRAME_MODE		10037  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_DATA_DEPTH		10048  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_PIXEL_SIZE		10059  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION		10114  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_OFFSET_X		10070  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_OFFSET_Y		10081  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_SIZE_X		10092  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_SIZE_Y		10103  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_IMAGE_COUNT		10125  /**/
+flag FrameDescriptor_IsConstraintValid(const FrameDescriptor* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_FRAMEDESCRIPTOR		10137  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FRAMEDESCRIPTOR_ATTRIBUTES_2		10033  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FRAMEDESCRIPTOR_FRAME_MODE_2		10044  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FRAMEDESCRIPTOR_DATA_DEPTH_2		10055  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FRAMEDESCRIPTOR_PIXEL_SIZE_2		10066  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FRAMEDESCRIPTOR_REGION_2		10121  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_FRAMEDESCRIPTOR_IMAGE_COUNT_2		10132  /**/
+#define i3ds_asn1_FrameDescriptor_REQUIRED_BYTES_FOR_ENCODING       78
+#define i3ds_asn1_FrameDescriptor_REQUIRED_BITS_FOR_ENCODING        617
+
+flag FrameDescriptor_Encode(const FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_FRAMEDESCRIPTOR		10138  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FRAMEDESCRIPTOR_ATTRIBUTES_2		10034  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FRAMEDESCRIPTOR_FRAME_MODE_2		10045  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FRAMEDESCRIPTOR_DATA_DEPTH_2		10056  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FRAMEDESCRIPTOR_PIXEL_SIZE_2		10067  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FRAMEDESCRIPTOR_REGION_2		10122  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_FRAMEDESCRIPTOR_IMAGE_COUNT_2		10133  /**/
+flag FrameDescriptor_Decode(FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/IMU.hpp b/generated/include/i3ds_asn1/IMU.hpp
new file mode 100644
index 0000000..c4486e8
--- /dev/null
+++ b/generated/include/i3ds_asn1/IMU.hpp
@@ -0,0 +1,136 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_IMU_H
+#define i3ds_asn1_GENERATED_ASN1SCC_IMU_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Sensor.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- IMUSample --------------------------------------------*/
+typedef struct {
+    T_Double axis_x_rate;
+    T_Double axis_x_acceleration;
+    T_Double axis_y_rate;
+    T_Double axis_y_acceleration;
+    T_Double axis_z_rate;
+    T_Double axis_z_acceleration;
+
+} IMUSample;
+
+void IMUSample_Initialize(IMUSample* pVal);
+
+#define i3ds_asn1_ERR_IMUSAMPLE		8640  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_X_RATE		8574  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_X_ACCELERATION		8585  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Y_RATE		8596  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Y_ACCELERATION		8607  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Z_RATE		8618  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Z_ACCELERATION		8629  /**/
+flag IMUSample_IsConstraintValid(const IMUSample* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_IMUSAMPLE		8641  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUSAMPLE_AXIS_X_RATE_2		8581  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUSAMPLE_AXIS_X_ACCELERATION_2		8592  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Y_RATE_2		8603  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Y_ACCELERATION_2		8614  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Z_RATE_2		8625  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUSAMPLE_AXIS_Z_ACCELERATION_2		8636  /**/
+#define i3ds_asn1_IMUSample_REQUIRED_BYTES_FOR_ENCODING       78
+#define i3ds_asn1_IMUSample_REQUIRED_BITS_FOR_ENCODING        624
+
+flag IMUSample_Encode(const IMUSample* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_IMUSAMPLE		8642  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUSAMPLE_AXIS_X_RATE_2		8582  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUSAMPLE_AXIS_X_ACCELERATION_2		8593  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUSAMPLE_AXIS_Y_RATE_2		8604  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUSAMPLE_AXIS_Y_ACCELERATION_2		8615  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUSAMPLE_AXIS_Z_RATE_2		8626  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUSAMPLE_AXIS_Z_ACCELERATION_2		8637  /**/
+flag IMUSample_Decode(IMUSample* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- IMUMeasurement20 --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    IMUSample arr[20];
+} IMUMeasurement20_samples;
+typedef struct {
+    SampleAttributes attributes;
+    IMUMeasurement20_samples samples;
+    T_UInt32 batch_size;
+
+} IMUMeasurement20;
+
+void IMUMeasurement20_samples_Initialize(IMUMeasurement20_samples* pVal);
+void IMUMeasurement20_Initialize(IMUMeasurement20* pVal);
+
+#define i3ds_asn1_ERR_IMUMEASUREMENT20		8867  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES		8757  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_TIMESTAMP		8647  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_VALIDITY		8662  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES		8750  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM		8739  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		8673  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		8728  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		8684  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		8695  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		8706  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		8717  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES		8845  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM		8834  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_RATE		8768  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_ACCELERATION		8779  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_RATE		8790  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_ACCELERATION		8801  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_RATE		8812  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_ACCELERATION		8823  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_BATCH_SIZE		8852  /**/
+flag IMUMeasurement20_IsConstraintValid(const IMUMeasurement20* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_IMUMEASUREMENT20		8868  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUMEASUREMENT20_ATTRIBUTES_2		8764  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUMEASUREMENT20_SAMPLES		8846  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUMEASUREMENT20_SAMPLES_ELM_2		8841  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_IMUMEASUREMENT20_BATCH_SIZE_2_2		8863  /**/
+#define i3ds_asn1_IMUMeasurement20_REQUIRED_BYTES_FOR_ENCODING       1631
+#define i3ds_asn1_IMUMeasurement20_REQUIRED_BITS_FOR_ENCODING        13042
+
+flag IMUMeasurement20_Encode(const IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_IMUMEASUREMENT20		8869  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUMEASUREMENT20_ATTRIBUTES_2		8765  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUMEASUREMENT20_SAMPLES		8847  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUMEASUREMENT20_SAMPLES_ELM_2		8842  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUMEASUREMENT20_BATCH_SIZE_2_2		8864  /**/
+flag IMUMeasurement20_Decode(IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/LIDAR.hpp b/generated/include/i3ds_asn1/LIDAR.hpp
new file mode 100644
index 0000000..be220d7
--- /dev/null
+++ b/generated/include/i3ds_asn1/LIDAR.hpp
@@ -0,0 +1,95 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_LIDAR_H
+#define i3ds_asn1_GENERATED_ASN1SCC_LIDAR_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- LIDARRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PolarRegion region;
+
+} LIDARRegion;
+
+void LIDARRegion_Initialize(LIDARRegion* pVal);
+
+#define i3ds_asn1_ERR_LIDARREGION		10209  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_ENABLE		10143  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION		10198  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_OFFSET_X		10154  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_OFFSET_Y		10165  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_SIZE_X		10176  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_SIZE_Y		10187  /**/
+flag LIDARRegion_IsConstraintValid(const LIDARRegion* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_LIDARREGION		10210  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_LIDARREGION_ENABLE_2		10150  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_LIDARREGION_REGION_2		10205  /**/
+#define i3ds_asn1_LIDARRegion_REQUIRED_BYTES_FOR_ENCODING       53
+#define i3ds_asn1_LIDARRegion_REQUIRED_BITS_FOR_ENCODING        417
+
+flag LIDARRegion_Encode(const LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_LIDARREGION		10211  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_LIDARREGION_ENABLE_2		10151  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_LIDARREGION_REGION_2		10206  /**/
+flag LIDARRegion_Decode(LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- LIDARConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean region_enabled;
+    PolarRegion region;
+
+} LIDARConfiguration;
+
+void LIDARConfiguration_Initialize(LIDARConfiguration* pVal);
+
+#define i3ds_asn1_ERR_LIDARCONFIGURATION		10282  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_ENABLED		10216  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION		10271  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_OFFSET_X		10227  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_OFFSET_Y		10238  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_SIZE_X		10249  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_SIZE_Y		10260  /**/
+flag LIDARConfiguration_IsConstraintValid(const LIDARConfiguration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_LIDARCONFIGURATION		10283  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_LIDARCONFIGURATION_REGION_ENABLED_2		10223  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_LIDARCONFIGURATION_REGION_2		10278  /**/
+#define i3ds_asn1_LIDARConfiguration_REQUIRED_BYTES_FOR_ENCODING       53
+#define i3ds_asn1_LIDARConfiguration_REQUIRED_BITS_FOR_ENCODING        417
+
+flag LIDARConfiguration_Encode(const LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_LIDARCONFIGURATION		10284  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_LIDARCONFIGURATION_REGION_ENABLED_2		10224  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_LIDARCONFIGURATION_REGION_2		10279  /**/
+flag LIDARConfiguration_Decode(LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/PointCloud.hpp b/generated/include/i3ds_asn1/PointCloud.hpp
new file mode 100644
index 0000000..dd7832d
--- /dev/null
+++ b/generated/include/i3ds_asn1/PointCloud.hpp
@@ -0,0 +1,105 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_PointCloud_H
+#define i3ds_asn1_GENERATED_ASN1SCC_PointCloud_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/Region.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    fields_xyz_f = 0
+} Point_format_t;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Point_format_t_fields_xyz_f fields_xyz_f
+
+void Point_format_t_Initialize(Point_format_t* pVal);
+
+#define i3ds_asn1_ERR_POINT_FORMAT_T		9053  /**/
+flag Point_format_t_IsConstraintValid(const Point_format_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POINT_FORMAT_T		9054  /**/
+#define i3ds_asn1_Point_format_t_REQUIRED_BYTES_FOR_ENCODING       0
+#define i3ds_asn1_Point_format_t_REQUIRED_BITS_FOR_ENCODING        0
+
+flag Point_format_t_Encode(const Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POINT_FORMAT_T		9055  /**/
+flag Point_format_t_Decode(Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PointCloudDescriptor --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Point_format_t point_format;
+    T_UInt16 point_size;
+    T_UInt32 width;
+    T_UInt32 height;
+
+} PointCloudDescriptor;
+
+void PointCloudDescriptor_Initialize(PointCloudDescriptor* pVal);
+
+#define i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR		9225  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES		9170  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_TIMESTAMP		9060  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_VALIDITY		9075  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES		9163  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM		9152  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		9086  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		9141  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		9097  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		9108  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		9119  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		9130  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_POINT_FORMAT		9181  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_POINT_SIZE		9192  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_WIDTH		9203  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_HEIGHT		9214  /**/
+flag PointCloudDescriptor_IsConstraintValid(const PointCloudDescriptor* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR		9226  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_ATTRIBUTES_2		9177  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_POINT_FORMAT_2		9188  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_POINT_SIZE_2		9199  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_WIDTH_2		9210  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POINTCLOUDDESCRIPTOR_HEIGHT_2		9221  /**/
+#define i3ds_asn1_PointCloudDescriptor_REQUIRED_BYTES_FOR_ENCODING       76
+#define i3ds_asn1_PointCloudDescriptor_REQUIRED_BITS_FOR_ENCODING        605
+
+flag PointCloudDescriptor_Encode(const PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR		9227  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_ATTRIBUTES_2		9178  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_POINT_FORMAT_2		9189  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_POINT_SIZE_2		9200  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_WIDTH_2		9211  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POINTCLOUDDESCRIPTOR_HEIGHT_2		9222  /**/
+flag PointCloudDescriptor_Decode(PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/PoseEstimator.hpp b/generated/include/i3ds_asn1/PoseEstimator.hpp
new file mode 100644
index 0000000..79606d2
--- /dev/null
+++ b/generated/include/i3ds_asn1/PoseEstimator.hpp
@@ -0,0 +1,149 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_PoseEstimator_H
+#define i3ds_asn1_GENERATED_ASN1SCC_PoseEstimator_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/base.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- PoseEstimatorMeasurement --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Base_Pose estimated_pose;
+
+} PoseEstimatorMeasurement;
+
+void PoseEstimatorMeasurement_Initialize(PoseEstimatorMeasurement* pVal);
+
+#define i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT		10555  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES		10464  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_TIMESTAMP		10354  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_VALIDITY		10369  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES		10457  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM		10446  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		10380  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		10435  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		10391  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		10402  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		10413  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		10424  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE		10544  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION		10493  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA		10486  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA_ELM		10475  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION		10533  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM		10515  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM_ELM		10504  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_RE		10522  /**/
+flag PoseEstimatorMeasurement_IsConstraintValid(const PoseEstimatorMeasurement* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORMEASUREMENT		10556  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORMEASUREMENT_ATTRIBUTES_2		10471  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_2		10551  /**/
+#define i3ds_asn1_PoseEstimatorMeasurement_REQUIRED_BYTES_FOR_ENCODING       158
+#define i3ds_asn1_PoseEstimatorMeasurement_REQUIRED_BITS_FOR_ENCODING        1257
+
+flag PoseEstimatorMeasurement_Encode(const PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORMEASUREMENT		10557  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORMEASUREMENT_ATTRIBUTES_2		10472  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_2		10552  /**/
+flag PoseEstimatorMeasurement_Decode(PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PoseEstimatorImagingMode --------------------------------------------*/
+typedef struct {
+    T_Boolean imaging_mode;
+
+} PoseEstimatorImagingMode;
+
+void PoseEstimatorImagingMode_Initialize(PoseEstimatorImagingMode* pVal);
+
+#define i3ds_asn1_ERR_POSEESTIMATORIMAGINGMODE		10300  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORIMAGINGMODE_IMAGING_MODE		10289  /**/
+flag PoseEstimatorImagingMode_IsConstraintValid(const PoseEstimatorImagingMode* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORIMAGINGMODE		10301  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORIMAGINGMODE_IMAGING_MODE_2		10296  /**/
+#define i3ds_asn1_PoseEstimatorImagingMode_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_PoseEstimatorImagingMode_REQUIRED_BITS_FOR_ENCODING        1
+
+flag PoseEstimatorImagingMode_Encode(const PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORIMAGINGMODE		10302  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORIMAGINGMODE_IMAGING_MODE_2		10297  /**/
+flag PoseEstimatorImagingMode_Decode(PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PoseEstimatorCameraSelect --------------------------------------------*/
+typedef struct {
+    T_UInt8 camera_select;
+
+} PoseEstimatorCameraSelect;
+
+void PoseEstimatorCameraSelect_Initialize(PoseEstimatorCameraSelect* pVal);
+
+#define i3ds_asn1_ERR_POSEESTIMATORCAMERASELECT		10318  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORCAMERASELECT_CAMERA_SELECT		10307  /**/
+flag PoseEstimatorCameraSelect_IsConstraintValid(const PoseEstimatorCameraSelect* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORCAMERASELECT		10319  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORCAMERASELECT_CAMERA_SELECT_2		10314  /**/
+#define i3ds_asn1_PoseEstimatorCameraSelect_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_PoseEstimatorCameraSelect_REQUIRED_BITS_FOR_ENCODING        8
+
+flag PoseEstimatorCameraSelect_Encode(const PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORCAMERASELECT		10320  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORCAMERASELECT_CAMERA_SELECT_2		10315  /**/
+flag PoseEstimatorCameraSelect_Decode(PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PoseEstimatorConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean imaging_mode;
+    T_UInt8 camera_select;
+
+} PoseEstimatorConfiguration;
+
+void PoseEstimatorConfiguration_Initialize(PoseEstimatorConfiguration* pVal);
+
+#define i3ds_asn1_ERR_POSEESTIMATORCONFIGURATION		10347  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORCONFIGURATION_IMAGING_MODE		10325  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORCONFIGURATION_CAMERA_SELECT		10336  /**/
+flag PoseEstimatorConfiguration_IsConstraintValid(const PoseEstimatorConfiguration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORCONFIGURATION		10348  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORCONFIGURATION_IMAGING_MODE_2		10332  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POSEESTIMATORCONFIGURATION_CAMERA_SELECT_2		10343  /**/
+#define i3ds_asn1_PoseEstimatorConfiguration_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_PoseEstimatorConfiguration_REQUIRED_BITS_FOR_ENCODING        9
+
+flag PoseEstimatorConfiguration_Encode(const PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORCONFIGURATION		10349  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORCONFIGURATION_IMAGING_MODE_2		10333  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POSEESTIMATORCONFIGURATION_CAMERA_SELECT_2		10344  /**/
+flag PoseEstimatorConfiguration_Decode(PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Power.hpp b/generated/include/i3ds_asn1/Power.hpp
new file mode 100644
index 0000000..ce0803e
--- /dev/null
+++ b/generated/include/i3ds_asn1/Power.hpp
@@ -0,0 +1,73 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Power_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Power_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+
+
+typedef struct {
+
+    T_Boolean arr[16];
+} PowerMask;
+
+void PowerMask_Initialize(PowerMask* pVal);
+
+#define i3ds_asn1_ERR_POWERMASK		11672  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POWERMASK_ELM		11661  /**/
+flag PowerMask_IsConstraintValid(const PowerMask* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POWERMASK		11673  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POWERMASK_ELM_2		11668  /**/
+#define i3ds_asn1_PowerMask_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_PowerMask_REQUIRED_BITS_FOR_ENCODING        16
+
+flag PowerMask_Encode(const PowerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POWERMASK		11674  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POWERMASK_ELM_2		11669  /**/
+flag PowerMask_Decode(PowerMask* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint PowerOutput;
+
+
+void PowerOutput_Initialize(PowerOutput* pVal);
+
+#define i3ds_asn1_ERR_POWEROUTPUT		11654  /**/
+flag PowerOutput_IsConstraintValid(const PowerOutput* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POWEROUTPUT		11655  /**/
+#define i3ds_asn1_PowerOutput_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_PowerOutput_REQUIRED_BITS_FOR_ENCODING        4
+
+flag PowerOutput_Encode(const PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POWEROUTPUT		11656  /**/
+flag PowerOutput_Decode(PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Radar.hpp b/generated/include/i3ds_asn1/Radar.hpp
new file mode 100644
index 0000000..386c5e1
--- /dev/null
+++ b/generated/include/i3ds_asn1/Radar.hpp
@@ -0,0 +1,95 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Radar_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Radar_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- RadarRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PlanarRegion region;
+
+} RadarRegion;
+
+void RadarRegion_Initialize(RadarRegion* pVal);
+
+#define i3ds_asn1_ERR_RADARREGION		10628  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_RADARREGION_ENABLE		10562  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION		10617  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_OFFSET_X		10573  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_OFFSET_Y		10584  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_SIZE_X		10595  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_SIZE_Y		10606  /**/
+flag RadarRegion_IsConstraintValid(const RadarRegion* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_RADARREGION		10629  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_RADARREGION_ENABLE_2		10569  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_RADARREGION_REGION_2		10624  /**/
+#define i3ds_asn1_RadarRegion_REQUIRED_BYTES_FOR_ENCODING       9
+#define i3ds_asn1_RadarRegion_REQUIRED_BITS_FOR_ENCODING        65
+
+flag RadarRegion_Encode(const RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_RADARREGION		10630  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_RADARREGION_ENABLE_2		10570  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_RADARREGION_REGION_2		10625  /**/
+flag RadarRegion_Decode(RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- RadarConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean region_enabled;
+    PlanarRegion region;
+
+} RadarConfiguration;
+
+void RadarConfiguration_Initialize(RadarConfiguration* pVal);
+
+#define i3ds_asn1_ERR_RADARCONFIGURATION		10701  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_ENABLED		10635  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION		10690  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_OFFSET_X		10646  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_OFFSET_Y		10657  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_SIZE_X		10668  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_SIZE_Y		10679  /**/
+flag RadarConfiguration_IsConstraintValid(const RadarConfiguration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_RADARCONFIGURATION		10702  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_RADARCONFIGURATION_REGION_ENABLED_2		10642  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_RADARCONFIGURATION_REGION_2		10697  /**/
+#define i3ds_asn1_RadarConfiguration_REQUIRED_BYTES_FOR_ENCODING       9
+#define i3ds_asn1_RadarConfiguration_REQUIRED_BITS_FOR_ENCODING        65
+
+flag RadarConfiguration_Encode(const RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_RADARCONFIGURATION		10703  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_RADARCONFIGURATION_REGION_ENABLED_2		10643  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_RADARCONFIGURATION_REGION_2		10698  /**/
+flag RadarConfiguration_Decode(RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Region.hpp b/generated/include/i3ds_asn1/Region.hpp
new file mode 100644
index 0000000..4343df9
--- /dev/null
+++ b/generated/include/i3ds_asn1/Region.hpp
@@ -0,0 +1,102 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Region_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Region_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- PlanarRegion --------------------------------------------*/
+typedef struct {
+    T_UInt16 offset_x;
+    T_UInt16 offset_y;
+    T_UInt16 size_x;
+    T_UInt16 size_y;
+
+} PlanarRegion;
+
+void PlanarRegion_Initialize(PlanarRegion* pVal);
+
+#define i3ds_asn1_ERR_PLANARREGION		10752  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_OFFSET_X		10708  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_OFFSET_Y		10719  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_SIZE_X		10730  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_SIZE_Y		10741  /**/
+flag PlanarRegion_IsConstraintValid(const PlanarRegion* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_PLANARREGION		10753  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_PLANARREGION_OFFSET_X_2		10715  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_PLANARREGION_OFFSET_Y_2		10726  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_PLANARREGION_SIZE_X_2		10737  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_PLANARREGION_SIZE_Y_2		10748  /**/
+#define i3ds_asn1_PlanarRegion_REQUIRED_BYTES_FOR_ENCODING       8
+#define i3ds_asn1_PlanarRegion_REQUIRED_BITS_FOR_ENCODING        64
+
+flag PlanarRegion_Encode(const PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_PLANARREGION		10754  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_PLANARREGION_OFFSET_X_2		10716  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_PLANARREGION_OFFSET_Y_2		10727  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_PLANARREGION_SIZE_X_2		10738  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_PLANARREGION_SIZE_Y_2		10749  /**/
+flag PlanarRegion_Decode(PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- PolarRegion --------------------------------------------*/
+typedef struct {
+    T_Float offset_x;
+    T_Float offset_y;
+    T_Float size_x;
+    T_Float size_y;
+
+} PolarRegion;
+
+void PolarRegion_Initialize(PolarRegion* pVal);
+
+#define i3ds_asn1_ERR_POLARREGION		10803  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POLARREGION_OFFSET_X		10759  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POLARREGION_OFFSET_Y		10770  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POLARREGION_SIZE_X		10781  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_POLARREGION_SIZE_Y		10792  /**/
+flag PolarRegion_IsConstraintValid(const PolarRegion* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_POLARREGION		10804  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POLARREGION_OFFSET_X_2		10766  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POLARREGION_OFFSET_Y_2		10777  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POLARREGION_SIZE_X_2		10788  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_POLARREGION_SIZE_Y_2		10799  /**/
+#define i3ds_asn1_PolarRegion_REQUIRED_BYTES_FOR_ENCODING       52
+#define i3ds_asn1_PolarRegion_REQUIRED_BITS_FOR_ENCODING        416
+
+flag PolarRegion_Encode(const PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_POLARREGION		10805  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POLARREGION_OFFSET_X_2		10767  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POLARREGION_OFFSET_Y_2		10778  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POLARREGION_SIZE_X_2		10789  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_POLARREGION_SIZE_Y_2		10800  /**/
+flag PolarRegion_Decode(PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/SampleAttribute.hpp b/generated/include/i3ds_asn1/SampleAttribute.hpp
new file mode 100644
index 0000000..e6f13f2
--- /dev/null
+++ b/generated/include/i3ds_asn1/SampleAttribute.hpp
@@ -0,0 +1,204 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_SampleAttribute_H
+#define i3ds_asn1_GENERATED_ASN1SCC_SampleAttribute_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/Common.hpp>
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum {
+    sample_empty = 0,
+    sample_valid = 1,
+    sample_invalid = 2
+} SampleValidity;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_SampleValidity_sample_empty sample_empty
+#define i3ds_asn1_SampleValidity_sample_valid sample_valid
+#define i3ds_asn1_SampleValidity_sample_invalid sample_invalid
+
+void SampleValidity_Initialize(SampleValidity* pVal);
+
+#define i3ds_asn1_ERR_SAMPLEVALIDITY		10810  /**/
+flag SampleValidity_IsConstraintValid(const SampleValidity* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SAMPLEVALIDITY		10811  /**/
+#define i3ds_asn1_SampleValidity_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_SampleValidity_REQUIRED_BITS_FOR_ENCODING        2
+
+flag SampleValidity_Encode(const SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SAMPLEVALIDITY		10812  /**/
+flag SampleValidity_Decode(SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef struct {
+    int nCount;
+
+    byte arr[8];
+} T_String8;
+
+
+void T_String8_Initialize(T_String8* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_T_STRING8		10817  /**/
+flag T_String8_IsConstraintValid(const T_String8* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_T_STRING8		10818  /**/
+#define i3ds_asn1_T_String8_REQUIRED_BYTES_FOR_ENCODING       9
+#define i3ds_asn1_T_String8_REQUIRED_BITS_FOR_ENCODING        68
+
+flag T_String8_Encode(const T_String8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_T_STRING8		10819  /**/
+flag T_String8_Decode(T_String8* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Attribute_value_t --------------------------------------------*/
+
+typedef enum {
+    Attribute_value_t_NONE,
+    boolean_value_PRESENT,
+    discrete_value_PRESENT,
+    real_value_PRESENT,
+    string_value_PRESENT
+} Attribute_value_t_selection;
+
+
+typedef struct {
+    Attribute_value_t_selection kind;
+
+    union {
+        T_Boolean boolean_value;
+        T_Int64 discrete_value;
+        T_Double real_value;
+        T_String8 string_value;
+    } u;
+} Attribute_value_t;
+
+void Attribute_value_t_Initialize(Attribute_value_t* pVal);
+
+#define i3ds_asn1_ERR_ATTRIBUTE_VALUE_T		10868  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_ATTRIBUTE_VALUE_T_BOOLEAN_VALUE		10824  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_ATTRIBUTE_VALUE_T_DISCRETE_VALUE		10835  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_ATTRIBUTE_VALUE_T_REAL_VALUE		10846  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_ATTRIBUTE_VALUE_T_STRING_VALUE		10857  /**/
+flag Attribute_value_t_IsConstraintValid(const Attribute_value_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T		10869  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_BOOLEAN_VALUE_2		10831  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_DISCRETE_VALUE_2		10842  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_REAL_VALUE_2		10853  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T_STRING_VALUE_2		10864  /**/
+#define i3ds_asn1_Attribute_value_t_REQUIRED_BYTES_FOR_ENCODING       14
+#define i3ds_asn1_Attribute_value_t_REQUIRED_BITS_FOR_ENCODING        106
+
+flag Attribute_value_t_Encode(const Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_ATTRIBUTE_VALUE_T		10870  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_BOOLEAN_VALUE_2		10832  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_DISCRETE_VALUE_2		10843  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_REAL_VALUE_2		10854  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_ATTRIBUTE_VALUE_T_STRING_VALUE_2		10865  /**/
+flag Attribute_value_t_Decode(Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Sample_attribute_t --------------------------------------------*/
+typedef struct {
+    T_UInt8 attribute_key;
+    Attribute_value_t attribute_value;
+
+} Sample_attribute_t;
+
+void Sample_attribute_t_Initialize(Sample_attribute_t* pVal);
+
+#define i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T		10941  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY		10875  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE		10930  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_BOOLEAN_VALUE		10886  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_DISCRETE_VALUE		10897  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_REAL_VALUE		10908  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_STRING_VALUE		10919  /**/
+flag Sample_attribute_t_IsConstraintValid(const Sample_attribute_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SAMPLE_ATTRIBUTE_T		10942  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY_2		10882  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_2		10937  /**/
+#define i3ds_asn1_Sample_attribute_t_REQUIRED_BYTES_FOR_ENCODING       15
+#define i3ds_asn1_Sample_attribute_t_REQUIRED_BITS_FOR_ENCODING        114
+
+flag Sample_attribute_t_Encode(const Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SAMPLE_ATTRIBUTE_T		10943  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY_2		10883  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_2		10938  /**/
+flag Sample_attribute_t_Decode(Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SampleAttributes --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Sample_attribute_t arr[4];
+} SampleAttributes_attributes;
+typedef struct {
+    T_Int64 timestamp;
+    SampleValidity validity;
+    SampleAttributes_attributes attributes;
+
+} SampleAttributes;
+
+void SampleAttributes_attributes_Initialize(SampleAttributes_attributes* pVal);
+void SampleAttributes_Initialize(SampleAttributes* pVal);
+
+#define i3ds_asn1_ERR_SAMPLEATTRIBUTES		11058  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_TIMESTAMP		10948  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_VALIDITY		10963  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES		11051  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM		11040  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		10974  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		11029  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		10985  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		10996  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		11007  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		11018  /**/
+flag SampleAttributes_IsConstraintValid(const SampleAttributes* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SAMPLEATTRIBUTES		11059  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLEATTRIBUTES_TIMESTAMP_2_2		10959  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLEATTRIBUTES_VALIDITY_2		10970  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLEATTRIBUTES_ATTRIBUTES		11052  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_2		11047  /**/
+#define i3ds_asn1_SampleAttributes_REQUIRED_BYTES_FOR_ENCODING       66
+#define i3ds_asn1_SampleAttributes_REQUIRED_BITS_FOR_ENCODING        525
+
+flag SampleAttributes_Encode(const SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SAMPLEATTRIBUTES		11060  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLEATTRIBUTES_TIMESTAMP_2_2		10960  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLEATTRIBUTES_VALIDITY_2		10971  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLEATTRIBUTES_ATTRIBUTES		11053  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_2		11048  /**/
+flag SampleAttributes_Decode(SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Sensor.hpp b/generated/include/i3ds_asn1/Sensor.hpp
new file mode 100644
index 0000000..f8175c3
--- /dev/null
+++ b/generated/include/i3ds_asn1/Sensor.hpp
@@ -0,0 +1,227 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Sensor_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Sensor_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/base.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_UInt32 SamplePeriod;
+
+
+void SamplePeriod_Initialize(SamplePeriod* pVal);
+
+#define i3ds_asn1_ERR_SAMPLEPERIOD		9286  /**/
+flag SamplePeriod_IsConstraintValid(const SamplePeriod* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SAMPLEPERIOD_2		9293  /**/
+#define i3ds_asn1_SamplePeriod_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_SamplePeriod_REQUIRED_BITS_FOR_ENCODING        32
+
+flag SamplePeriod_Encode(const SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SAMPLEPERIOD_2		9294  /**/
+flag SamplePeriod_Decode(SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt32 BatchSize;
+
+
+void BatchSize_Initialize(BatchSize* pVal);
+
+#define i3ds_asn1_ERR_BATCHSIZE		9297  /**/
+flag BatchSize_IsConstraintValid(const BatchSize* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BATCHSIZE_2		9304  /**/
+#define i3ds_asn1_BatchSize_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_BatchSize_REQUIRED_BITS_FOR_ENCODING        32
+
+flag BatchSize_Encode(const BatchSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BATCHSIZE_2		9305  /**/
+flag BatchSize_Decode(BatchSize* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef T_UInt32 BatchCount;
+
+
+void BatchCount_Initialize(BatchCount* pVal);
+
+#define i3ds_asn1_ERR_BATCHCOUNT		9308  /**/
+flag BatchCount_IsConstraintValid(const BatchCount* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BATCHCOUNT_2		9315  /**/
+#define i3ds_asn1_BatchCount_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_BatchCount_REQUIRED_BITS_FOR_ENCODING        32
+
+flag BatchCount_Encode(const BatchCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BATCHCOUNT_2		9316  /**/
+flag BatchCount_Decode(BatchCount* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SampleCommand --------------------------------------------*/
+typedef struct {
+    T_UInt32 period;
+    T_UInt32 batch_size;
+    T_UInt32 batch_count;
+
+} SampleCommand;
+
+void SampleCommand_Initialize(SampleCommand* pVal);
+
+#define i3ds_asn1_ERR_SAMPLECOMMAND		9364  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLECOMMAND_PERIOD		9319  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLECOMMAND_BATCH_SIZE		9334  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SAMPLECOMMAND_BATCH_COUNT		9349  /**/
+flag SampleCommand_IsConstraintValid(const SampleCommand* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SAMPLECOMMAND		9365  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLECOMMAND_PERIOD_2_2		9330  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLECOMMAND_BATCH_SIZE_2_2		9345  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SAMPLECOMMAND_BATCH_COUNT_2_2		9360  /**/
+#define i3ds_asn1_SampleCommand_REQUIRED_BYTES_FOR_ENCODING       12
+#define i3ds_asn1_SampleCommand_REQUIRED_BITS_FOR_ENCODING        96
+
+flag SampleCommand_Encode(const SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SAMPLECOMMAND		9366  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLECOMMAND_PERIOD_2_2		9331  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLECOMMAND_BATCH_SIZE_2_2		9346  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLECOMMAND_BATCH_COUNT_2_2		9361  /**/
+flag SampleCommand_Decode(SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SensorConfiguration --------------------------------------------*/
+typedef struct {
+    T_String device_name;
+    T_UInt32 period;
+    T_UInt32 batch_size;
+    T_UInt32 batch_count;
+
+} SensorConfiguration;
+
+void SensorConfiguration_Initialize(SensorConfiguration* pVal);
+
+#define i3ds_asn1_ERR_SENSORCONFIGURATION		9427  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_DEVICE_NAME		9371  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_PERIOD		9382  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_BATCH_SIZE		9397  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_BATCH_COUNT		9412  /**/
+flag SensorConfiguration_IsConstraintValid(const SensorConfiguration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SENSORCONFIGURATION		9428  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SENSORCONFIGURATION_DEVICE_NAME_2		9378  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SENSORCONFIGURATION_PERIOD_2_2		9393  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SENSORCONFIGURATION_BATCH_SIZE_2_2		9408  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SENSORCONFIGURATION_BATCH_COUNT_2_2		9423  /**/
+#define i3ds_asn1_SensorConfiguration_REQUIRED_BYTES_FOR_ENCODING       53
+#define i3ds_asn1_SensorConfiguration_REQUIRED_BITS_FOR_ENCODING        422
+
+flag SensorConfiguration_Encode(const SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SENSORCONFIGURATION		9429  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SENSORCONFIGURATION_DEVICE_NAME_2		9379  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SENSORCONFIGURATION_PERIOD_2_2		9394  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SENSORCONFIGURATION_BATCH_SIZE_2_2		9409  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SENSORCONFIGURATION_BATCH_COUNT_2_2		9424  /**/
+flag SensorConfiguration_Decode(SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    inactive = 0,
+    standby = 1,
+    operational = 2,
+    failure = 3
+} SensorState;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_SensorState_inactive inactive
+#define i3ds_asn1_SensorState_standby standby
+#define i3ds_asn1_SensorState_operational operational
+#define i3ds_asn1_SensorState_failure failure
+
+void SensorState_Initialize(SensorState* pVal);
+
+#define i3ds_asn1_ERR_SENSORSTATE		9232  /**/
+flag SensorState_IsConstraintValid(const SensorState* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SENSORSTATE		9233  /**/
+#define i3ds_asn1_SensorState_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_SensorState_REQUIRED_BITS_FOR_ENCODING        2
+
+flag SensorState_Encode(const SensorState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SENSORSTATE		9234  /**/
+flag SensorState_Decode(SensorState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- SensorStatus --------------------------------------------*/
+typedef struct {
+    SensorState current_state;
+    Base_Temperature device_temperature;
+
+} SensorStatus;
+
+void SensorStatus_Initialize(SensorStatus* pVal);
+
+#define i3ds_asn1_ERR_SENSORSTATUS		9279  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SENSORSTATUS_CURRENT_STATE		9246  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_SENSORSTATUS_DEVICE_TEMPERATURE		9268  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SENSORSTATUS_DEVICE_TEMPERATURE_KELVIN		9257  /**/
+flag SensorStatus_IsConstraintValid(const SensorStatus* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_SENSORSTATUS		9280  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SENSORSTATUS_CURRENT_STATE_2		9253  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_SENSORSTATUS_DEVICE_TEMPERATURE_2		9275  /**/
+#define i3ds_asn1_SensorStatus_REQUIRED_BYTES_FOR_ENCODING       14
+#define i3ds_asn1_SensorStatus_REQUIRED_BITS_FOR_ENCODING        106
+
+flag SensorStatus_Encode(const SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_SENSORSTATUS		9281  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SENSORSTATUS_CURRENT_STATE_2		9254  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SENSORSTATUS_DEVICE_TEMPERATURE_2		9276  /**/
+flag SensorStatus_Decode(SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    activate = 0,
+    start = 1,
+    stop = 2,
+    deactivate = 3
+} StateCommand;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_StateCommand_activate activate
+#define i3ds_asn1_StateCommand_start start
+#define i3ds_asn1_StateCommand_stop stop
+#define i3ds_asn1_StateCommand_deactivate deactivate
+
+void StateCommand_Initialize(StateCommand* pVal);
+
+#define i3ds_asn1_ERR_STATECOMMAND		9239  /**/
+flag StateCommand_IsConstraintValid(const StateCommand* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_STATECOMMAND		9240  /**/
+#define i3ds_asn1_StateCommand_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_StateCommand_REQUIRED_BITS_FOR_ENCODING        2
+
+flag StateCommand_Encode(const StateCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_STATECOMMAND		9241  /**/
+flag StateCommand_Decode(StateCommand* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/StarTracker.hpp b/generated/include/i3ds_asn1/StarTracker.hpp
new file mode 100644
index 0000000..20eb298
--- /dev/null
+++ b/generated/include/i3ds_asn1/StarTracker.hpp
@@ -0,0 +1,74 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_StarTracker_H
+#define i3ds_asn1_GENERATED_ASN1SCC_StarTracker_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/base.hpp>
+#include <i3ds_asn1/SampleAttribute.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- StarTrackerMeasurement --------------------------------------------*/
+typedef struct {
+    SampleAttributes attributes;
+    Wrappers_Quaterniond position;
+
+} StarTrackerMeasurement;
+
+void StarTrackerMeasurement_Initialize(StarTrackerMeasurement* pVal);
+
+#define i3ds_asn1_ERR_STARTRACKERMEASUREMENT		11226  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES		11175  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_TIMESTAMP		11065  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_VALIDITY		11080  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES		11168  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM		11157  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY		11091  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE		11146  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_BOOLEAN_VALUE		11102  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE		11113  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE		11124  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE		11135  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_POSITION		11215  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_POSITION_IM		11197  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_POSITION_IM_ELM		11186  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_POSITION_RE		11204  /**/
+flag StarTrackerMeasurement_IsConstraintValid(const StarTrackerMeasurement* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_STARTRACKERMEASUREMENT		11227  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_STARTRACKERMEASUREMENT_ATTRIBUTES_2		11182  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_STARTRACKERMEASUREMENT_POSITION_2		11222  /**/
+#define i3ds_asn1_StarTrackerMeasurement_REQUIRED_BYTES_FOR_ENCODING       118
+#define i3ds_asn1_StarTrackerMeasurement_REQUIRED_BITS_FOR_ENCODING        943
+
+flag StarTrackerMeasurement_Encode(const StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_STARTRACKERMEASUREMENT		11228  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_STARTRACKERMEASUREMENT_ATTRIBUTES_2		11183  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_STARTRACKERMEASUREMENT_POSITION_2		11223  /**/
+flag StarTrackerMeasurement_Decode(StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/ToFCamera.hpp b/generated/include/i3ds_asn1/ToFCamera.hpp
new file mode 100644
index 0000000..efa74d7
--- /dev/null
+++ b/generated/include/i3ds_asn1/ToFCamera.hpp
@@ -0,0 +1,130 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_ToFCamera_H
+#define i3ds_asn1_GENERATED_ASN1SCC_ToFCamera_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/Region.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- ToFRange --------------------------------------------*/
+typedef struct {
+    T_Float min_depth;
+    T_Float max_depth;
+
+} ToFRange;
+
+void ToFRange_Initialize(ToFRange* pVal);
+
+#define i3ds_asn1_ERR_TOFRANGE		11328  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TOFRANGE_MIN_DEPTH		11306  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TOFRANGE_MAX_DEPTH		11317  /**/
+flag ToFRange_IsConstraintValid(const ToFRange* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TOFRANGE		11329  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFRANGE_MIN_DEPTH_2		11313  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFRANGE_MAX_DEPTH_2		11324  /**/
+#define i3ds_asn1_ToFRange_REQUIRED_BYTES_FOR_ENCODING       26
+#define i3ds_asn1_ToFRange_REQUIRED_BITS_FOR_ENCODING        208
+
+flag ToFRange_Encode(const ToFRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TOFRANGE		11330  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFRANGE_MIN_DEPTH_2		11314  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFRANGE_MAX_DEPTH_2		11325  /**/
+flag ToFRange_Decode(ToFRange* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ToFRegion --------------------------------------------*/
+typedef struct {
+    T_Boolean enable;
+    PlanarRegion region;
+
+} ToFRegion;
+
+void ToFRegion_Initialize(ToFRegion* pVal);
+
+#define i3ds_asn1_ERR_TOFREGION		11299  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TOFREGION_ENABLE		11233  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION		11288  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_OFFSET_X		11244  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_OFFSET_Y		11255  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_SIZE_X		11266  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_SIZE_Y		11277  /**/
+flag ToFRegion_IsConstraintValid(const ToFRegion* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TOFREGION		11300  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFREGION_ENABLE_2		11240  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFREGION_REGION_2		11295  /**/
+#define i3ds_asn1_ToFRegion_REQUIRED_BYTES_FOR_ENCODING       9
+#define i3ds_asn1_ToFRegion_REQUIRED_BITS_FOR_ENCODING        65
+
+flag ToFRegion_Encode(const ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TOFREGION		11301  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFREGION_ENABLE_2		11241  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFREGION_REGION_2		11296  /**/
+flag ToFRegion_Decode(ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ToFConfiguration --------------------------------------------*/
+typedef struct {
+    T_Boolean region_enabled;
+    PlanarRegion region;
+    T_Float min_depth;
+    T_Float max_depth;
+
+} ToFConfiguration;
+
+void ToFConfiguration_Initialize(ToFConfiguration* pVal);
+
+#define i3ds_asn1_ERR_TOFCONFIGURATION		11423  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_ENABLED		11335  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION		11390  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_OFFSET_X		11346  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_OFFSET_Y		11357  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_SIZE_X		11368  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_SIZE_Y		11379  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_MIN_DEPTH		11401  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_MAX_DEPTH		11412  /**/
+flag ToFConfiguration_IsConstraintValid(const ToFConfiguration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TOFCONFIGURATION		11424  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFCONFIGURATION_REGION_ENABLED_2		11342  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFCONFIGURATION_REGION_2		11397  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFCONFIGURATION_MIN_DEPTH_2		11408  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TOFCONFIGURATION_MAX_DEPTH_2		11419  /**/
+#define i3ds_asn1_ToFConfiguration_REQUIRED_BYTES_FOR_ENCODING       35
+#define i3ds_asn1_ToFConfiguration_REQUIRED_BITS_FOR_ENCODING        273
+
+flag ToFConfiguration_Encode(const ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TOFCONFIGURATION		11425  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFCONFIGURATION_REGION_ENABLED_2		11343  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFCONFIGURATION_REGION_2		11398  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFCONFIGURATION_MIN_DEPTH_2		11409  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TOFCONFIGURATION_MAX_DEPTH_2		11420  /**/
+flag ToFConfiguration_Decode(ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/Trigger.hpp b/generated/include/i3ds_asn1/Trigger.hpp
new file mode 100644
index 0000000..f537278
--- /dev/null
+++ b/generated/include/i3ds_asn1/Trigger.hpp
@@ -0,0 +1,259 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_Trigger_H
+#define i3ds_asn1_GENERATED_ASN1SCC_Trigger_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+
+
+typedef struct {
+
+    T_Boolean arr[8];
+} TriggerMask;
+
+void TriggerMask_Initialize(TriggerMask* pVal);
+
+#define i3ds_asn1_ERR_TRIGGERMASK		11483  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_TRIGGERMASK_ELM		11472  /**/
+flag TriggerMask_IsConstraintValid(const TriggerMask* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TRIGGERMASK		11484  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_TRIGGERMASK_ELM_2		11479  /**/
+#define i3ds_asn1_TriggerMask_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_TriggerMask_REQUIRED_BITS_FOR_ENCODING        8
+
+flag TriggerMask_Encode(const TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TRIGGERMASK		11485  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_TRIGGERMASK_ELM_2		11480  /**/
+flag TriggerMask_Decode(TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerGenerator;
+
+
+void TriggerGenerator_Initialize(TriggerGenerator* pVal);
+
+#define i3ds_asn1_ERR_TRIGGERGENERATOR		11430  /**/
+flag TriggerGenerator_IsConstraintValid(const TriggerGenerator* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TRIGGERGENERATOR		11431  /**/
+#define i3ds_asn1_TriggerGenerator_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_TriggerGenerator_REQUIRED_BITS_FOR_ENCODING        2
+
+flag TriggerGenerator_Encode(const TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TRIGGERGENERATOR		11432  /**/
+flag TriggerGenerator_Decode(TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerInput;
+
+
+void TriggerInput_Initialize(TriggerInput* pVal);
+
+#define i3ds_asn1_ERR_TRIGGERINPUT		11437  /**/
+flag TriggerInput_IsConstraintValid(const TriggerInput* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TRIGGERINPUT		11438  /**/
+#define i3ds_asn1_TriggerInput_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_TriggerInput_REQUIRED_BITS_FOR_ENCODING        2
+
+flag TriggerInput_Encode(const TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TRIGGERINPUT		11439  /**/
+flag TriggerInput_Decode(TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerOutput;
+
+
+void TriggerOutput_Initialize(TriggerOutput* pVal);
+
+#define i3ds_asn1_ERR_TRIGGEROUTPUT		11444  /**/
+flag TriggerOutput_IsConstraintValid(const TriggerOutput* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TRIGGEROUTPUT		11445  /**/
+#define i3ds_asn1_TriggerOutput_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_TriggerOutput_REQUIRED_BITS_FOR_ENCODING        3
+
+flag TriggerOutput_Encode(const TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TRIGGEROUTPUT		11446  /**/
+flag TriggerOutput_Decode(TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerPeriod;
+
+
+void TriggerPeriod_Initialize(TriggerPeriod* pVal);
+
+#define i3ds_asn1_ERR_TRIGGERPERIOD		11451  /**/
+flag TriggerPeriod_IsConstraintValid(const TriggerPeriod* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TRIGGERPERIOD		11452  /**/
+#define i3ds_asn1_TriggerPeriod_REQUIRED_BYTES_FOR_ENCODING       3
+#define i3ds_asn1_TriggerPeriod_REQUIRED_BITS_FOR_ENCODING        24
+
+flag TriggerPeriod_Encode(const TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TRIGGERPERIOD		11453  /**/
+flag TriggerPeriod_Decode(TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- GeneratorSetup --------------------------------------------*/
+typedef struct {
+    TriggerGenerator source;
+    TriggerPeriod period;
+
+} GeneratorSetup;
+
+void GeneratorSetup_Initialize(GeneratorSetup* pVal);
+
+#define i3ds_asn1_ERR_GENERATORSETUP		11512  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_GENERATORSETUP_SOURCE		11490  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_GENERATORSETUP_PERIOD		11501  /**/
+flag GeneratorSetup_IsConstraintValid(const GeneratorSetup* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_GENERATORSETUP		11513  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_GENERATORSETUP_SOURCE_2		11497  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_GENERATORSETUP_PERIOD_2		11508  /**/
+#define i3ds_asn1_GeneratorSetup_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_GeneratorSetup_REQUIRED_BITS_FOR_ENCODING        26
+
+flag GeneratorSetup_Encode(const GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_GENERATORSETUP		11514  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_GENERATORSETUP_SOURCE_2		11498  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_GENERATORSETUP_PERIOD_2		11509  /**/
+flag GeneratorSetup_Decode(GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerOffset;
+
+
+void TriggerOffset_Initialize(TriggerOffset* pVal);
+
+#define i3ds_asn1_ERR_TRIGGEROFFSET		11458  /**/
+flag TriggerOffset_IsConstraintValid(const TriggerOffset* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TRIGGEROFFSET		11459  /**/
+#define i3ds_asn1_TriggerOffset_REQUIRED_BYTES_FOR_ENCODING       3
+#define i3ds_asn1_TriggerOffset_REQUIRED_BITS_FOR_ENCODING        24
+
+flag TriggerOffset_Encode(const TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TRIGGEROFFSET		11460  /**/
+flag TriggerOffset_Decode(TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint TriggerDuration;
+
+
+void TriggerDuration_Initialize(TriggerDuration* pVal);
+
+#define i3ds_asn1_ERR_TRIGGERDURATION		11465  /**/
+flag TriggerDuration_IsConstraintValid(const TriggerDuration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_TRIGGERDURATION		11466  /**/
+#define i3ds_asn1_TriggerDuration_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_TriggerDuration_REQUIRED_BITS_FOR_ENCODING        10
+
+flag TriggerDuration_Encode(const TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_TRIGGERDURATION		11467  /**/
+flag TriggerDuration_Decode(TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ChannelInternal --------------------------------------------*/
+typedef struct {
+    TriggerOutput output_channel;
+    TriggerGenerator source;
+    TriggerOffset offset;
+    TriggerDuration duration;
+    T_Boolean invert;
+
+} ChannelInternal;
+
+void ChannelInternal_Initialize(ChannelInternal* pVal);
+
+#define i3ds_asn1_ERR_CHANNELINTERNAL		11574  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_OUTPUT_CHANNEL		11519  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_SOURCE		11530  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_OFFSET		11541  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_DURATION		11552  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_INVERT		11563  /**/
+flag ChannelInternal_IsConstraintValid(const ChannelInternal* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CHANNELINTERNAL		11575  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELINTERNAL_OUTPUT_CHANNEL_2		11526  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELINTERNAL_SOURCE_2		11537  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELINTERNAL_OFFSET_2		11548  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELINTERNAL_DURATION_2		11559  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELINTERNAL_INVERT_2		11570  /**/
+#define i3ds_asn1_ChannelInternal_REQUIRED_BYTES_FOR_ENCODING       5
+#define i3ds_asn1_ChannelInternal_REQUIRED_BITS_FOR_ENCODING        40
+
+flag ChannelInternal_Encode(const ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CHANNELINTERNAL		11576  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELINTERNAL_OUTPUT_CHANNEL_2		11527  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELINTERNAL_SOURCE_2		11538  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELINTERNAL_OFFSET_2		11549  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELINTERNAL_DURATION_2		11560  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELINTERNAL_INVERT_2		11571  /**/
+flag ChannelInternal_Decode(ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- ChannelExternal --------------------------------------------*/
+typedef struct {
+    TriggerOutput output_channel;
+    TriggerInput source;
+    TriggerOffset offset;
+    TriggerDuration duration;
+    T_Boolean bypass;
+    T_Boolean invert;
+
+} ChannelExternal;
+
+void ChannelExternal_Initialize(ChannelExternal* pVal);
+
+#define i3ds_asn1_ERR_CHANNELEXTERNAL		11647  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_OUTPUT_CHANNEL		11581  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_SOURCE		11592  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_OFFSET		11603  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_DURATION		11614  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_BYPASS		11625  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_INVERT		11636  /**/
+flag ChannelExternal_IsConstraintValid(const ChannelExternal* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_CHANNELEXTERNAL		11648  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELEXTERNAL_OUTPUT_CHANNEL_2		11588  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELEXTERNAL_SOURCE_2		11599  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELEXTERNAL_OFFSET_2		11610  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELEXTERNAL_DURATION_2		11621  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELEXTERNAL_BYPASS_2		11632  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_CHANNELEXTERNAL_INVERT_2		11643  /**/
+#define i3ds_asn1_ChannelExternal_REQUIRED_BYTES_FOR_ENCODING       6
+#define i3ds_asn1_ChannelExternal_REQUIRED_BITS_FOR_ENCODING        41
+
+flag ChannelExternal_Encode(const ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_CHANNELEXTERNAL		11649  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELEXTERNAL_OUTPUT_CHANNEL_2		11589  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELEXTERNAL_SOURCE_2		11600  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELEXTERNAL_OFFSET_2		11611  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELEXTERNAL_DURATION_2		11622  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELEXTERNAL_BYPASS_2		11633  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_CHANNELEXTERNAL_INVERT_2		11644  /**/
+flag ChannelExternal_Decode(ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/asn1crt.hpp b/generated/include/i3ds_asn1/asn1crt.hpp
new file mode 100644
index 0000000..d82f816
--- /dev/null
+++ b/generated/include/i3ds_asn1/asn1crt.hpp
@@ -0,0 +1,175 @@
+#ifndef i3ds_asn1_ASN1SCC_ASN1CRT_H_
+#define i3ds_asn1_ASN1SCC_ASN1CRT_H_
+
+#include <stddef.h>
+namespace i3ds_asn1 {
+
+#if (!defined(_MSC_VER) || _MSC_VER >= 1800)
+#  ifndef SWIG
+#    include <stdbool.h>
+#  endif
+#else
+typedef unsigned char bool;
+#define true 1
+#define false 0
+#endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifndef NULL
+#define NULL	0
+#endif
+
+#ifndef TRUE
+#define TRUE	true
+#endif
+
+#ifndef FALSE
+#define FALSE	false
+#endif
+
+#ifndef i3ds_asn1_WORD_SIZE
+#define i3ds_asn1_WORD_SIZE	8
+#endif
+
+#ifndef FP_i3ds_asn1_WORD_SIZE
+#define FP_i3ds_asn1_WORD_SIZE	8
+#endif
+
+#define i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH	20
+
+typedef float asn1Real32;
+typedef double asn1Real64;
+
+
+
+typedef unsigned char byte;
+
+typedef int asn1SccSint32;
+typedef unsigned int asn1SccUint32;
+
+typedef long long asn1SccSint64;
+typedef unsigned long long asn1SccUint64;
+
+#if i3ds_asn1_WORD_SIZE==8
+typedef asn1SccUint64 asn1SccUint;
+typedef asn1SccSint64 asn1SccSint;
+#else
+typedef asn1SccUint32 asn1SccUint;
+typedef asn1SccSint32 asn1SccSint;
+#endif
+
+#if FP_i3ds_asn1_WORD_SIZE==8
+typedef asn1Real64 asn1Real;
+#else
+typedef asn1Real32 asn1Real;
+#endif
+
+
+#ifdef _MSC_VER
+#  ifndef INFINITY
+#    define INFINITY (DBL_MAX+DBL_MAX)
+#  endif
+#  ifndef NAN
+#    define NAN (INFINITY-INFINITY)
+#  endif
+#endif
+
+typedef bool flag;
+
+typedef char NullType;
+
+typedef struct {
+	byte* buf;
+	long count;
+	long currentByte;
+	/* Next available bit for writting. Possible vallues 0..7, 0 is most significant bit of current byte*/
+	int currentBit;
+} BitStream;
+
+typedef struct {
+	byte* buf;
+	long count;
+	long currentByte;
+	flag EncodeWhiteSpace;
+} ByteStream;
+
+typedef struct {
+	int TokenID;
+	char Value[100];
+} Token;
+
+typedef struct {
+	char Name[50];
+	char Value[100];
+} XmlAttribute;
+
+typedef struct {
+	XmlAttribute attrs[20];
+	int nCount;
+} XmlAttributeArray;
+
+typedef struct {
+	int nCount;
+	asn1SccUint values[i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH];
+} Asn1ObjectIdentifier;
+
+#define i3ds_asn1_ERR_INSUFFICIENT_DATA	101
+#define i3ds_asn1_ERR_INCORRECT_PER_STREAM	102
+#define i3ds_asn1_ERR_INVALID_CHOICE_ALTERNATIVE	103
+#define i3ds_asn1_ERR_INVALID_ENUM_VALUE	104
+#define i3ds_asn1_ERR_INVALID_XML_FILE	200
+#define i3ds_asn1_ERR_INVALID_BER_FILE	201
+#define i3ds_asn1_ERR_BER_LENGTH_MISMATCH	202
+
+
+
+flag OctetString_equal(int len1, int len2, const byte arr1[], const byte arr2[]);
+flag BitString_equal(int nBitsLength1, int nBitsLength2, const byte arr1[], const byte arr2[]);
+void ObjectIdentifier_Init(Asn1ObjectIdentifier *pVal);
+flag ObjectIdentifier_equal(const Asn1ObjectIdentifier *pVal1, const Asn1ObjectIdentifier *pVal2);
+flag ObjectIdentifier_isValid(const Asn1ObjectIdentifier *pVal);
+flag RelativeOID_isValid(const Asn1ObjectIdentifier *pVal);
+
+
+int GetCharIndex(char ch, byte allowedCharSet[], int setLen);
+
+
+
+
+
+
+
+typedef asn1SccUint BerTag;
+
+
+
+
+
+
+#if i3ds_asn1_WORD_SIZE==8
+extern const asn1SccUint64 ber_aux[];
+#else
+extern const asn1SccUint32 ber_aux[];
+#endif
+
+
+
+
+#define i3ds_asn1_CHECK_BIT_STREAM(pBitStrm)	assert((pBitStrm)->currentByte*8+(pBitStrm)->currentBit<=(pBitStrm)->count*8)
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4127)
+#endif
+
+#define i3ds_asn1_ASSERT_OR_RETURN_FALSE(_Expression) do { assert(_Expression); if (!(_Expression)) return FALSE;} while(0)
+
+#ifdef  __cplusplus
+}
+#endif
+
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/asn1crt_encoding.hpp b/generated/include/i3ds_asn1/asn1crt_encoding.hpp
new file mode 100644
index 0000000..1f37c6a
--- /dev/null
+++ b/generated/include/i3ds_asn1/asn1crt_encoding.hpp
@@ -0,0 +1,80 @@
+#ifndef i3ds_asn1_ASN1SCC_ASN1CRT_ENCODING_H_
+#define i3ds_asn1_ASN1SCC_ASN1CRT_ENCODING_H_
+
+#include <i3ds_asn1/asn1crt.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* Bit strean functions */
+
+void BitStream_AppendNBitZero(BitStream* pBitStrm, int nbits);
+void BitStream_EncodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint v);
+void BitStream_AppendNBitOne(BitStream* pBitStrm, int nbits);
+void BitStream_EncodeNonNegativeIntegerNeg(BitStream* pBitStrm, asn1SccUint v, flag negate);
+flag BitStream_DecodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint* v, int nBits);
+flag BitStream_ReadPartialByte(BitStream* pBitStrm, byte *v, byte nbits);
+void BitStream_AppendPartialByte(BitStream* pBitStrm, byte v, byte nbits, flag negate);
+
+
+
+
+
+void BitStream_Init(BitStream* pBitStrm, unsigned char* buf, long count);
+void BitStream_AttachBuffer(BitStream* pBitStrm, unsigned char* buf, long count);
+void BitStream_AppendBit(BitStream* pBitStrm, flag v);
+void BitStream_AppendBits(BitStream* pBitStrm, const byte* srcBuffer, int nBitsToWrite);
+void BitStream_AppendByte(BitStream* pBitStrm, byte v, flag negate);
+void BitStream_AppendByte0(BitStream* pBitStrm, byte v);
+
+
+void ByteStream_Init(ByteStream* pStrm, byte* buf, long count);
+void ByteStream_AttachBuffer(ByteStream* pStrm, unsigned char* buf, long count);
+asn1SccSint ByteStream_GetLength(ByteStream* pStrm);
+
+asn1SccSint BitStream_GetLength(BitStream* pBitStrm);
+void BitStream_AppendBitOne(BitStream* pBitStrm);
+void BitStream_AppendBitZero(BitStream* pBitStrm);
+flag BitStream_ReadBit(BitStream* pBitStrm, flag* v);
+flag BitStream_ReadBits(BitStream* pBitStrm, byte* BuffToWrite, int nBitsToRead);
+flag BitStream_ReadByte(BitStream* pBitStrm, byte* v);
+
+/* Integer functions */
+
+
+void BitStream_EncodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v);
+void BitStream_EncodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min);
+void BitStream_EncodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min);
+void BitStream_EncodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min, asn1SccSint max);
+void BitStream_EncodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min, asn1SccUint max);
+
+flag BitStream_DecodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v);
+flag BitStream_DecodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min);
+flag BitStream_DecodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min);
+flag BitStream_DecodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min, asn1SccSint max);
+flag BitStream_DecodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min, asn1SccUint max);
+
+asn1SccUint int2uint(asn1SccSint v);
+asn1SccSint uint2int(asn1SccUint v, int uintSizeInBytes);
+
+int GetNumberOfBitsForNonNegativeInteger(asn1SccUint v);
+
+void CalculateMantissaAndExponent(asn1Real d, int* exp, asn1SccUint64* mantissa);
+asn1Real GetDoubleByMantissaAndExp(asn1SccUint mantissa, int exp);
+
+int GetLengthInBytesOfSInt(asn1SccSint v);
+int GetLengthInBytesOfUInt(asn1SccUint64 v);
+
+void BitStream_EncodeReal(BitStream* pBitStrm, asn1Real v);
+flag BitStream_DecodeReal(BitStream* pBitStrm, asn1Real* v);
+
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/asn1crt_encoding_acn.hpp b/generated/include/i3ds_asn1/asn1crt_encoding_acn.hpp
new file mode 100644
index 0000000..9eaaab1
--- /dev/null
+++ b/generated/include/i3ds_asn1/asn1crt_encoding_acn.hpp
@@ -0,0 +1,153 @@
+#ifndef i3ds_asn1_ASN1SCC_ASN1CRT_ENCODING_ACN_H_
+#define i3ds_asn1_ASN1SCC_ASN1CRT_ENCODING_ACN_H_
+
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*
+
+       db         ,ad8888ba,   888b      88           88888888888                                             88                                  
+      d88b       d8"'    `"8b  8888b     88           88                                               ,d     ""                                  
+     d8'`8b     d8'            88 `8b    88           88                                               88                                         
+    d8'  `8b    88             88  `8b   88           88aaaaa  88       88  8b,dPPYba,    ,adPPYba,  MM88MMM  88   ,adPPYba,   8b,dPPYba,   ,adPPYba,
+   d8YaaaaY8b   88             88   `8b  88           88"""""  88       88  88P'   `"8a  a8"     ""    88     88  a8"     "8a  88P'   `"8a  I8[    ""
+  d8""""""""8b  Y8,            88    `8b 88           88       88       88  88       88  8b            88     88  8b       d8  88       88   `"Y8ba,
+ d8'        `8b  Y8a.    .a8P  88     `8888           88       "8a,   ,a88  88       88  "8a,   ,aa    88,    88  "8a,   ,a8"  88       88  aa    ]8I
+d8'          `8b  `"Y8888Y"'   88      `888           88        `"YbbdP'Y8  88       88   `"Ybbd8"'    "Y888  88   `"YbbdP"'   88       88  `"YbbdP"
+*/
+
+void Acn_AlignToNextByte(BitStream* pBitStrm);
+void Acn_AlignToNextWord(BitStream* pBitStrm);
+void Acn_AlignToNextDWord(BitStream* pBitStrm);
+
+/*ACN Integer functions*/
+void Acn_Enc_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBits);
+void Acn_Enc_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal);
+
+void Acn_Enc_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBits);
+void Acn_Enc_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal);
+
+void Acn_Enc_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInNibbles);
+void Acn_Enc_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal); /*encoding ends when 'F' is reached*/
+
+void Acn_Enc_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBytes);
+void Acn_Enc_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal);
+void Acn_Enc_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint intVal, const byte null_characters[], size_t null_characters_size); /*encoding ends when null_character is reached*/
+
+void Acn_Enc_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBytes);
+void Acn_Enc_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal);
+void Acn_Enc_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal, const byte null_characters[], size_t null_characters_size); /*encoding ends when null_character is reached*/
+
+
+/*ACN Decode Integer functions*/
+flag Acn_Dec_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBits);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal);
+
+flag Acn_Dec_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBits);
+flag Acn_Dec_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal);
+
+flag Acn_Dec_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInNibbles);
+flag Acn_Dec_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal);
+/*encoding ends when 'F' is reached*/
+flag Acn_Dec_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal);
+
+flag Acn_Dec_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBytes);
+flag Acn_Dec_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal);
+flag Acn_Dec_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint* pIntVal, const byte null_characters[], size_t null_characters_size);
+
+flag Acn_Dec_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBytes);
+flag Acn_Dec_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal);
+flag Acn_Dec_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal, const byte null_characters[], size_t null_characters_size);
+
+/*flag Acn_Dec_Int_ASCII_NullTerminated_FormattedInteger(BitStream* pBitStrm, const char* format, asn1SccSint* pIntVal);*/
+
+
+/* Boolean Decode */
+
+flag BitStream_ReadBitPattern(BitStream* pBitStrm, const byte* patternToRead, int nBitsToRead, flag* pBoolValue);
+
+/*Real encoding functions*/
+void Acn_Enc_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real realValue);
+void Acn_Enc_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real realValue);
+void Acn_Enc_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real realValue);
+void Acn_Enc_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real realValue);
+
+flag Acn_Dec_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+flag Acn_Dec_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+flag Acn_Dec_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+flag Acn_Dec_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real* pRealValue);
+
+/*String functions*/
+void Acn_Enc_String_Ascii_FixSize                       (BitStream* pBitStrm, asn1SccSint max, const char* strVal);
+void Acn_Enc_String_Ascii_Null_Teminated                (BitStream* pBitStrm, asn1SccSint max, char null_character, const char* strVal);
+void Acn_Enc_String_Ascii_Null_Teminated_mult           (BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, const char* strVal);
+void Acn_Enc_String_Ascii_External_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, const char* strVal);
+void Acn_Enc_String_Ascii_Internal_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal);
+void Acn_Enc_String_CharIndex_FixSize                   (BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal);
+void Acn_Enc_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal);
+void Acn_Enc_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, const char* strVal);
+void Acn_Enc_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, const char* strVal);
+void Acn_Enc_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal);
+
+flag Acn_Dec_String_Ascii_FixSize                       (BitStream* pBitStrm, asn1SccSint max, char* strVal);
+flag Acn_Dec_String_Ascii_Null_Teminated                (BitStream* pBitStrm, asn1SccSint max, char null_character, char* strVal);
+flag Acn_Dec_String_Ascii_Null_Teminated_mult           (BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, char* strVal);
+flag Acn_Dec_String_Ascii_External_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal);
+flag Acn_Dec_String_Ascii_Internal_Field_Determinant    (BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal);
+flag Acn_Dec_String_CharIndex_FixSize                   (BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, char* strVal);
+flag Acn_Dec_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint extSizeDeterminatFld, char* strVal);
+flag Acn_Dec_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, char* strVal);
+flag Acn_Dec_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal);
+flag Acn_Dec_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal);
+
+
+/* Length Determinant functions*/
+void Acn_Enc_Length(BitStream* pBitStrm, asn1SccUint lengthValue, int lengthSizeInBits);
+flag Acn_Dec_Length(BitStream* pBitStrm, asn1SccUint* pLengthValue, int lengthSizeInBits);
+
+
+
+asn1SccSint milbus_encode(asn1SccSint val);
+asn1SccSint milbus_decode(asn1SccSint val);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+} // namespace i3ds_asn1
+#endif
\ No newline at end of file
diff --git a/generated/include/i3ds_asn1/asn1crt_encoding_uper.hpp b/generated/include/i3ds_asn1/asn1crt_encoding_uper.hpp
new file mode 100644
index 0000000..04d961f
--- /dev/null
+++ b/generated/include/i3ds_asn1/asn1crt_encoding_uper.hpp
@@ -0,0 +1,25 @@
+#ifndef i3ds_asn1_ASN1SCC_ASN1CRT_ENCODING_UPER_H_
+#define i3ds_asn1_ASN1SCC_ASN1CRT_ENCODING_UPER_H_
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+void ObjectIdentifier_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal);
+flag ObjectIdentifier_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal);
+void RelativeOID_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal);
+flag RelativeOID_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal);
+
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+
+} // namespace i3ds_asn1
+#endif
\ No newline at end of file
diff --git a/generated/include/i3ds_asn1/base.hpp b/generated/include/i3ds_asn1/base.hpp
new file mode 100644
index 0000000..bd32eb5
--- /dev/null
+++ b/generated/include/i3ds_asn1/base.hpp
@@ -0,0 +1,4008 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_base_H
+#define i3ds_asn1_GENERATED_ASN1SCC_base_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+#include <i3ds_asn1/taste-types.hpp>
+#include <i3ds_asn1/userdefs-base.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- Base_Angle --------------------------------------------*/
+typedef struct {
+    T_Double rad;
+
+} Base_Angle;
+
+void Base_Angle_Initialize(Base_Angle* pVal);
+
+#define i3ds_asn1_ERR_BASE_ANGLE		891  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_ANGLE_RAD		880  /**/
+flag Base_Angle_IsConstraintValid(const Base_Angle* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_ANGLE		892  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_ANGLE_RAD_2		887  /**/
+#define i3ds_asn1_Base_Angle_REQUIRED_BYTES_FOR_ENCODING       13
+#define i3ds_asn1_Base_Angle_REQUIRED_BITS_FOR_ENCODING        104
+
+flag Base_Angle_Encode(const Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_ANGLE		893  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_ANGLE_RAD_2		888  /**/
+flag Base_Angle_Decode(Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_Motion2D --------------------------------------------*/
+typedef struct {
+    T_Double translation;
+    T_Double rotation;
+    Base_Angle heading;
+
+} Base_commands_Motion2D;
+
+void Base_commands_Motion2D_Initialize(Base_commands_Motion2D* pVal);
+
+#define i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D		1611  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D_TRANSLATION		1567  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D_ROTATION		1578  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D_HEADING		1600  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D_HEADING_RAD		1589  /**/
+flag Base_commands_Motion2D_IsConstraintValid(const Base_commands_Motion2D* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D		1612  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1574  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D_ROTATION_2		1585  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_MOTION2D_HEADING_2		1607  /**/
+#define i3ds_asn1_Base_commands_Motion2D_REQUIRED_BYTES_FOR_ENCODING       39
+#define i3ds_asn1_Base_commands_Motion2D_REQUIRED_BITS_FOR_ENCODING        312
+
+flag Base_commands_Motion2D_Encode(const Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D		1613  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1575  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D_ROTATION_2		1586  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_MOTION2D_HEADING_2		1608  /**/
+flag Base_commands_Motion2D_Decode(Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_PoseUpdateThreshold --------------------------------------------*/
+typedef struct {
+    T_Double distance;
+    T_Double angle;
+
+} Base_PoseUpdateThreshold;
+
+void Base_PoseUpdateThreshold_Initialize(Base_PoseUpdateThreshold* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_POSEUPDATETHRESHOLD		1029  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSEUPDATETHRESHOLD_DISTANCE		1007  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSEUPDATETHRESHOLD_ANGLE		1018  /**/
+flag Base_PoseUpdateThreshold_IsConstraintValid(const Base_PoseUpdateThreshold* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSEUPDATETHRESHOLD		1030  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSEUPDATETHRESHOLD_DISTANCE_2		1014  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSEUPDATETHRESHOLD_ANGLE_2		1025  /**/
+#define i3ds_asn1_Base_PoseUpdateThreshold_REQUIRED_BYTES_FOR_ENCODING       26
+#define i3ds_asn1_Base_PoseUpdateThreshold_REQUIRED_BITS_FOR_ENCODING        208
+
+flag Base_PoseUpdateThreshold_Encode(const Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSEUPDATETHRESHOLD		1031  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSEUPDATETHRESHOLD_DISTANCE_2		1015  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSEUPDATETHRESHOLD_ANGLE_2		1026  /**/
+flag Base_PoseUpdateThreshold_Decode(Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Temperature --------------------------------------------*/
+typedef struct {
+    T_Double kelvin;
+
+} Base_Temperature;
+
+void Base_Temperature_Initialize(Base_Temperature* pVal);
+
+#define i3ds_asn1_ERR_BASE_TEMPERATURE		1065  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TEMPERATURE_KELVIN		1054  /**/
+flag Base_Temperature_IsConstraintValid(const Base_Temperature* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_TEMPERATURE		1066  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TEMPERATURE_KELVIN_2		1061  /**/
+#define i3ds_asn1_Base_Temperature_REQUIRED_BYTES_FOR_ENCODING       13
+#define i3ds_asn1_Base_Temperature_REQUIRED_BITS_FOR_ENCODING        104
+
+flag Base_Temperature_Encode(const Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_TEMPERATURE		1067  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TEMPERATURE_KELVIN_2		1062  /**/
+flag Base_Temperature_Decode(Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_Speed6D --------------------------------------------*/
+typedef struct {
+    T_Double surge;
+    T_Double sway;
+    T_Double heave;
+    T_Double roll;
+    T_Double pitch;
+    T_Double yaw;
+
+} Base_commands_Speed6D;
+
+void Base_commands_Speed6D_Initialize(Base_commands_Speed6D* pVal);
+
+#define i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D		1684  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_SURGE		1618  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_SWAY		1629  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_HEAVE		1640  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_ROLL		1651  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_PITCH		1662  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_YAW		1673  /**/
+flag Base_commands_Speed6D_IsConstraintValid(const Base_commands_Speed6D* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D		1685  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_SURGE_2		1625  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_SWAY_2		1636  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_HEAVE_2		1647  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_ROLL_2		1658  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_PITCH_2		1669  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_SPEED6D_YAW_2		1680  /**/
+#define i3ds_asn1_Base_commands_Speed6D_REQUIRED_BYTES_FOR_ENCODING       78
+#define i3ds_asn1_Base_commands_Speed6D_REQUIRED_BITS_FOR_ENCODING        624
+
+flag Base_commands_Speed6D_Encode(const Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D		1686  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_SURGE_2		1626  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_SWAY_2		1637  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_HEAVE_2		1648  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_ROLL_2		1659  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_PITCH_2		1670  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_SPEED6D_YAW_2		1681  /**/
+flag Base_commands_Speed6D_Decode(Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_AngleAxisd --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[3];
+} Wrappers_AngleAxisd_axis;
+typedef struct {
+    T_Double angle;
+    Wrappers_AngleAxisd_axis axis;
+
+} Wrappers_AngleAxisd;
+
+void Wrappers_AngleAxisd_axis_Initialize(Wrappers_AngleAxisd_axis* pVal);
+void Wrappers_AngleAxisd_Initialize(Wrappers_AngleAxisd* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_ANGLEAXISD		5701  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_ANGLEAXISD_ANGLE		5672  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_ANGLEAXISD_AXIS		5694  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_ANGLEAXISD_AXIS_ELM		5683  /**/
+flag Wrappers_AngleAxisd_IsConstraintValid(const Wrappers_AngleAxisd* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD		5702  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD_ANGLE_2		5679  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD_AXIS		5695  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_ANGLEAXISD_AXIS_ELM_2		5690  /**/
+#define i3ds_asn1_Wrappers_AngleAxisd_REQUIRED_BYTES_FOR_ENCODING       53
+#define i3ds_asn1_Wrappers_AngleAxisd_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_AngleAxisd_Encode(const Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD		5703  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_ANGLE_2		5680  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS		5696  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS_ELM_2		5691  /**/
+flag Wrappers_AngleAxisd_Decode(Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector2d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[2];
+} Wrappers_Vector2d_data;
+typedef struct {
+    Wrappers_Vector2d_data data;
+
+} Wrappers_Vector2d;
+
+void Wrappers_Vector2d_data_Initialize(Wrappers_Vector2d_data* pVal);
+void Wrappers_Vector2d_Initialize(Wrappers_Vector2d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_VECTOR2D		5726  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR2D_DATA		5719  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR2D_DATA_ELM		5708  /**/
+flag Wrappers_Vector2d_IsConstraintValid(const Wrappers_Vector2d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR2D		5727  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR2D_DATA		5720  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR2D_DATA_ELM_2		5715  /**/
+#define i3ds_asn1_Wrappers_Vector2d_REQUIRED_BYTES_FOR_ENCODING       27
+#define i3ds_asn1_Wrappers_Vector2d_REQUIRED_BITS_FOR_ENCODING        209
+
+flag Wrappers_Vector2d_Encode(const Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR2D		5728  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA		5721  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA_ELM_2		5716  /**/
+flag Wrappers_Vector2d_Decode(Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose2D --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector2d position;
+    T_Double orientation;
+
+} Base_Pose2D;
+
+void Base_Pose2D_Initialize(Base_Pose2D* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D		1000  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_POSITION		978  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_POSITION_DATA		971  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_POSITION_DATA_ELM		960  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_ORIENTATION		989  /**/
+flag Base_Pose2D_IsConstraintValid(const Base_Pose2D* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE2D		1001  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE2D_POSITION_2		985  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE2D_ORIENTATION_2		996  /**/
+#define i3ds_asn1_Base_Pose2D_REQUIRED_BYTES_FOR_ENCODING       40
+#define i3ds_asn1_Base_Pose2D_REQUIRED_BITS_FOR_ENCODING        313
+
+flag Base_Pose2D_Encode(const Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE2D		1002  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE2D_POSITION_2		986  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE2D_ORIENTATION_2		997  /**/
+flag Base_Pose2D_Decode(Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose2D_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector2d position;
+    T_Double orientation;
+
+} Base_Pose2D_m;
+
+void Base_Pose2D_m_Initialize(Base_Pose2D_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M		6114  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M_POSITION		6092  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M_POSITION_DATA		6085  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M_POSITION_DATA_ELM		6074  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M_ORIENTATION		6103  /**/
+flag Base_Pose2D_m_IsConstraintValid(const Base_Pose2D_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE2D_M		6115  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE2D_M_POSITION_2		6099  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE2D_M_ORIENTATION_2		6110  /**/
+#define i3ds_asn1_Base_Pose2D_m_REQUIRED_BYTES_FOR_ENCODING       40
+#define i3ds_asn1_Base_Pose2D_m_REQUIRED_BITS_FOR_ENCODING        313
+
+flag Base_Pose2D_m_Encode(const Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE2D_M		6116  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE2D_M_POSITION_2		6100  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE2D_M_ORIENTATION_2		6111  /**/
+flag Base_Pose2D_m_Decode(Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix2d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[4];
+} Wrappers_Matrix2d_data;
+typedef struct {
+    Wrappers_Matrix2d_data data;
+
+} Wrappers_Matrix2d;
+
+void Wrappers_Matrix2d_data_Initialize(Wrappers_Matrix2d_data* pVal);
+void Wrappers_Matrix2d_Initialize(Wrappers_Matrix2d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_MATRIX2D		5751  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX2D_DATA		5744  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX2D_DATA_ELM		5733  /**/
+flag Wrappers_Matrix2d_IsConstraintValid(const Wrappers_Matrix2d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX2D		5752  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX2D_DATA		5745  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX2D_DATA_ELM_2		5740  /**/
+#define i3ds_asn1_Wrappers_Matrix2d_REQUIRED_BYTES_FOR_ENCODING       53
+#define i3ds_asn1_Wrappers_Matrix2d_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_Matrix2d_Encode(const Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX2D		5753  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA		5746  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA_ELM_2		5741  /**/
+flag Wrappers_Matrix2d_Decode(Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector3d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[3];
+} Wrappers_Vector3d_data;
+typedef struct {
+    Wrappers_Vector3d_data data;
+
+} Wrappers_Vector3d;
+
+void Wrappers_Vector3d_data_Initialize(Wrappers_Vector3d_data* pVal);
+void Wrappers_Vector3d_Initialize(Wrappers_Vector3d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_VECTOR3D		5776  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR3D_DATA		5769  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR3D_DATA_ELM		5758  /**/
+flag Wrappers_Vector3d_IsConstraintValid(const Wrappers_Vector3d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR3D		5777  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR3D_DATA		5770  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR3D_DATA_ELM_2		5765  /**/
+#define i3ds_asn1_Wrappers_Vector3d_REQUIRED_BYTES_FOR_ENCODING       40
+#define i3ds_asn1_Wrappers_Vector3d_REQUIRED_BITS_FOR_ENCODING        314
+
+flag Wrappers_Vector3d_Encode(const Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR3D		5778  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA		5771  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA_ELM_2		5766  /**/
+flag Wrappers_Vector3d_Decode(Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Wrench --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+
+} Base_Wrench;
+
+void Base_Wrench_Initialize(Base_Wrench* pVal);
+
+#define i3ds_asn1_ERR_BASE_WRENCH		873  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_FORCE		833  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_FORCE_DATA		826  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_FORCE_DATA_ELM		815  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_TORQUE		862  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_TORQUE_DATA		855  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_TORQUE_DATA_ELM		844  /**/
+flag Base_Wrench_IsConstraintValid(const Base_Wrench* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_WRENCH		874  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WRENCH_FORCE_2		840  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WRENCH_TORQUE_2		869  /**/
+#define i3ds_asn1_Base_Wrench_REQUIRED_BYTES_FOR_ENCODING       79
+#define i3ds_asn1_Base_Wrench_REQUIRED_BITS_FOR_ENCODING        628
+
+flag Base_Wrench_Encode(const Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_WRENCH		875  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WRENCH_FORCE_2		841  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WRENCH_TORQUE_2		870  /**/
+flag Base_Wrench_Decode(Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Waypoint --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    T_Double heading;
+    T_Double tol_position;
+    T_Double tol_heading;
+
+} Base_Waypoint;
+
+void Base_Waypoint_Initialize(Base_Waypoint* pVal);
+
+#define i3ds_asn1_ERR_BASE_WAYPOINT		1261  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_POSITION		1217  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_POSITION_DATA		1210  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_POSITION_DATA_ELM		1199  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_HEADING		1228  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_TOL_POSITION		1239  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_TOL_HEADING		1250  /**/
+flag Base_Waypoint_IsConstraintValid(const Base_Waypoint* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT		1262  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_POSITION_2		1224  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_HEADING_2		1235  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_TOL_POSITION_2		1246  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_TOL_HEADING_2		1257  /**/
+#define i3ds_asn1_Base_Waypoint_REQUIRED_BYTES_FOR_ENCODING       79
+#define i3ds_asn1_Base_Waypoint_REQUIRED_BITS_FOR_ENCODING        626
+
+flag Base_Waypoint_Encode(const Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT		1263  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_POSITION_2		1225  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_HEADING_2		1236  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_TOL_POSITION_2		1247  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_TOL_HEADING_2		1258  /**/
+flag Base_Waypoint_Decode(Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Waypoint_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    T_Double heading;
+    T_Double tol_position;
+    T_Double tol_heading;
+
+} Base_Waypoint_m;
+
+void Base_Waypoint_m_Initialize(Base_Waypoint_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M		6458  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_POSITION		6414  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_POSITION_DATA		6407  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_POSITION_DATA_ELM		6396  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_HEADING		6425  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_TOL_POSITION		6436  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_TOL_HEADING		6447  /**/
+flag Base_Waypoint_m_IsConstraintValid(const Base_Waypoint_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_M		6459  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_M_POSITION_2		6421  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_M_HEADING_2		6432  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_M_TOL_POSITION_2		6443  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WAYPOINT_M_TOL_HEADING_2		6454  /**/
+#define i3ds_asn1_Base_Waypoint_m_REQUIRED_BYTES_FOR_ENCODING       79
+#define i3ds_asn1_Base_Waypoint_m_REQUIRED_BITS_FOR_ENCODING        626
+
+flag Base_Waypoint_m_Encode(const Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_M		6460  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_M_POSITION_2		6422  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_M_HEADING_2		6433  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_M_TOL_POSITION_2		6444  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WAYPOINT_M_TOL_HEADING_2		6455  /**/
+flag Base_Waypoint_m_Decode(Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_Waypoint_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_Waypoint;
+
+void Std_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal);
+
+#define i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT		301  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM		290  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION		246  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA		239  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA_ELM		228  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_HEADING		257  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_POSITION		268  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_HEADING		279  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT		302  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_2		297  /**/
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BYTES_FOR_ENCODING       15651
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_Waypoint_REQUIRED_BITS_FOR_ENCODING        125208
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Encode(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT		303  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_2		298  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Decode(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Wrench_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+
+} Base_Wrench_m;
+
+void Base_Wrench_m_Initialize(Base_Wrench_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M		6523  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_FORCE		6483  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_FORCE_DATA		6476  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_FORCE_DATA_ELM		6465  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_TORQUE		6512  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_TORQUE_DATA		6505  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_TORQUE_DATA_ELM		6494  /**/
+flag Base_Wrench_m_IsConstraintValid(const Base_Wrench_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WRENCH_M		6524  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WRENCH_M_FORCE_2		6490  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_WRENCH_M_TORQUE_2		6519  /**/
+#define i3ds_asn1_Base_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       79
+#define i3ds_asn1_Base_Wrench_m_REQUIRED_BITS_FOR_ENCODING        628
+
+flag Base_Wrench_m_Encode(const Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WRENCH_M		6525  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WRENCH_M_FORCE_2		6491  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_WRENCH_M_TORQUE_2		6520  /**/
+flag Base_Wrench_m_Decode(Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_Wrench_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_Wrench;
+
+void Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal);
+
+#define i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH		377  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM		366  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE		326  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA		319  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA_ELM		308  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE		355  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA		348  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA_ELM		337  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH		378  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_2		373  /**/
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BYTES_FOR_ENCODING       15701
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_Wrench_REQUIRED_BITS_FOR_ENCODING        125608
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH		379  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_2		374  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix3d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[9];
+} Wrappers_Matrix3d_data;
+typedef struct {
+    Wrappers_Matrix3d_data data;
+
+} Wrappers_Matrix3d;
+
+void Wrappers_Matrix3d_data_Initialize(Wrappers_Matrix3d_data* pVal);
+void Wrappers_Matrix3d_Initialize(Wrappers_Matrix3d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_MATRIX3D		5801  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX3D_DATA		5794  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX3D_DATA_ELM		5783  /**/
+flag Wrappers_Matrix3d_IsConstraintValid(const Wrappers_Matrix3d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX3D		5802  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX3D_DATA		5795  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX3D_DATA_ELM_2		5790  /**/
+#define i3ds_asn1_Wrappers_Matrix3d_REQUIRED_BYTES_FOR_ENCODING       118
+#define i3ds_asn1_Wrappers_Matrix3d_REQUIRED_BITS_FOR_ENCODING        940
+
+flag Wrappers_Matrix3d_Encode(const Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX3D		5803  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA		5796  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA_ELM_2		5791  /**/
+flag Wrappers_Matrix3d_Decode(Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector4d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[4];
+} Wrappers_Vector4d_data;
+typedef struct {
+    Wrappers_Vector4d_data data;
+
+} Wrappers_Vector4d;
+
+void Wrappers_Vector4d_data_Initialize(Wrappers_Vector4d_data* pVal);
+void Wrappers_Vector4d_Initialize(Wrappers_Vector4d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_VECTOR4D		5826  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR4D_DATA		5819  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR4D_DATA_ELM		5808  /**/
+flag Wrappers_Vector4d_IsConstraintValid(const Wrappers_Vector4d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR4D		5827  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR4D_DATA		5820  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR4D_DATA_ELM_2		5815  /**/
+#define i3ds_asn1_Wrappers_Vector4d_REQUIRED_BYTES_FOR_ENCODING       53
+#define i3ds_asn1_Wrappers_Vector4d_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_Vector4d_Encode(const Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR4D		5828  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA		5821  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA_ELM_2		5816  /**/
+flag Wrappers_Vector4d_Decode(Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector4d arr[200];
+} Std_vector_Wrappers_Vector4d;
+
+void Std_vector_Wrappers_Vector4d_Initialize(Std_vector_Wrappers_Vector4d* pVal);
+
+#define i3ds_asn1_ERR_STD_VECTOR_WRAPPERS_VECTOR4D		413  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM		402  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA		395  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA_ELM		384  /**/
+flag Std_vector_Wrappers_Vector4d_IsConstraintValid(const Std_vector_Wrappers_Vector4d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_STD_VECTOR_WRAPPERS_VECTOR4D		414  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_2		409  /**/
+#define Std_vector_i3ds_asn1_Wrappers_Vector4d_REQUIRED_BYTES_FOR_ENCODING       10451
+#define Std_vector_i3ds_asn1_Wrappers_Vector4d_REQUIRED_BITS_FOR_ENCODING        83608
+
+flag Std_vector_Wrappers_Vector4d_Encode(const Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D		415  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_2		410  /**/
+flag Std_vector_Wrappers_Vector4d_Decode(Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix4d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[16];
+} Wrappers_Matrix4d_data;
+typedef struct {
+    Wrappers_Matrix4d_data data;
+
+} Wrappers_Matrix4d;
+
+void Wrappers_Matrix4d_data_Initialize(Wrappers_Matrix4d_data* pVal);
+void Wrappers_Matrix4d_Initialize(Wrappers_Matrix4d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_MATRIX4D		5851  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX4D_DATA		5844  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX4D_DATA_ELM		5833  /**/
+flag Wrappers_Matrix4d_IsConstraintValid(const Wrappers_Matrix4d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX4D		5852  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX4D_DATA		5845  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX4D_DATA_ELM_2		5840  /**/
+#define i3ds_asn1_Wrappers_Matrix4d_REQUIRED_BYTES_FOR_ENCODING       209
+#define i3ds_asn1_Wrappers_Matrix4d_REQUIRED_BITS_FOR_ENCODING        1668
+
+flag Wrappers_Matrix4d_Encode(const Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX4D		5853  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA		5846  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA_ELM_2		5841  /**/
+flag Wrappers_Matrix4d_Decode(Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Vector6d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[6];
+} Wrappers_Vector6d_data;
+typedef struct {
+    Wrappers_Vector6d_data data;
+
+} Wrappers_Vector6d;
+
+void Wrappers_Vector6d_data_Initialize(Wrappers_Vector6d_data* pVal);
+void Wrappers_Vector6d_Initialize(Wrappers_Vector6d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_VECTOR6D		5876  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR6D_DATA		5869  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR6D_DATA_ELM		5858  /**/
+flag Wrappers_Vector6d_IsConstraintValid(const Wrappers_Vector6d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR6D		5877  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR6D_DATA		5870  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTOR6D_DATA_ELM_2		5865  /**/
+#define i3ds_asn1_Wrappers_Vector6d_REQUIRED_BYTES_FOR_ENCODING       79
+#define i3ds_asn1_Wrappers_Vector6d_REQUIRED_BITS_FOR_ENCODING        627
+
+flag Wrappers_Vector6d_Encode(const Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR6D		5878  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA		5871  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA_ELM_2		5866  /**/
+flag Wrappers_Vector6d_Decode(Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Matrix6d --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[36];
+} Wrappers_Matrix6d_data;
+typedef struct {
+    Wrappers_Matrix6d_data data;
+
+} Wrappers_Matrix6d;
+
+void Wrappers_Matrix6d_data_Initialize(Wrappers_Matrix6d_data* pVal);
+void Wrappers_Matrix6d_Initialize(Wrappers_Matrix6d* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_MATRIX6D		5901  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX6D_DATA		5894  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX6D_DATA_ELM		5883  /**/
+flag Wrappers_Matrix6d_IsConstraintValid(const Wrappers_Matrix6d* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX6D		5902  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX6D_DATA		5895  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIX6D_DATA_ELM_2		5890  /**/
+#define i3ds_asn1_Wrappers_Matrix6d_REQUIRED_BYTES_FOR_ENCODING       469
+#define i3ds_asn1_Wrappers_Matrix6d_REQUIRED_BITS_FOR_ENCODING        3750
+
+flag Wrappers_Matrix6d_Encode(const Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX6D		5903  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA		5896  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA_ELM_2		5891  /**/
+flag Wrappers_Matrix6d_Decode(Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TwistWithCovariance --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d vel;
+    Wrappers_Vector3d rot;
+    Wrappers_Matrix6d cov;
+
+} Base_TwistWithCovariance;
+
+void Base_TwistWithCovariance_Initialize(Base_TwistWithCovariance* pVal);
+
+#define i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE		808  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_VEL		739  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA		732  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA_ELM		721  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_ROT		768  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA		761  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA_ELM		750  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_COV		797  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA		790  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA_ELM		779  /**/
+flag Base_TwistWithCovariance_IsConstraintValid(const Base_TwistWithCovariance* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE		809  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_VEL_2		746  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_ROT_2		775  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_COV_2		804  /**/
+#define i3ds_asn1_Base_TwistWithCovariance_REQUIRED_BYTES_FOR_ENCODING       548
+#define i3ds_asn1_Base_TwistWithCovariance_REQUIRED_BITS_FOR_ENCODING        4378
+
+flag Base_TwistWithCovariance_Encode(const Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE		810  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_VEL_2		747  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_ROT_2		776  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_COV_2		805  /**/
+flag Base_TwistWithCovariance_Decode(Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TwistWithCovariance_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d vel;
+    Wrappers_Vector3d rot;
+    Wrappers_Matrix6d cov;
+
+} Base_TwistWithCovariance_m;
+
+void Base_TwistWithCovariance_m_Initialize(Base_TwistWithCovariance_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M		6389  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_VEL		6320  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA		6313  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA_ELM		6302  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_ROT		6349  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA		6342  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA_ELM		6331  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_COV		6378  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA		6371  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA_ELM		6360  /**/
+flag Base_TwistWithCovariance_m_IsConstraintValid(const Base_TwistWithCovariance_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M		6390  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M_VEL_2		6327  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M_ROT_2		6356  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TWISTWITHCOVARIANCE_M_COV_2		6385  /**/
+#define i3ds_asn1_Base_TwistWithCovariance_m_REQUIRED_BYTES_FOR_ENCODING       548
+#define i3ds_asn1_Base_TwistWithCovariance_m_REQUIRED_BITS_FOR_ENCODING        4378
+
+flag Base_TwistWithCovariance_m_Encode(const Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M		6391  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M_VEL_2		6328  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M_ROT_2		6357  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TWISTWITHCOVARIANCE_M_COV_2		6386  /**/
+flag Base_TwistWithCovariance_m_Decode(Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_Quaterniond --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[3];
+} Wrappers_Quaterniond_im;
+typedef struct {
+    Wrappers_Quaterniond_im im;
+    T_Double re;
+
+} Wrappers_Quaterniond;
+
+void Wrappers_Quaterniond_im_Initialize(Wrappers_Quaterniond_im* pVal);
+void Wrappers_Quaterniond_Initialize(Wrappers_Quaterniond* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_QUATERNIOND		5984  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_QUATERNIOND_IM		5966  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_QUATERNIOND_IM_ELM		5955  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_QUATERNIOND_RE		5973  /**/
+flag Wrappers_Quaterniond_IsConstraintValid(const Wrappers_Quaterniond* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND		5985  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND_IM		5967  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND_IM_ELM_2		5962  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_QUATERNIOND_RE_2		5980  /**/
+#define i3ds_asn1_Wrappers_Quaterniond_REQUIRED_BYTES_FOR_ENCODING       53
+#define i3ds_asn1_Wrappers_Quaterniond_REQUIRED_BITS_FOR_ENCODING        418
+
+flag Wrappers_Quaterniond_Encode(const Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_QUATERNIOND		5986  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM		5968  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM_ELM_2		5963  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_RE_2		5981  /**/
+flag Wrappers_Quaterniond_Decode(Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    Wrappers_Quaterniond orientation;
+
+} Base_Pose;
+
+void Base_Pose_Initialize(Base_Pose* pVal);
+
+#define i3ds_asn1_ERR_BASE_POSE		609  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_POSITION		558  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_POSITION_DATA		551  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_POSITION_DATA_ELM		540  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_ORIENTATION		598  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_ORIENTATION_IM		580  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_ORIENTATION_IM_ELM		569  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_ORIENTATION_RE		587  /**/
+flag Base_Pose_IsConstraintValid(const Base_Pose* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE		610  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE_POSITION_2		565  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE_ORIENTATION_2		605  /**/
+#define i3ds_asn1_Base_Pose_REQUIRED_BYTES_FOR_ENCODING       92
+#define i3ds_asn1_Base_Pose_REQUIRED_BITS_FOR_ENCODING        732
+
+flag Base_Pose_Encode(const Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_POSE		611  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE_POSITION_2		566  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE_ORIENTATION_2		606  /**/
+flag Base_Pose_Decode(Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TransformWithCovariance --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d translation;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix6d cov;
+
+} Base_TransformWithCovariance;
+
+void Base_TransformWithCovariance_Initialize(Base_TransformWithCovariance* pVal);
+
+#define i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE		714  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION		634  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA		627  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA_ELM		616  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION		674  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM		656  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM_ELM		645  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_RE		663  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_COV		703  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA		696  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA_ELM		685  /**/
+flag Base_TransformWithCovariance_IsConstraintValid(const Base_TransformWithCovariance* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE		715  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_2		641  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_2		681  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_COV_2		710  /**/
+#define i3ds_asn1_Base_TransformWithCovariance_REQUIRED_BYTES_FOR_ENCODING       561
+#define i3ds_asn1_Base_TransformWithCovariance_REQUIRED_BITS_FOR_ENCODING        4482
+
+flag Base_TransformWithCovariance_Encode(const Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE		716  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_2		642  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_2		682  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_COV_2		711  /**/
+flag Base_TransformWithCovariance_Decode(Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pose_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d position;
+    Wrappers_Quaterniond orientation;
+
+} Base_Pose_m;
+
+void Base_Pose_m_Initialize(Base_Pose_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M		6190  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_POSITION		6139  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_POSITION_DATA		6132  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_POSITION_DATA_ELM		6121  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_ORIENTATION		6179  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_ORIENTATION_IM		6161  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_ORIENTATION_IM_ELM		6150  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_ORIENTATION_RE		6168  /**/
+flag Base_Pose_m_IsConstraintValid(const Base_Pose_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE_M		6191  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE_M_POSITION_2		6146  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_POSE_M_ORIENTATION_2		6186  /**/
+#define i3ds_asn1_Base_Pose_m_REQUIRED_BYTES_FOR_ENCODING       92
+#define i3ds_asn1_Base_Pose_m_REQUIRED_BITS_FOR_ENCODING        732
+
+flag Base_Pose_m_Encode(const Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE_M		6192  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE_M_POSITION_2		6147  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_POSE_M_ORIENTATION_2		6187  /**/
+flag Base_Pose_m_Decode(Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TransformWithCovariance_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d translation;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix6d cov;
+
+} Base_TransformWithCovariance_m;
+
+void Base_TransformWithCovariance_m_Initialize(Base_TransformWithCovariance_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M		6295  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION		6215  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA		6208  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA_ELM		6197  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION		6255  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM		6237  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM_ELM		6226  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_RE		6244  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV		6284  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA		6277  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA_ELM		6266  /**/
+flag Base_TransformWithCovariance_m_IsConstraintValid(const Base_TransformWithCovariance_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M		6296  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_2		6222  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_2		6262  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRANSFORMWITHCOVARIANCE_M_COV_2		6291  /**/
+#define i3ds_asn1_Base_TransformWithCovariance_m_REQUIRED_BYTES_FOR_ENCODING       561
+#define i3ds_asn1_Base_TransformWithCovariance_m_REQUIRED_BITS_FOR_ENCODING        4482
+
+flag Base_TransformWithCovariance_m_Encode(const Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M		6297  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_2		6223  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_2		6263  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRANSFORMWITHCOVARIANCE_M_COV_2		6292  /**/
+flag Base_TransformWithCovariance_m_Decode(Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_VectorXd --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_VectorXd_data;
+typedef struct {
+    Wrappers_VectorXd_data data;
+
+} Wrappers_VectorXd;
+
+void Wrappers_VectorXd_data_Initialize(Wrappers_VectorXd_data* pVal);
+void Wrappers_VectorXd_Initialize(Wrappers_VectorXd* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_VECTORXD		6009  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTORXD_DATA		6002  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTORXD_DATA_ELM		5991  /**/
+flag Wrappers_VectorXd_IsConstraintValid(const Wrappers_VectorXd* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTORXD		6010  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTORXD_DATA		6003  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_VECTORXD_DATA_ELM_2		5998  /**/
+#define i3ds_asn1_Wrappers_VectorXd_REQUIRED_BYTES_FOR_ENCODING       2601
+#define i3ds_asn1_Wrappers_VectorXd_REQUIRED_BITS_FOR_ENCODING        20808
+
+flag Wrappers_VectorXd_Encode(const Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTORXD		6011  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA		6004  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA_ELM_2		5999  /**/
+flag Wrappers_VectorXd_Decode(Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointState --------------------------------------------*/
+typedef struct {
+    T_Double position;
+    T_Float speed;
+    T_Float effort;
+    T_Float raw;
+    T_Float acceleration;
+
+} Base_JointState;
+
+void Base_JointState_Initialize(Base_JointState* pVal);
+
+#define i3ds_asn1_ERR_BASE_JOINTSTATE		953  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_POSITION		898  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_SPEED		909  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_EFFORT		920  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_RAW		931  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_ACCELERATION		942  /**/
+flag Base_JointState_IsConstraintValid(const Base_JointState* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE		954  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE_POSITION_2		905  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE_SPEED_2		916  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE_EFFORT_2		927  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE_RAW_2		938  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE_ACCELERATION_2		949  /**/
+#define i3ds_asn1_Base_JointState_REQUIRED_BYTES_FOR_ENCODING       65
+#define i3ds_asn1_Base_JointState_REQUIRED_BITS_FOR_ENCODING        520
+
+flag Base_JointState_Encode(const Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE		955  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_POSITION_2		906  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_SPEED_2		917  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_EFFORT_2		928  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_RAW_2		939  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_ACCELERATION_2		950  /**/
+flag Base_JointState_Decode(Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointState arr[200];
+} Base_JointTrajectory;
+
+void Base_JointTrajectory_Initialize(Base_JointTrajectory* pVal);
+
+#define i3ds_asn1_ERR_BASE_JOINTTRAJECTORY		152  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM		141  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_POSITION		86  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_SPEED		97  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_EFFORT		108  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_RAW		119  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_ACCELERATION		130  /**/
+flag Base_JointTrajectory_IsConstraintValid(const Base_JointTrajectory* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRAJECTORY		153  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRAJECTORY_ELM_2		148  /**/
+#define i3ds_asn1_Base_JointTrajectory_REQUIRED_BYTES_FOR_ENCODING       13001
+#define i3ds_asn1_Base_JointTrajectory_REQUIRED_BITS_FOR_ENCODING        104008
+
+flag Base_JointTrajectory_Encode(const Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRAJECTORY		154  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRAJECTORY_ELM_2		149  /**/
+flag Base_JointTrajectory_Decode(Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointLimitRange --------------------------------------------*/
+typedef struct {
+    Base_JointState min;
+    Base_JointState max;
+
+} Base_JointLimitRange;
+
+void Base_JointLimitRange_Initialize(Base_JointLimitRange* pVal);
+
+#define i3ds_asn1_ERR_BASE_JOINTLIMITRANGE		1400  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN		1323  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_POSITION		1268  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_SPEED		1279  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_EFFORT		1290  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_RAW		1301  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_ACCELERATION		1312  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX		1389  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_POSITION		1334  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_SPEED		1345  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_EFFORT		1356  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_RAW		1367  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_ACCELERATION		1378  /**/
+flag Base_JointLimitRange_IsConstraintValid(const Base_JointLimitRange* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITRANGE		1401  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITRANGE_MIN_2		1330  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITRANGE_MAX_2		1396  /**/
+#define i3ds_asn1_Base_JointLimitRange_REQUIRED_BYTES_FOR_ENCODING       130
+#define i3ds_asn1_Base_JointLimitRange_REQUIRED_BITS_FOR_ENCODING        1040
+
+flag Base_JointLimitRange_Encode(const Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITRANGE		1402  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITRANGE_MIN_2		1331  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITRANGE_MAX_2		1397  /**/
+flag Base_JointLimitRange_Decode(Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Pressure --------------------------------------------*/
+typedef struct {
+    T_Float pascal;
+
+} Base_Pressure;
+
+void Base_Pressure_Initialize(Base_Pressure* pVal);
+
+#define i3ds_asn1_ERR_BASE_PRESSURE		1047  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_PRESSURE_PASCAL		1036  /**/
+flag Base_Pressure_IsConstraintValid(const Base_Pressure* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_PRESSURE		1048  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_PRESSURE_PASCAL_2		1043  /**/
+#define i3ds_asn1_Base_Pressure_REQUIRED_BYTES_FOR_ENCODING       13
+#define i3ds_asn1_Base_Pressure_REQUIRED_BITS_FOR_ENCODING        104
+
+flag Base_Pressure_Encode(const Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_PRESSURE		1049  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_PRESSURE_PASCAL_2		1044  /**/
+flag Base_Pressure_Decode(Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Time --------------------------------------------*/
+typedef struct {
+    T_Int64 microseconds;
+
+} Base_Time;
+
+void Base_Time_Initialize(Base_Time* pVal);
+
+#define i3ds_asn1_ERR_BASE_TIME		1083  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TIME_MICROSECONDS		1072  /**/
+flag Base_Time_IsConstraintValid(const Base_Time* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_TIME		1084  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIME_MICROSECONDS_2		1079  /**/
+#define i3ds_asn1_Base_Time_REQUIRED_BYTES_FOR_ENCODING       8
+#define i3ds_asn1_Base_Time_REQUIRED_BITS_FOR_ENCODING        64
+
+flag Base_Time_Encode(const Base_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_TIME		1085  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIME_MICROSECONDS_2		1080  /**/
+flag Base_Time_Decode(Base_Time* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_TimeStamped_Base_commands_Motion2D --------------------------------------------*/
+typedef struct {
+    T_Double translation;
+    T_Double rotation;
+    Base_Angle heading;
+    Base_Time time;
+
+} Base_TimeStamped_Base_commands_Motion2D;
+
+void Base_TimeStamped_Base_commands_Motion2D_Initialize(Base_TimeStamped_Base_commands_Motion2D* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D		1473  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION		1407  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION		1418  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING		1440  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_RAD		1429  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME		1462  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_MICROSECONDS		1451  /**/
+flag Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const Base_TimeStamped_Base_commands_Motion2D* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D		1474  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1414  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION_2		1425  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_2		1447  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_2		1469  /**/
+#define Base_TimeStamped_i3ds_asn1_Base_commands_Motion2D_REQUIRED_BYTES_FOR_ENCODING       47
+#define Base_TimeStamped_i3ds_asn1_Base_commands_Motion2D_REQUIRED_BITS_FOR_ENCODING        376
+
+flag Base_TimeStamped_Base_commands_Motion2D_Encode(const Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D		1475  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION_2		1415  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION_2		1426  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_2		1448  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TIME_2		1470  /**/
+flag Base_TimeStamped_Base_commands_Motion2D_Decode(Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_LinearAngular6DCommand --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d linear;
+    Wrappers_Vector3d angular;
+
+} Base_LinearAngular6DCommand;
+
+void Base_LinearAngular6DCommand_Initialize(Base_LinearAngular6DCommand* pVal);
+
+#define i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND		1560  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_TIME		1491  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_TIME_MICROSECONDS		1480  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR		1520  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA		1513  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA_ELM		1502  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR		1549  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA		1542  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA_ELM		1531  /**/
+flag Base_LinearAngular6DCommand_IsConstraintValid(const Base_LinearAngular6DCommand* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND		1561  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND_TIME_2		1498  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND_LINEAR_2		1527  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_2		1556  /**/
+#define i3ds_asn1_Base_LinearAngular6DCommand_REQUIRED_BYTES_FOR_ENCODING       87
+#define i3ds_asn1_Base_LinearAngular6DCommand_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_LinearAngular6DCommand_Encode(const Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND		1562  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND_TIME_2		1499  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND_LINEAR_2		1528  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_2		1557  /**/
+flag Base_LinearAngular6DCommand_Decode(Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_BodyState --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Base_TransformWithCovariance pose;
+    Base_TwistWithCovariance velocity;
+
+} Base_samples_BodyState;
+
+void Base_samples_BodyState_Initialize(Base_samples_BodyState* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE		1920  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_TIME		1702  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_TIME_MICROSECONDS		1691  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE		1811  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION		1731  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA		1724  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA_ELM		1713  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION		1771  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM		1753  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM_ELM		1742  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_RE		1760  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_COV		1800  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA		1793  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA_ELM		1782  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY		1909  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL		1840  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA		1833  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA_ELM		1822  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT		1869  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA		1862  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA_ELM		1851  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV		1898  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA		1891  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA_ELM		1880  /**/
+flag Base_samples_BodyState_IsConstraintValid(const Base_samples_BodyState* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE		1921  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_TIME_2		1709  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_POSE_2		1818  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_VELOCITY_2		1916  /**/
+#define i3ds_asn1_Base_samples_BodyState_REQUIRED_BYTES_FOR_ENCODING       1116
+#define i3ds_asn1_Base_samples_BodyState_REQUIRED_BITS_FOR_ENCODING        8924
+
+flag Base_samples_BodyState_Encode(const Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE		1922  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_TIME_2		1710  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_POSE_2		1819  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_VELOCITY_2		1917  /**/
+flag Base_samples_BodyState_Decode(Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_IMUSensors --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acc;
+    Wrappers_Vector3d gyro;
+    Wrappers_Vector3d mag;
+
+} Base_samples_IMUSensors;
+
+void Base_samples_IMUSensors_Initialize(Base_samples_IMUSensors* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS		2036  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_TIME		1938  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_TIME_MICROSECONDS		1927  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_ACC		1967  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA		1960  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA_ELM		1949  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_GYRO		1996  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA		1989  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA_ELM		1978  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_MAG		2025  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA		2018  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA_ELM		2007  /**/
+flag Base_samples_IMUSensors_IsConstraintValid(const Base_samples_IMUSensors* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS		2037  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_TIME_2		1945  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_ACC_2		1974  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_GYRO_2		2003  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_MAG_2		2032  /**/
+#define i3ds_asn1_Base_samples_IMUSensors_REQUIRED_BYTES_FOR_ENCODING       126
+#define i3ds_asn1_Base_samples_IMUSensors_REQUIRED_BITS_FOR_ENCODING        1006
+
+flag Base_samples_IMUSensors_Encode(const Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS		2038  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_TIME_2		1946  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_ACC_2		1975  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_GYRO_2		2004  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_MAG_2		2033  /**/
+flag Base_samples_IMUSensors_Decode(Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Motion2D --------------------------------------------*/
+typedef struct {
+    T_Double translation;
+    T_Double rotation;
+    Base_Angle heading;
+    Base_Time time;
+
+} Base_samples_Motion2D;
+
+void Base_samples_Motion2D_Initialize(Base_samples_Motion2D* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D		2109  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_TRANSLATION		2043  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_ROTATION		2054  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_HEADING		2076  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_HEADING_RAD		2065  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_TIME		2098  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_TIME_MICROSECONDS		2087  /**/
+flag Base_samples_Motion2D_IsConstraintValid(const Base_samples_Motion2D* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D		2110  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_TRANSLATION_2		2050  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_ROTATION_2		2061  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_HEADING_2		2083  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_MOTION2D_TIME_2		2105  /**/
+#define i3ds_asn1_Base_samples_Motion2D_REQUIRED_BYTES_FOR_ENCODING       47
+#define i3ds_asn1_Base_samples_Motion2D_REQUIRED_BITS_FOR_ENCODING        376
+
+flag Base_samples_Motion2D_Encode(const Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D		2111  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_TRANSLATION_2		2051  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_ROTATION_2		2062  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_HEADING_2		2084  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_MOTION2D_TIME_2		2106  /**/
+flag Base_samples_Motion2D_Decode(Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Pressure --------------------------------------------*/
+typedef struct {
+    T_Float pascal;
+    Base_Time time;
+
+} Base_samples_Pressure;
+
+void Base_samples_Pressure_Initialize(Base_samples_Pressure* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_PRESSURE		2149  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_PRESSURE_PASCAL		2116  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_PRESSURE_TIME		2138  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_PRESSURE_TIME_MICROSECONDS		2127  /**/
+flag Base_samples_Pressure_IsConstraintValid(const Base_samples_Pressure* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_PRESSURE		2150  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_PRESSURE_PASCAL_2		2123  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_PRESSURE_TIME_2		2145  /**/
+#define i3ds_asn1_Base_samples_Pressure_REQUIRED_BYTES_FOR_ENCODING       21
+#define i3ds_asn1_Base_samples_Pressure_REQUIRED_BITS_FOR_ENCODING        168
+
+flag Base_samples_Pressure_Encode(const Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_PRESSURE		2151  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_PRESSURE_PASCAL_2		2124  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_PRESSURE_TIME_2		2146  /**/
+flag Base_samples_Pressure_Decode(Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyAcceleration --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acceleration;
+    Wrappers_Matrix3d cov_acceleration;
+    Wrappers_Vector3d angular_acceleration;
+    Wrappers_Matrix3d cov_angular_acceleration;
+
+} Base_samples_RigidBodyAcceleration;
+
+void Base_samples_RigidBodyAcceleration_Initialize(Base_samples_RigidBodyAcceleration* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION		2294  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME		2167  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_MICROSECONDS		2156  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION		2196  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA		2189  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA_ELM		2178  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION		2225  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA		2218  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA_ELM		2207  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION		2254  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA		2247  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA_ELM		2236  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION		2283  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA		2276  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA_ELM		2265  /**/
+flag Base_samples_RigidBodyAcceleration_IsConstraintValid(const Base_samples_RigidBodyAcceleration* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION		2295  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_2		2174  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_2		2203  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_2		2232  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_2		2261  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_2		2290  /**/
+#define i3ds_asn1_Base_samples_RigidBodyAcceleration_REQUIRED_BYTES_FOR_ENCODING       322
+#define i3ds_asn1_Base_samples_RigidBodyAcceleration_REQUIRED_BITS_FOR_ENCODING        2572
+
+flag Base_samples_RigidBodyAcceleration_Encode(const Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION		2296  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_TIME_2		2175  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_2		2204  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_2		2233  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_2		2262  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_2		2291  /**/
+flag Base_samples_RigidBodyAcceleration_Decode(Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrench --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+    Base_Time time;
+
+} Base_samples_Wrench;
+
+void Base_samples_Wrench_Initialize(Base_samples_Wrench* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_WRENCH		2381  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_FORCE		2319  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_FORCE_DATA		2312  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_FORCE_DATA_ELM		2301  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_TORQUE		2348  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA		2341  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA_ELM		2330  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_TIME		2370  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_TIME_MICROSECONDS		2359  /**/
+flag Base_samples_Wrench_IsConstraintValid(const Base_samples_Wrench* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH		2382  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_FORCE_2		2326  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_TORQUE_2		2355  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_TIME_2		2377  /**/
+#define i3ds_asn1_Base_samples_Wrench_REQUIRED_BYTES_FOR_ENCODING       87
+#define i3ds_asn1_Base_samples_Wrench_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_samples_Wrench_Encode(const Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH		2383  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_FORCE_2		2327  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_TORQUE_2		2356  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_TIME_2		2378  /**/
+flag Base_samples_Wrench_Decode(Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Pointcloud --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector3d arr[200];
+} Base_samples_Pointcloud_points;
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector4d arr[200];
+} Base_samples_Pointcloud_colors;
+typedef struct {
+    Base_Time time;
+    Base_samples_Pointcloud_points points;
+    Base_samples_Pointcloud_colors colors;
+
+} Base_samples_Pointcloud;
+
+void Base_samples_Pointcloud_points_Initialize(Base_samples_Pointcloud_points* pVal);
+void Base_samples_Pointcloud_colors_Initialize(Base_samples_Pointcloud_colors* pVal);
+void Base_samples_Pointcloud_Initialize(Base_samples_Pointcloud* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD		3900  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_TIME		3817  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_TIME_MICROSECONDS		3806  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_POINTS		3857  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM		3846  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA		3839  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA_ELM		3828  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_COLORS		3893  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM		3882  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA		3875  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA_ELM		3864  /**/
+flag Base_samples_Pointcloud_IsConstraintValid(const Base_samples_Pointcloud* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD		3901  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_TIME_2		3824  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_POINTS		3858  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_2		3853  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_COLORS		3894  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_2		3889  /**/
+#define i3ds_asn1_Base_samples_Pointcloud_REQUIRED_BYTES_FOR_ENCODING       18310
+#define i3ds_asn1_Base_samples_Pointcloud_REQUIRED_BITS_FOR_ENCODING        146480
+
+flag Base_samples_Pointcloud_Encode(const Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD		3902  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_TIME_2		3825  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS		3859  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_2		3854  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS		3895  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_2		3890  /**/
+flag Base_samples_Pointcloud_Decode(Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_SonarBeam --------------------------------------------*/
+typedef struct {
+    int nCount;
+
+    byte arr[200];
+} Base_samples_SonarBeam_beam;
+
+typedef struct {
+    Base_Time time;
+    Base_Angle bearing;
+    T_Double sampling_interval;
+    T_Float speed_of_sound;
+    T_Float beamwidth_horizontal;
+    T_Float beamwidth_vertical;
+    Base_samples_SonarBeam_beam beam;
+
+} Base_samples_SonarBeam;
+
+void Base_samples_SonarBeam_beam_Initialize(Base_samples_SonarBeam_beam* pVal);
+void Base_samples_SonarBeam_Initialize(Base_samples_SonarBeam* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM		4500  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_TIME		4416  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_TIME_MICROSECONDS		4405  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEARING		4438  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEARING_RAD		4427  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL		4449  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND		4460  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL		4471  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL		4482  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEAM		4493  /**/
+flag Base_samples_SonarBeam_IsConstraintValid(const Base_samples_SonarBeam* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM		4501  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_TIME_2		4423  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEARING_2		4445  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL_2		4456  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND_2		4467  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL_2		4478  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL_2		4489  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARBEAM_BEAM		4494  /**/
+#define i3ds_asn1_Base_samples_SonarBeam_REQUIRED_BYTES_FOR_ENCODING       274
+#define i3ds_asn1_Base_samples_SonarBeam_REQUIRED_BITS_FOR_ENCODING        2192
+
+flag Base_samples_SonarBeam_Encode(const Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM		4502  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_TIME_2		4424  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEARING_2		4446  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL_2		4457  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND_2		4468  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL_2		4479  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL_2		4490  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM		4495  /**/
+flag Base_samples_SonarBeam_Decode(Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_LinearAngular6DCommand_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d linear;
+    Wrappers_Vector3d angular;
+
+} Base_commands_LinearAngular6DCommand_m;
+
+void Base_commands_LinearAngular6DCommand_m_Initialize(Base_commands_LinearAngular6DCommand_m* pVal);
+
+#define i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M		6610  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME		6541  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_MICROSECONDS		6530  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR		6570  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA		6563  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA_ELM		6552  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR		6599  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA		6592  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA_ELM		6581  /**/
+flag Base_commands_LinearAngular6DCommand_m_IsConstraintValid(const Base_commands_LinearAngular6DCommand_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M		6611  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_2		6548  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_2		6577  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_2		6606  /**/
+#define i3ds_asn1_Base_commands_LinearAngular6DCommand_m_REQUIRED_BYTES_FOR_ENCODING       87
+#define i3ds_asn1_Base_commands_LinearAngular6DCommand_m_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_commands_LinearAngular6DCommand_m_Encode(const Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M		6612  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_TIME_2		6549  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_2		6578  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_2		6607  /**/
+flag Base_commands_LinearAngular6DCommand_m_Decode(Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_BodyState_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Base_TransformWithCovariance_m pose;
+    Base_TwistWithCovariance_m velocity;
+
+} Base_samples_BodyState_m;
+
+void Base_samples_BodyState_m_Initialize(Base_samples_BodyState_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M		6846  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_TIME		6628  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_TIME_MICROSECONDS		6617  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE		6737  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION		6657  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA		6650  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA_ELM		6639  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION		6697  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM		6679  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM_ELM		6668  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_RE		6686  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV		6726  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA		6719  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA_ELM		6708  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY		6835  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL		6766  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA		6759  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA_ELM		6748  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT		6795  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA		6788  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA_ELM		6777  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV		6824  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA		6817  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA_ELM		6806  /**/
+flag Base_samples_BodyState_m_IsConstraintValid(const Base_samples_BodyState_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M		6847  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M_TIME_2		6635  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M_POSE_2		6744  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_2		6842  /**/
+#define i3ds_asn1_Base_samples_BodyState_m_REQUIRED_BYTES_FOR_ENCODING       1116
+#define i3ds_asn1_Base_samples_BodyState_m_REQUIRED_BITS_FOR_ENCODING        8924
+
+flag Base_samples_BodyState_m_Encode(const Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M		6848  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M_TIME_2		6636  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M_POSE_2		6745  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_BODYSTATE_M_VELOCITY_2		6843  /**/
+flag Base_samples_BodyState_m_Decode(Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_IMUSensors_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acc;
+    Wrappers_Vector3d gyro;
+    Wrappers_Vector3d mag;
+
+} Base_samples_IMUSensors_m;
+
+void Base_samples_IMUSensors_m_Initialize(Base_samples_IMUSensors_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M		6962  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_TIME		6864  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_TIME_MICROSECONDS		6853  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_ACC		6893  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA		6886  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA_ELM		6875  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO		6922  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA		6915  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA_ELM		6904  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_MAG		6951  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA		6944  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA_ELM		6933  /**/
+flag Base_samples_IMUSensors_m_IsConstraintValid(const Base_samples_IMUSensors_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M		6963  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_TIME_2		6871  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_ACC_2		6900  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_GYRO_2		6929  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_IMUSENSORS_M_MAG_2		6958  /**/
+#define i3ds_asn1_Base_samples_IMUSensors_m_REQUIRED_BYTES_FOR_ENCODING       126
+#define i3ds_asn1_Base_samples_IMUSensors_m_REQUIRED_BITS_FOR_ENCODING        1006
+
+flag Base_samples_IMUSensors_m_Encode(const Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M		6964  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_TIME_2		6872  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_ACC_2		6901  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_GYRO_2		6930  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_IMUSENSORS_M_MAG_2		6959  /**/
+flag Base_samples_IMUSensors_m_Decode(Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyAcceleration_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Wrappers_Vector3d acceleration;
+    Wrappers_Matrix3d cov_acceleration;
+    Wrappers_Vector3d angular_acceleration;
+    Wrappers_Matrix3d cov_angular_acceleration;
+
+} Base_samples_RigidBodyAcceleration_m;
+
+void Base_samples_RigidBodyAcceleration_m_Initialize(Base_samples_RigidBodyAcceleration_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M		7107  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME		6980  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_MICROSECONDS		6969  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION		7009  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA		7002  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA_ELM		6991  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION		7038  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA		7031  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA_ELM		7020  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION		7067  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA		7060  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA_ELM		7049  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION		7096  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA		7089  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA_ELM		7078  /**/
+flag Base_samples_RigidBodyAcceleration_m_IsConstraintValid(const Base_samples_RigidBodyAcceleration_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M		7108  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_2		6987  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_2		7016  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_2		7045  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_2		7074  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_2		7103  /**/
+#define i3ds_asn1_Base_samples_RigidBodyAcceleration_m_REQUIRED_BYTES_FOR_ENCODING       322
+#define i3ds_asn1_Base_samples_RigidBodyAcceleration_m_REQUIRED_BITS_FOR_ENCODING        2572
+
+flag Base_samples_RigidBodyAcceleration_m_Encode(const Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M		7109  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_TIME_2		6988  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_2		7017  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_2		7046  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_2		7075  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_2		7104  /**/
+flag Base_samples_RigidBodyAcceleration_m_Decode(Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrench_m --------------------------------------------*/
+typedef struct {
+    Wrappers_Vector3d force;
+    Wrappers_Vector3d torque;
+    Base_Time time;
+
+} Base_samples_Wrench_m;
+
+void Base_samples_Wrench_m_Initialize(Base_samples_Wrench_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M		7488  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_FORCE		7426  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA		7419  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA_ELM		7408  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_TORQUE		7455  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA		7448  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA_ELM		7437  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_TIME		7477  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_TIME_MICROSECONDS		7466  /**/
+flag Base_samples_Wrench_m_IsConstraintValid(const Base_samples_Wrench_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M		7489  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M_FORCE_2		7433  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M_TORQUE_2		7462  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCH_M_TIME_2		7484  /**/
+#define i3ds_asn1_Base_samples_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       87
+#define i3ds_asn1_Base_samples_Wrench_m_REQUIRED_BITS_FOR_ENCODING        692
+
+flag Base_samples_Wrench_m_Encode(const Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M		7490  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M_FORCE_2		7434  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M_TORQUE_2		7463  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCH_M_TIME_2		7485  /**/
+flag Base_samples_Wrench_m_Decode(Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Pointcloud_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector3d arr[200];
+} Base_samples_Pointcloud_m_points;
+
+
+typedef struct {
+    int nCount;
+
+    Wrappers_Vector4d arr[200];
+} Base_samples_Pointcloud_m_colors;
+typedef struct {
+    Base_Time time;
+    Base_samples_Pointcloud_m_points points;
+    Base_samples_Pointcloud_m_colors colors;
+
+} Base_samples_Pointcloud_m;
+
+void Base_samples_Pointcloud_m_points_Initialize(Base_samples_Pointcloud_m_points* pVal);
+void Base_samples_Pointcloud_m_colors_Initialize(Base_samples_Pointcloud_m_colors* pVal);
+void Base_samples_Pointcloud_m_Initialize(Base_samples_Pointcloud_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M		7890  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_TIME		7807  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_TIME_MICROSECONDS		7796  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS		7847  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM		7836  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA		7829  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA_ELM		7818  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS		7883  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM		7872  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA		7865  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA_ELM		7854  /**/
+flag Base_samples_Pointcloud_m_IsConstraintValid(const Base_samples_Pointcloud_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M		7891  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_TIME_2		7814  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_POINTS		7848  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_2		7843  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_COLORS		7884  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_2		7879  /**/
+#define i3ds_asn1_Base_samples_Pointcloud_m_REQUIRED_BYTES_FOR_ENCODING       18310
+#define i3ds_asn1_Base_samples_Pointcloud_m_REQUIRED_BITS_FOR_ENCODING        146480
+
+flag Base_samples_Pointcloud_m_Encode(const Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M		7892  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_TIME_2		7815  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS		7849  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_2		7844  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS		7885  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_2		7880  /**/
+flag Base_samples_Pointcloud_m_Decode(Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_frame_size_t --------------------------------------------*/
+typedef struct {
+    T_UInt16 width;
+    T_UInt16 height;
+
+} Base_samples_frame_frame_size_t;
+
+void Base_samples_frame_frame_size_t_Initialize(Base_samples_frame_frame_size_t* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T		2410  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH		2388  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT		2399  /**/
+flag Base_samples_frame_frame_size_t_IsConstraintValid(const Base_samples_frame_frame_size_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T		2411  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH_2		2395  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT_2		2406  /**/
+#define i3ds_asn1_Base_samples_frame_frame_size_t_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_Base_samples_frame_frame_size_t_REQUIRED_BITS_FOR_ENCODING        32
+
+flag Base_samples_frame_frame_size_t_Encode(const Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T		2412  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH_2		2396  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT_2		2407  /**/
+flag Base_samples_frame_frame_size_t_Decode(Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_DistanceImage --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_DistanceImage_data;
+typedef struct {
+    Base_Time time;
+    T_UInt16 width;
+    T_UInt16 height;
+    T_Float scale_x;
+    T_Float scale_y;
+    T_Float center_x;
+    T_Float center_y;
+    Base_samples_DistanceImage_data data;
+
+} Base_samples_DistanceImage;
+
+void Base_samples_DistanceImage_data_Initialize(Base_samples_DistanceImage_data* pVal);
+void Base_samples_DistanceImage_Initialize(Base_samples_DistanceImage* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE		3555  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_TIME		3460  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_TIME_MICROSECONDS		3449  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_WIDTH		3471  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT		3482  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X		3493  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y		3504  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X		3515  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y		3526  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA		3548  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM		3537  /**/
+flag Base_samples_DistanceImage_IsConstraintValid(const Base_samples_DistanceImage* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE		3556  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_TIME_2		3467  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_WIDTH_2		3478  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT_2		3489  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X_2		3500  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y_2		3511  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X_2		3522  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y_2		3533  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_DATA		3549  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM_2		3544  /**/
+#define i3ds_asn1_Base_samples_DistanceImage_REQUIRED_BYTES_FOR_ENCODING       2665
+#define i3ds_asn1_Base_samples_DistanceImage_REQUIRED_BITS_FOR_ENCODING        21320
+
+flag Base_samples_DistanceImage_Encode(const Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE		3557  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_TIME_2		3468  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_WIDTH_2		3479  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT_2		3490  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X_2		3501  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y_2		3512  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X_2		3523  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y_2		3534  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA		3550  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM_2		3545  /**/
+flag Base_samples_DistanceImage_Decode(Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointLimits --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointLimits_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointLimitRange arr[200];
+} Base_JointLimits_elements;
+typedef struct {
+    Base_JointLimits_names names;
+    Base_JointLimits_elements elements;
+
+} Base_JointLimits;
+
+void Base_JointLimits_names_Initialize(Base_JointLimits_names* pVal);
+void Base_JointLimits_elements_Initialize(Base_JointLimits_elements* pVal);
+void Base_JointLimits_Initialize(Base_JointLimits* pVal);
+
+#define i3ds_asn1_ERR_BASE_JOINTLIMITS		2585  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_NAMES		2428  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_NAMES_ELM		2417  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS		2578  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM		2567  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN		2490  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_POSITION		2435  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_SPEED		2446  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_EFFORT		2457  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_RAW		2468  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_ACCELERATION		2479  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX		2556  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_POSITION		2501  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_SPEED		2512  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_EFFORT		2523  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_RAW		2534  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_ACCELERATION		2545  /**/
+flag Base_JointLimits_IsConstraintValid(const Base_JointLimits* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITS		2586  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITS_NAMES		2429  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITS_NAMES_ELM_2		2424  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITS_ELEMENTS		2579  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTLIMITS_ELEMENTS_ELM_2		2574  /**/
+#define i3ds_asn1_Base_JointLimits_REQUIRED_BYTES_FOR_ENCODING       34152
+#define i3ds_asn1_Base_JointLimits_REQUIRED_BITS_FOR_ENCODING        273216
+
+flag Base_JointLimits_Encode(const Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITS		2587  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES		2430  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES_ELM_2		2425  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS		2580  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS_ELM_2		2575  /**/
+flag Base_JointLimits_Decode(Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransform --------------------------------------------*/
+typedef struct {
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d rotationaxis;
+
+} Base_JointTransform;
+
+void Base_JointTransform_Initialize(Base_JointTransform* pVal);
+
+#define i3ds_asn1_ERR_BASE_JOINTTRANSFORM		2643  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_SOURCEFRAME		2592  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_TARGETFRAME		2603  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS		2632  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA		2625  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA_ELM		2614  /**/
+flag Base_JointTransform_IsConstraintValid(const Base_JointTransform* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM		2644  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_SOURCEFRAME_2		2599  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_TARGETFRAME_2		2610  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_ROTATIONAXIS_2		2639  /**/
+#define i3ds_asn1_Base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       121
+#define i3ds_asn1_Base_JointTransform_REQUIRED_BITS_FOR_ENCODING        966
+
+flag Base_JointTransform_Encode(const Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM		2645  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM_SOURCEFRAME_2		2600  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM_TARGETFRAME_2		2611  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM_ROTATIONAXIS_2		2640  /**/
+flag Base_JointTransform_Decode(Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransformVector --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointTransformVector_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTransform arr[200];
+} Base_JointTransformVector_elements;
+typedef struct {
+    Base_JointTransformVector_names names;
+    Base_JointTransformVector_elements elements;
+
+} Base_JointTransformVector;
+
+void Base_JointTransformVector_names_Initialize(Base_JointTransformVector_names* pVal);
+void Base_JointTransformVector_elements_Initialize(Base_JointTransformVector_elements* pVal);
+void Base_JointTransformVector_Initialize(Base_JointTransformVector* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR		4965  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_NAMES		4889  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM		4878  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS		4958  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM		4947  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME		4896  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME		4907  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS		4936  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA		4929  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		4918  /**/
+flag Base_JointTransformVector_IsConstraintValid(const Base_JointTransformVector* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR		4966  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_NAMES		4890  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM_2		4885  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS		4959  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_2		4954  /**/
+#define i3ds_asn1_Base_JointTransformVector_REQUIRED_BYTES_FOR_ENCODING       32302
+#define i3ds_asn1_Base_JointTransformVector_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_JointTransformVector_Encode(const Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR		4967  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES		4891  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM_2		4886  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS		4960  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_2		4955  /**/
+flag Base_JointTransformVector_Decode(Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointTransform --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointTransform_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTransform arr[200];
+} Base_NamedVector_Base_JointTransform_elements;
+typedef struct {
+    Base_NamedVector_Base_JointTransform_names names;
+    Base_NamedVector_Base_JointTransform_elements elements;
+
+} Base_NamedVector_Base_JointTransform;
+
+void Base_NamedVector_Base_JointTransform_names_Initialize(Base_NamedVector_Base_JointTransform_names* pVal);
+void Base_NamedVector_Base_JointTransform_elements_Initialize(Base_NamedVector_Base_JointTransform_elements* pVal);
+void Base_NamedVector_Base_JointTransform_Initialize(Base_NamedVector_Base_JointTransform* pVal);
+
+#define i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM		5059  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES		4983  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM		4972  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS		5052  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM		5041  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME		4990  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME		5001  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS		5030  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA		5023  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		5012  /**/
+flag Base_NamedVector_Base_JointTransform_IsConstraintValid(const Base_NamedVector_Base_JointTransform* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM		5060  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES		4984  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM_2		4979  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS		5053  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_2		5048  /**/
+#define Base_NamedVector_i3ds_asn1_Base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       32302
+#define Base_NamedVector_i3ds_asn1_Base_JointTransform_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_NamedVector_Base_JointTransform_Encode(const Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM		5061  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES		4985  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM_2		4980  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS		5054  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_2		5049  /**/
+flag Base_NamedVector_Base_JointTransform_Decode(Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointsTrajectory --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointsTrajectory_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTrajectory arr[200];
+} Base_JointsTrajectory_elements;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_JointsTrajectory_times_val;
+typedef struct {
+    Base_JointsTrajectory_names names;
+    Base_JointsTrajectory_elements elements;
+    Base_JointsTrajectory_times_val times_val;
+
+} Base_JointsTrajectory;
+
+void Base_JointsTrajectory_names_Initialize(Base_JointsTrajectory_names* pVal);
+void Base_JointsTrajectory_elements_Initialize(Base_JointsTrajectory_elements* pVal);
+void Base_JointsTrajectory_times_val_Initialize(Base_JointsTrajectory_times_val* pVal);
+void Base_JointsTrajectory_Initialize(Base_JointsTrajectory* pVal);
+
+#define i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY		2781  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_NAMES		2661  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_NAMES_ELM		2650  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS		2745  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM		2734  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM		2723  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_POSITION		2668  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_SPEED		2679  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT		2690  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_RAW		2701  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION		2712  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL		2774  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM		2763  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_MICROSECONDS		2752  /**/
+flag Base_JointsTrajectory_IsConstraintValid(const Base_JointsTrajectory* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY		2782  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_NAMES		2662  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_NAMES_ELM_2		2657  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_ELEMENTS		2746  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_2		2741  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_TIMES_VAL		2775  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_2		2770  /**/
+#define i3ds_asn1_Base_JointsTrajectory_REQUIRED_BYTES_FOR_ENCODING       2609953
+#define i3ds_asn1_Base_JointsTrajectory_REQUIRED_BITS_FOR_ENCODING        20879624
+
+flag Base_JointsTrajectory_Encode(const Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY		2783  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES		2663  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES_ELM_2		2658  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS		2747  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_2		2742  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL		2776  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL_ELM_2		2771  /**/
+flag Base_JointsTrajectory_Decode(Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointLimitRange --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointLimitRange_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointLimitRange arr[200];
+} Base_NamedVector_Base_JointLimitRange_elements;
+typedef struct {
+    Base_NamedVector_Base_JointLimitRange_names names;
+    Base_NamedVector_Base_JointLimitRange_elements elements;
+
+} Base_NamedVector_Base_JointLimitRange;
+
+void Base_NamedVector_Base_JointLimitRange_names_Initialize(Base_NamedVector_Base_JointLimitRange_names* pVal);
+void Base_NamedVector_Base_JointLimitRange_elements_Initialize(Base_NamedVector_Base_JointLimitRange_elements* pVal);
+void Base_NamedVector_Base_JointLimitRange_Initialize(Base_NamedVector_Base_JointLimitRange* pVal);
+
+#define i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE		2956  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES		2799  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM		2788  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS		2949  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM		2938  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN		2861  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_POSITION		2806  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_SPEED		2817  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_EFFORT		2828  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_RAW		2839  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_ACCELERATION		2850  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX		2927  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_POSITION		2872  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_SPEED		2883  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_EFFORT		2894  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_RAW		2905  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_ACCELERATION		2916  /**/
+flag Base_NamedVector_Base_JointLimitRange_IsConstraintValid(const Base_NamedVector_Base_JointLimitRange* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE		2957  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES		2800  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM_2		2795  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS		2950  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_2		2945  /**/
+#define Base_NamedVector_i3ds_asn1_Base_JointLimitRange_REQUIRED_BYTES_FOR_ENCODING       34152
+#define Base_NamedVector_i3ds_asn1_Base_JointLimitRange_REQUIRED_BITS_FOR_ENCODING        273216
+
+flag Base_NamedVector_Base_JointLimitRange_Encode(const Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE		2958  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES		2801  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM_2		2796  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS		2951  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_2		2946  /**/
+flag Base_NamedVector_Base_JointLimitRange_Decode(Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointState --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointState_names;
+typedef struct {
+    Base_NamedVector_Base_JointState_names names;
+    Base_JointTrajectory elements;
+
+} Base_NamedVector_Base_JointState;
+
+void Base_NamedVector_Base_JointState_names_Initialize(Base_NamedVector_Base_JointState_names* pVal);
+void Base_NamedVector_Base_JointState_Initialize(Base_NamedVector_Base_JointState* pVal);
+
+#define i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE		3058  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES		2974  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM		2963  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS		3047  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM		3036  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_POSITION		2981  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_SPEED		2992  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_EFFORT		3003  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_RAW		3014  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_ACCELERATION		3025  /**/
+flag Base_NamedVector_Base_JointState_IsConstraintValid(const Base_NamedVector_Base_JointState* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE		3059  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES		2975  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM_2		2970  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_2		3054  /**/
+#define Base_NamedVector_i3ds_asn1_Base_JointState_REQUIRED_BYTES_FOR_ENCODING       21152
+#define Base_NamedVector_i3ds_asn1_Base_JointState_REQUIRED_BITS_FOR_ENCODING        169216
+
+flag Base_NamedVector_Base_JointState_Encode(const Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE		3060  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES		2976  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM_2		2971  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_2		3055  /**/
+flag Base_NamedVector_Base_JointState_Decode(Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_Wrench --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_Wrench_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Wrench arr[200];
+} Base_NamedVector_Base_Wrench_elements;
+typedef struct {
+    Base_NamedVector_Base_Wrench_names names;
+    Base_NamedVector_Base_Wrench_elements elements;
+
+} Base_NamedVector_Base_Wrench;
+
+void Base_NamedVector_Base_Wrench_names_Initialize(Base_NamedVector_Base_Wrench_names* pVal);
+void Base_NamedVector_Base_Wrench_elements_Initialize(Base_NamedVector_Base_Wrench_elements* pVal);
+void Base_NamedVector_Base_Wrench_Initialize(Base_NamedVector_Base_Wrench* pVal);
+
+#define i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH		3159  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES		3076  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM		3065  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS		3152  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM		3141  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE		3101  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA		3094  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA_ELM		3083  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE		3130  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA		3123  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA_ELM		3112  /**/
+flag Base_NamedVector_Base_Wrench_IsConstraintValid(const Base_NamedVector_Base_Wrench* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH		3160  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES		3077  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM_2		3072  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS		3153  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_2		3148  /**/
+#define Base_NamedVector_i3ds_asn1_Base_Wrench_REQUIRED_BYTES_FOR_ENCODING       23852
+#define Base_NamedVector_i3ds_asn1_Base_Wrench_REQUIRED_BITS_FOR_ENCODING        190816
+
+flag Base_NamedVector_Base_Wrench_Encode(const Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH		3161  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES		3078  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM_2		3073  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS		3154  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_2		3149  /**/
+flag Base_NamedVector_Base_Wrench_Decode(Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_Base_JointTrajectory --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_Base_JointTrajectory_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTrajectory arr[200];
+} Base_NamedVector_Base_JointTrajectory_elements;
+typedef struct {
+    Base_NamedVector_Base_JointTrajectory_names names;
+    Base_NamedVector_Base_JointTrajectory_elements elements;
+
+} Base_NamedVector_Base_JointTrajectory;
+
+void Base_NamedVector_Base_JointTrajectory_names_Initialize(Base_NamedVector_Base_JointTrajectory_names* pVal);
+void Base_NamedVector_Base_JointTrajectory_elements_Initialize(Base_NamedVector_Base_JointTrajectory_elements* pVal);
+void Base_NamedVector_Base_JointTrajectory_Initialize(Base_NamedVector_Base_JointTrajectory* pVal);
+
+#define i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY		3268  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES		3177  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM		3166  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS		3261  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM		3250  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM		3239  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_POSITION		3184  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_SPEED		3195  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT		3206  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_RAW		3217  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION		3228  /**/
+flag Base_NamedVector_Base_JointTrajectory_IsConstraintValid(const Base_NamedVector_Base_JointTrajectory* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY		3269  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES		3178  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM_2		3173  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS		3262  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_2		3257  /**/
+#define Base_NamedVector_i3ds_asn1_Base_JointTrajectory_REQUIRED_BYTES_FOR_ENCODING       2608352
+#define Base_NamedVector_i3ds_asn1_Base_JointTrajectory_REQUIRED_BITS_FOR_ENCODING        20866816
+
+flag Base_NamedVector_Base_JointTrajectory_Encode(const Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY		3270  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES		3179  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM_2		3174  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS		3263  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_2		3258  /**/
+flag Base_NamedVector_Base_JointTrajectory_Decode(Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_commands_Joints --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_commands_Joints_names;
+typedef struct {
+    Base_commands_Joints_names names;
+    Base_JointTrajectory elements;
+    Base_Time time;
+
+} Base_commands_Joints;
+
+void Base_commands_Joints_names_Initialize(Base_commands_Joints_names* pVal);
+void Base_commands_Joints_Initialize(Base_commands_Joints* pVal);
+
+#define i3ds_asn1_ERR_BASE_COMMANDS_JOINTS		3679  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_NAMES		3573  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_NAMES_ELM		3562  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS		3646  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM		3635  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_POSITION		3580  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_SPEED		3591  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_EFFORT		3602  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_RAW		3613  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_ACCELERATION		3624  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_TIME		3668  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_TIME_MICROSECONDS		3657  /**/
+flag Base_commands_Joints_IsConstraintValid(const Base_commands_Joints* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS		3680  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_NAMES		3574  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_NAMES_ELM_2		3569  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_ELEMENTS_2		3653  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_COMMANDS_JOINTS_TIME_2		3675  /**/
+#define i3ds_asn1_Base_commands_Joints_REQUIRED_BYTES_FOR_ENCODING       21160
+#define i3ds_asn1_Base_commands_Joints_REQUIRED_BITS_FOR_ENCODING        169280
+
+flag Base_commands_Joints_Encode(const Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_JOINTS		3681  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES		3575  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES_ELM_2		3570  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_ELEMENTS_2		3654  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_TIME_2		3676  /**/
+flag Base_commands_Joints_Decode(Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyState --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d position;
+    Wrappers_Matrix3d cov_position;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix3d cov_orientation;
+    Wrappers_Vector3d velocity;
+    Wrappers_Matrix3d cov_velocity;
+    Wrappers_Vector3d angular_velocity;
+    Wrappers_Matrix3d cov_angular_velocity;
+
+} Base_samples_RigidBodyState;
+
+void Base_samples_RigidBodyState_Initialize(Base_samples_RigidBodyState* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE		4194  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_TIME		3918  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_TIME_MICROSECONDS		3907  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME		3929  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME		3940  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION		3969  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA		3962  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA_ELM		3951  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION		3998  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA		3991  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA_ELM		3980  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION		4038  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM		4020  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM_ELM		4009  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_RE		4027  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION		4067  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA		4060  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA_ELM		4049  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY		4096  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA		4089  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA_ELM		4078  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY		4125  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA		4118  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA_ELM		4107  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY		4154  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA		4147  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA_ELM		4136  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY		4183  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA		4176  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA_ELM		4165  /**/
+flag Base_samples_RigidBodyState_IsConstraintValid(const Base_samples_RigidBodyState* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE		4195  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_TIME_2		3925  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME_2		3936  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME_2		3947  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_2		3976  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_2		4005  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_2		4045  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_2		4074  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_2		4103  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_2		4132  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_2		4161  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_2		4190  /**/
+#define i3ds_asn1_Base_samples_RigidBodyState_REQUIRED_BYTES_FOR_ENCODING       730
+#define i3ds_asn1_Base_samples_RigidBodyState_REQUIRED_BITS_FOR_ENCODING        5836
+
+flag Base_samples_RigidBodyState_Encode(const Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE		4196  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_TIME_2		3926  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME_2		3937  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME_2		3948  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_2		3977  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_2		4006  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_2		4046  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_2		4075  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_2		4104  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_2		4133  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_2		4162  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_2		4191  /**/
+flag Base_samples_RigidBodyState_Decode(Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrenches --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_samples_Wrenches_names;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Wrench arr[200];
+} Base_samples_Wrenches_elements;
+typedef struct {
+    Base_samples_Wrenches_names names;
+    Base_samples_Wrenches_elements elements;
+    Base_Time time;
+
+} Base_samples_Wrenches;
+
+void Base_samples_Wrenches_names_Initialize(Base_samples_Wrenches_names* pVal);
+void Base_samples_Wrenches_elements_Initialize(Base_samples_Wrenches_elements* pVal);
+void Base_samples_Wrenches_Initialize(Base_samples_Wrenches* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES		4842  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_NAMES		4737  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_NAMES_ELM		4726  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS		4813  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM		4802  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE		4762  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA		4755  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA_ELM		4744  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE		4791  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA		4784  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA_ELM		4773  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_TIME		4831  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_TIME_MICROSECONDS		4820  /**/
+flag Base_samples_Wrenches_IsConstraintValid(const Base_samples_Wrenches* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES		4843  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_NAMES		4738  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_NAMES_ELM_2		4733  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_ELEMENTS		4814  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_2		4809  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_TIME_2		4838  /**/
+#define i3ds_asn1_Base_samples_Wrenches_REQUIRED_BYTES_FOR_ENCODING       23860
+#define i3ds_asn1_Base_samples_Wrenches_REQUIRED_BITS_FOR_ENCODING        190880
+
+flag Base_samples_Wrenches_Encode(const Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES		4844  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES		4739  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES_ELM_2		4734  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS		4815  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_2		4810  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_TIME_2		4839  /**/
+flag Base_samples_Wrenches_Decode(Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_frame_attrib_t --------------------------------------------*/
+typedef struct {
+    T_String data;
+    T_String name_val;
+
+} Base_samples_frame_frame_attrib_t;
+
+void Base_samples_frame_frame_attrib_t_Initialize(Base_samples_frame_frame_attrib_t* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T		4871  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA		4849  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL		4860  /**/
+flag Base_samples_frame_frame_attrib_t_IsConstraintValid(const Base_samples_frame_frame_attrib_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T		4872  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA_2		4856  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL_2		4867  /**/
+#define i3ds_asn1_Base_samples_frame_frame_attrib_t_REQUIRED_BYTES_FOR_ENCODING       82
+#define i3ds_asn1_Base_samples_frame_frame_attrib_t_REQUIRED_BITS_FOR_ENCODING        652
+
+flag Base_samples_frame_frame_attrib_t_Encode(const Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T		4873  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA_2		4857  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL_2		4868  /**/
+flag Base_samples_frame_frame_attrib_t_Decode(Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransform_m --------------------------------------------*/
+typedef struct {
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d rotationaxis;
+
+} Base_JointTransform_m;
+
+void Base_JointTransform_m_Initialize(Base_JointTransform_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M		6067  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_SOURCEFRAME		6016  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_TARGETFRAME		6027  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS		6056  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA		6049  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA_ELM		6038  /**/
+flag Base_JointTransform_m_IsConstraintValid(const Base_JointTransform_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M		6068  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M_SOURCEFRAME_2		6023  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M_TARGETFRAME_2		6034  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_2		6063  /**/
+#define i3ds_asn1_Base_JointTransform_m_REQUIRED_BYTES_FOR_ENCODING       121
+#define i3ds_asn1_Base_JointTransform_m_REQUIRED_BITS_FOR_ENCODING        966
+
+flag Base_JointTransform_m_Encode(const Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M		6069  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M_SOURCEFRAME_2		6024  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M_TARGETFRAME_2		6035  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_2		6064  /**/
+flag Base_JointTransform_m_Decode(Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_JointTransform_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_JointTransform;
+
+void Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal);
+
+#define i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM		221  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM		210  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME		159  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME		170  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS		199  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA		192  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA_ELM		181  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM		222  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_2		217  /**/
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BYTES_FOR_ENCODING       24151
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_JointTransform_REQUIRED_BITS_FOR_ENCODING        193208
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM		223  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_2		218  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_JointTransformVector_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_JointTransformVector_m_names;
+typedef struct {
+    Base_JointTransformVector_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_JointTransform elements;
+
+} Base_JointTransformVector_m;
+
+void Base_JointTransformVector_m_names_Initialize(Base_JointTransformVector_m_names* pVal);
+void Base_JointTransformVector_m_Initialize(Base_JointTransformVector_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M		7586  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES		7506  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM		7495  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS		7575  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM		7564  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME		7513  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME		7524  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS		7553  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA		7546  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		7535  /**/
+flag Base_JointTransformVector_m_IsConstraintValid(const Base_JointTransformVector_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M		7587  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES		7507  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM_2		7502  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_2		7582  /**/
+#define i3ds_asn1_Base_JointTransformVector_m_REQUIRED_BYTES_FOR_ENCODING       32302
+#define i3ds_asn1_Base_JointTransformVector_m_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_JointTransformVector_m_Encode(const Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M		7588  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES		7508  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM_2		7503  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_2		7583  /**/
+flag Base_JointTransformVector_m_Decode(Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_base_JointTransform_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_base_JointTransform_m_names;
+typedef struct {
+    Base_NamedVector_base_JointTransform_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_JointTransform elements;
+
+} Base_NamedVector_base_JointTransform_m;
+
+void Base_NamedVector_base_JointTransform_m_names_Initialize(Base_NamedVector_base_JointTransform_m_names* pVal);
+void Base_NamedVector_base_JointTransform_m_Initialize(Base_NamedVector_base_JointTransform_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M		7684  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES		7604  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM		7593  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS		7673  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM		7662  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME		7611  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME		7622  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS		7651  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA		7644  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM		7633  /**/
+flag Base_NamedVector_base_JointTransform_m_IsConstraintValid(const Base_NamedVector_base_JointTransform_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M		7685  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES		7605  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM_2		7600  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_2		7680  /**/
+#define i3ds_asn1_Base_NamedVector_base_JointTransform_m_REQUIRED_BYTES_FOR_ENCODING       32302
+#define i3ds_asn1_Base_NamedVector_base_JointTransform_m_REQUIRED_BITS_FOR_ENCODING        258416
+
+flag Base_NamedVector_base_JointTransform_m_Encode(const Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M		7686  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES		7606  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM_2		7601  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_2		7681  /**/
+flag Base_NamedVector_base_JointTransform_m_Decode(Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_RigidBodyState_m --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    T_String sourceframe;
+    T_String targetframe;
+    Wrappers_Vector3d position;
+    Wrappers_Matrix3d cov_position;
+    Wrappers_Quaterniond orientation;
+    Wrappers_Matrix3d cov_orientation;
+    Wrappers_Vector3d velocity;
+    Wrappers_Matrix3d cov_velocity;
+    Wrappers_Vector3d angular_velocity;
+    Wrappers_Matrix3d cov_angular_velocity;
+
+} Base_samples_RigidBodyState_m;
+
+void Base_samples_RigidBodyState_m_Initialize(Base_samples_RigidBodyState_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M		7401  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME		7125  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_MICROSECONDS		7114  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME		7136  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME		7147  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION		7176  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA		7169  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA_ELM		7158  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION		7205  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA		7198  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA_ELM		7187  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION		7245  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM		7227  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM_ELM		7216  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_RE		7234  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION		7274  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA		7267  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA_ELM		7256  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY		7303  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA		7296  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA_ELM		7285  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY		7332  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA		7325  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA_ELM		7314  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY		7361  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA		7354  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA_ELM		7343  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY		7390  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA		7383  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA_ELM		7372  /**/
+flag Base_samples_RigidBodyState_m_IsConstraintValid(const Base_samples_RigidBodyState_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M		7402  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_2		7132  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME_2		7143  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME_2		7154  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_2		7183  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_2		7212  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_2		7252  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_2		7281  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_2		7310  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_2		7339  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_2		7368  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_2		7397  /**/
+#define i3ds_asn1_Base_samples_RigidBodyState_m_REQUIRED_BYTES_FOR_ENCODING       730
+#define i3ds_asn1_Base_samples_RigidBodyState_m_REQUIRED_BITS_FOR_ENCODING        5836
+
+flag Base_samples_RigidBodyState_m_Encode(const Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M		7403  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TIME_2		7133  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME_2		7144  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME_2		7155  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_2		7184  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_2		7213  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_2		7253  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_2		7282  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_2		7311  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_2		7340  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_2		7369  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_2		7398  /**/
+flag Base_samples_RigidBodyState_m_Decode(Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_NamedVector_base_Wrench_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_NamedVector_base_Wrench_m_names;
+typedef struct {
+    Base_NamedVector_base_Wrench_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_Wrench elements;
+
+} Base_NamedVector_base_Wrench_m;
+
+void Base_NamedVector_base_Wrench_m_names_Initialize(Base_NamedVector_base_Wrench_m_names* pVal);
+void Base_NamedVector_base_Wrench_m_Initialize(Base_NamedVector_base_Wrench_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M		7789  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES		7702  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM		7691  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS		7778  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM		7767  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE		7727  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA		7720  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA_ELM		7709  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE		7756  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA		7749  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA_ELM		7738  /**/
+flag Base_NamedVector_base_Wrench_m_IsConstraintValid(const Base_NamedVector_base_Wrench_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M		7790  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES		7703  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM_2		7698  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_2		7785  /**/
+#define i3ds_asn1_Base_NamedVector_base_Wrench_m_REQUIRED_BYTES_FOR_ENCODING       23852
+#define i3ds_asn1_Base_NamedVector_base_Wrench_m_REQUIRED_BITS_FOR_ENCODING        190816
+
+flag Base_NamedVector_base_Wrench_m_Encode(const Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M		7791  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES		7704  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM_2		7699  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_2		7786  /**/
+flag Base_NamedVector_base_Wrench_m_Decode(Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Wrenches_m --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_String arr[200];
+} Base_samples_Wrenches_m_names;
+typedef struct {
+    Base_samples_Wrenches_m_names names;
+    Std_orogen_typekits_mtype_std_vector_base_Wrench elements;
+    Base_Time time;
+
+} Base_samples_Wrenches_m;
+
+void Base_samples_Wrenches_m_names_Initialize(Base_samples_Wrenches_m_names* pVal);
+void Base_samples_Wrenches_m_Initialize(Base_samples_Wrenches_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M		8017  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_NAMES		7908  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_NAMES_ELM		7897  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS		7984  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM		7973  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE		7933  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA		7926  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA_ELM		7915  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE		7962  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA		7955  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA_ELM		7944  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_TIME		8006  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_TIME_MICROSECONDS		7995  /**/
+flag Base_samples_Wrenches_m_IsConstraintValid(const Base_samples_Wrenches_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M		8018  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_NAMES		7909  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_NAMES_ELM_2		7904  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_2		7991  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_WRENCHES_M_TIME_2		8013  /**/
+#define i3ds_asn1_Base_samples_Wrenches_m_REQUIRED_BYTES_FOR_ENCODING       23860
+#define i3ds_asn1_Base_samples_Wrenches_m_REQUIRED_BITS_FOR_ENCODING        190880
+
+flag Base_samples_Wrenches_m_Encode(const Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M		8019  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES		7910  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES_ELM_2		7905  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_ELEMENTS_2		7992  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_TIME_2		8014  /**/
+flag Base_samples_Wrenches_m_Decode(Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_LaserScan --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_UInt32 arr[200];
+} Base_samples_LaserScan_ranges;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_LaserScan_remission;
+typedef struct {
+    Base_Time time;
+    T_Double start_angle;
+    T_Double angular_resolution;
+    T_Double speed;
+    Base_samples_LaserScan_ranges ranges;
+    T_UInt32 minrange;
+    T_UInt32 maxrange;
+    Base_samples_LaserScan_remission remission;
+
+} Base_samples_LaserScan;
+
+void Base_samples_LaserScan_ranges_Initialize(Base_samples_LaserScan_ranges* pVal);
+void Base_samples_LaserScan_remission_Initialize(Base_samples_LaserScan_remission* pVal);
+void Base_samples_LaserScan_Initialize(Base_samples_LaserScan* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN		3799  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_TIME		3697  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_TIME_MICROSECONDS		3686  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_START_ANGLE		3708  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION		3719  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_SPEED		3730  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_RANGES		3752  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_RANGES_ELM		3741  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_MINRANGE		3759  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_MAXRANGE		3770  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_REMISSION		3792  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_REMISSION_ELM		3781  /**/
+flag Base_samples_LaserScan_IsConstraintValid(const Base_samples_LaserScan* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN		3800  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_TIME_2		3704  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_START_ANGLE_2		3715  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION_2		3726  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_SPEED_2		3737  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_RANGES		3753  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_RANGES_ELM_2		3748  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_MINRANGE_2		3766  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_MAXRANGE_2		3777  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_REMISSION		3793  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASERSCAN_REMISSION_ELM_2		3788  /**/
+#define i3ds_asn1_Base_samples_LaserScan_REQUIRED_BYTES_FOR_ENCODING       3457
+#define i3ds_asn1_Base_samples_LaserScan_REQUIRED_BITS_FOR_ENCODING        27656
+
+flag Base_samples_LaserScan_Encode(const Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN		3801  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_TIME_2		3705  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_START_ANGLE_2		3716  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION_2		3727  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_SPEED_2		3738  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES		3754  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES_ELM_2		3749  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_MINRANGE_2		3767  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_MAXRANGE_2		3778  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION		3794  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION_ELM_2		3789  /**/
+flag Base_samples_LaserScan_Decode(Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_Sonar --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_samples_Sonar_timestamps;
+
+
+typedef struct {
+    int nCount;
+
+    Base_Angle arr[200];
+} Base_samples_Sonar_bearings;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_Sonar_bins;
+typedef struct {
+    Base_Time time;
+    Base_samples_Sonar_timestamps timestamps;
+    Base_Time bin_duration;
+    Base_Angle beam_width;
+    Base_Angle beam_height;
+    Base_samples_Sonar_bearings bearings;
+    T_Float speed_of_sound;
+    T_UInt32 bin_count;
+    T_UInt32 beam_count;
+    Base_samples_Sonar_bins bins;
+
+} Base_samples_Sonar;
+
+void Base_samples_Sonar_timestamps_Initialize(Base_samples_Sonar_timestamps* pVal);
+void Base_samples_Sonar_bearings_Initialize(Base_samples_Sonar_bearings* pVal);
+void Base_samples_Sonar_bins_Initialize(Base_samples_Sonar_bins* pVal);
+void Base_samples_Sonar_Initialize(Base_samples_Sonar* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_SONAR		4398  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_TIME		4212  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_TIME_MICROSECONDS		4201  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_TIMESTAMPS		4245  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM		4234  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_MICROSECONDS		4223  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BIN_DURATION		4263  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BIN_DURATION_MICROSECONDS		4252  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH		4285  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH_RAD		4274  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT		4307  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT_RAD		4296  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEARINGS		4340  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM		4329  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM_RAD		4318  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_SPEED_OF_SOUND		4347  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BIN_COUNT		4358  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_COUNT		4369  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BINS		4391  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BINS_ELM		4380  /**/
+flag Base_samples_Sonar_IsConstraintValid(const Base_samples_Sonar* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR		4399  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_TIME_2		4219  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_TIMESTAMPS		4246  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_2		4241  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BIN_DURATION_2		4270  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEAM_WIDTH_2		4292  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEAM_HEIGHT_2		4314  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEARINGS		4341  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEARINGS_ELM_2		4336  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_SPEED_OF_SOUND_2		4354  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BIN_COUNT_2		4365  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BEAM_COUNT_2		4376  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BINS		4392  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONAR_BINS_ELM_2		4387  /**/
+#define i3ds_asn1_Base_samples_Sonar_REQUIRED_BYTES_FOR_ENCODING       6866
+#define i3ds_asn1_Base_samples_Sonar_REQUIRED_BITS_FOR_ENCODING        54928
+
+flag Base_samples_Sonar_Encode(const Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR		4400  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIME_2		4220  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS		4247  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS_ELM_2		4242  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BIN_DURATION_2		4271  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEAM_WIDTH_2		4293  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEAM_HEIGHT_2		4315  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS		4342  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS_ELM_2		4337  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_SPEED_OF_SOUND_2		4355  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BIN_COUNT_2		4366  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEAM_COUNT_2		4377  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS		4393  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS_ELM_2		4388  /**/
+flag Base_samples_Sonar_Decode(Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_SonarScan --------------------------------------------*/
+typedef struct {
+    int nCount;
+
+    byte arr[200];
+} Base_samples_SonarScan_data;
+
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_samples_SonarScan_time_beams;
+typedef struct {
+    Base_Time time;
+    Base_samples_SonarScan_data data;
+    Base_samples_SonarScan_time_beams time_beams;
+    T_UInt16 number_of_beams;
+    T_UInt16 number_of_bins;
+    Base_Angle start_bearing;
+    Base_Angle angular_resolution;
+    T_Double sampling_interval;
+    T_Float speed_of_sound;
+    Base_Angle beamwidth_horizontal;
+    Base_Angle beamwidth_vertical;
+    T_Boolean memory_layout_column;
+    T_Boolean polar_coordinates;
+
+} Base_samples_SonarScan;
+
+void Base_samples_SonarScan_data_Initialize(Base_samples_SonarScan_data* pVal);
+void Base_samples_SonarScan_time_beams_Initialize(Base_samples_SonarScan_time_beams* pVal);
+void Base_samples_SonarScan_Initialize(Base_samples_SonarScan* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN		4719  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_TIME		4518  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_TIME_MICROSECONDS		4507  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_DATA		4529  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS		4558  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM		4547  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_MICROSECONDS		4536  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS		4565  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS		4576  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_START_BEARING		4598  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_START_BEARING_RAD		4587  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION		4620  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_RAD		4609  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL		4631  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND		4642  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL		4664  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_RAD		4653  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL		4686  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_RAD		4675  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN		4697  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES		4708  /**/
+flag Base_samples_SonarScan_IsConstraintValid(const Base_samples_SonarScan* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN		4720  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_TIME_2		4525  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_DATA		4530  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS		4559  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_2		4554  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS_2		4572  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS_2		4583  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_START_BEARING_2		4605  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_2		4627  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL_2		4638  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND_2		4649  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_2		4671  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_2		4693  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN_2		4704  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES_2		4715  /**/
+#define i3ds_asn1_Base_samples_SonarScan_REQUIRED_BYTES_FOR_ENCODING       1893
+#define i3ds_asn1_Base_samples_SonarScan_REQUIRED_BITS_FOR_ENCODING        15138
+
+flag Base_samples_SonarScan_Encode(const Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN		4721  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_2		4526  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA		4531  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS		4560  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS_ELM_2		4555  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS_2		4573  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS_2		4584  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_START_BEARING_2		4606  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_2		4628  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL_2		4639  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND_2		4650  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_2		4672  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_2		4694  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_MEMORY_LAYOUT_COLUMN_2		4705  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_POLAR_COORDINATES_2		4716  /**/
+flag Base_samples_SonarScan_Decode(Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_MatrixXd --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_MatrixXd_data;
+typedef struct {
+    T_Int32 rows;
+    T_Int32 cols;
+    Wrappers_MatrixXd_data data;
+
+} Wrappers_MatrixXd;
+
+void Wrappers_MatrixXd_data_Initialize(Wrappers_MatrixXd_data* pVal);
+void Wrappers_MatrixXd_Initialize(Wrappers_MatrixXd* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_MATRIXXD		5948  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_ROWS		5908  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_COLS		5919  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_DATA		5941  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_DATA_ELM		5930  /**/
+flag Wrappers_MatrixXd_IsConstraintValid(const Wrappers_MatrixXd* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIXXD		5949  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_ROWS_2		5915  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_COLS_2		5926  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_DATA		5942  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_MATRIXXD_DATA_ELM_2		5937  /**/
+#define i3ds_asn1_Wrappers_MatrixXd_REQUIRED_BYTES_FOR_ENCODING       2609
+#define i3ds_asn1_Wrappers_MatrixXd_REQUIRED_BITS_FOR_ENCODING        20872
+
+flag Wrappers_MatrixXd_Encode(const Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIXXD		5950  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIXXD_ROWS_2		5916  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIXXD_COLS_2		5927  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA		5943  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA_ELM_2		5938  /**/
+flag Wrappers_MatrixXd_Decode(Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef DummyBase_T Dummy2Base_T;
+
+
+void Dummy2Base_T_Initialize(Dummy2Base_T* pVal);
+
+#define i3ds_asn1_ERR_DUMMY2BASE_T		1  /**/
+flag Dummy2Base_T_IsConstraintValid(const Dummy2Base_T* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_DUMMY2BASE_T_2_2		12  /**/
+#define i3ds_asn1_Dummy2Base_T_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_Dummy2Base_T_REQUIRED_BITS_FOR_ENCODING        32
+
+flag Dummy2Base_T_Encode(const Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_DUMMY2BASE_T_2_2		13  /**/
+flag Dummy2Base_T_Decode(Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_jointstate_mode_acceleration = 0,
+    base_jointstate_mode_effort = 1,
+    base_jointstate_mode_position = 2,
+    base_jointstate_mode_raw = 3,
+    base_jointstate_mode_speed = 4,
+    base_jointstate_mode_unset = 5
+} Base_JointState_MODE;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_JointState_MODE_base_jointstate_mode_acceleration base_jointstate_mode_acceleration
+#define i3ds_asn1_Base_JointState_MODE_base_jointstate_mode_effort base_jointstate_mode_effort
+#define i3ds_asn1_Base_JointState_MODE_base_jointstate_mode_position base_jointstate_mode_position
+#define i3ds_asn1_Base_JointState_MODE_base_jointstate_mode_raw base_jointstate_mode_raw
+#define i3ds_asn1_Base_JointState_MODE_base_jointstate_mode_speed base_jointstate_mode_speed
+#define i3ds_asn1_Base_JointState_MODE_base_jointstate_mode_unset base_jointstate_mode_unset
+
+void Base_JointState_MODE_Initialize(Base_JointState_MODE* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_MODE		16  /**/
+flag Base_JointState_MODE_IsConstraintValid(const Base_JointState_MODE* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE_MODE		17  /**/
+#define i3ds_asn1_Base_JointState_MODE_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_JointState_MODE_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Base_JointState_MODE_Encode(const Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_MODE		18  /**/
+flag Base_JointState_MODE_Decode(Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_time_resolution_microseconds = 0,
+    base_time_resolution_milliseconds = 1,
+    base_time_resolution_seconds = 2
+} Base_Time_Resolution;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_Time_Resolution_base_time_resolution_microseconds base_time_resolution_microseconds
+#define i3ds_asn1_Base_Time_Resolution_base_time_resolution_milliseconds base_time_resolution_milliseconds
+#define i3ds_asn1_Base_Time_Resolution_base_time_resolution_seconds base_time_resolution_seconds
+
+void Base_Time_Resolution_Initialize(Base_Time_Resolution* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TIME_RESOLUTION		23  /**/
+flag Base_Time_Resolution_IsConstraintValid(const Base_Time_Resolution* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIME_RESOLUTION		24  /**/
+#define i3ds_asn1_Base_Time_Resolution_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_Time_Resolution_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_Time_Resolution_Encode(const Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIME_RESOLUTION		25  /**/
+flag Base_Time_Resolution_Decode(Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_geometry_splinebase_coordinatetype_derivative_to_next = 0,
+    base_geometry_splinebase_coordinatetype_derivative_to_prior = 1,
+    base_geometry_splinebase_coordinatetype_knuckle_point = 2,
+    base_geometry_splinebase_coordinatetype_ordinary_point = 3,
+    base_geometry_splinebase_coordinatetype_second_derivative_to_next = 4,
+    base_geometry_splinebase_coordinatetype_second_derivative_to_prior = 5,
+    base_geometry_splinebase_coordinatetype_tangent_point_for_next = 6,
+    base_geometry_splinebase_coordinatetype_tangent_point_for_prior = 7
+} Base_geometry_SplineBase_CoordinateType;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_derivative_to_next base_geometry_splinebase_coordinatetype_derivative_to_next
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_derivative_to_prior base_geometry_splinebase_coordinatetype_derivative_to_prior
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_knuckle_point base_geometry_splinebase_coordinatetype_knuckle_point
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_ordinary_point base_geometry_splinebase_coordinatetype_ordinary_point
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_second_derivative_to_next base_geometry_splinebase_coordinatetype_second_derivative_to_next
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_second_derivative_to_prior base_geometry_splinebase_coordinatetype_second_derivative_to_prior
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_tangent_point_for_next base_geometry_splinebase_coordinatetype_tangent_point_for_next
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_base_geometry_splinebase_coordinatetype_tangent_point_for_prior base_geometry_splinebase_coordinatetype_tangent_point_for_prior
+
+void Base_geometry_SplineBase_CoordinateType_Initialize(Base_geometry_SplineBase_CoordinateType* pVal);
+
+#define i3ds_asn1_ERR_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE		30  /**/
+flag Base_geometry_SplineBase_CoordinateType_IsConstraintValid(const Base_geometry_SplineBase_CoordinateType* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE		31  /**/
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_geometry_SplineBase_CoordinateType_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Base_geometry_SplineBase_CoordinateType_Encode(const Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE		32  /**/
+flag Base_geometry_SplineBase_CoordinateType_Decode(Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_depthmap_depth_measurement_state_measurement_error = 0,
+    base_samples_depthmap_depth_measurement_state_too_far = 1,
+    base_samples_depthmap_depth_measurement_state_too_near = 2,
+    base_samples_depthmap_depth_measurement_state_valid_measurement = 3
+} Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_measurement_error base_samples_depthmap_depth_measurement_state_measurement_error
+#define i3ds_asn1_Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_too_far base_samples_depthmap_depth_measurement_state_too_far
+#define i3ds_asn1_Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_too_near base_samples_depthmap_depth_measurement_state_too_near
+#define i3ds_asn1_Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_base_samples_depthmap_depth_measurement_state_valid_measurement base_samples_depthmap_depth_measurement_state_valid_measurement
+
+void Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE		37  /**/
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE		38  /**/
+#define i3ds_asn1_Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Encode(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE		39  /**/
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Decode(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_depthmap_projection_type_planar = 0,
+    base_samples_depthmap_projection_type_polar = 1
+} Base_samples_DepthMap_PROJECTION_TYPE;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_samples_DepthMap_PROJECTION_TYPE_base_samples_depthmap_projection_type_planar base_samples_depthmap_projection_type_planar
+#define i3ds_asn1_Base_samples_DepthMap_PROJECTION_TYPE_base_samples_depthmap_projection_type_polar base_samples_depthmap_projection_type_polar
+
+void Base_samples_DepthMap_PROJECTION_TYPE_Initialize(Base_samples_DepthMap_PROJECTION_TYPE* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE		44  /**/
+flag Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE		45  /**/
+#define i3ds_asn1_Base_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_samples_DepthMap_PROJECTION_TYPE_REQUIRED_BITS_FOR_ENCODING        1
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_Encode(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE		46  /**/
+flag Base_samples_DepthMap_PROJECTION_TYPE_Decode(Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_DepthMap --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    Base_Time arr[200];
+} Base_samples_DepthMap_timestamps;
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Base_samples_DepthMap_vertical_interval;
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Base_samples_DepthMap_horizontal_interval;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_DepthMap_distances;
+
+
+typedef struct {
+    int nCount;
+
+    T_Float arr[200];
+} Base_samples_DepthMap_remissions;
+typedef struct {
+    Base_Time time;
+    Base_samples_DepthMap_timestamps timestamps;
+    Base_samples_DepthMap_PROJECTION_TYPE vertical_projection;
+    Base_samples_DepthMap_PROJECTION_TYPE horizontal_projection;
+    Base_samples_DepthMap_vertical_interval vertical_interval;
+    Base_samples_DepthMap_horizontal_interval horizontal_interval;
+    T_UInt32 vertical_size;
+    T_UInt32 horizontal_size;
+    Base_samples_DepthMap_distances distances;
+    Base_samples_DepthMap_remissions remissions;
+
+} Base_samples_DepthMap;
+
+void Base_samples_DepthMap_timestamps_Initialize(Base_samples_DepthMap_timestamps* pVal);
+void Base_samples_DepthMap_vertical_interval_Initialize(Base_samples_DepthMap_vertical_interval* pVal);
+void Base_samples_DepthMap_horizontal_interval_Initialize(Base_samples_DepthMap_horizontal_interval* pVal);
+void Base_samples_DepthMap_distances_Initialize(Base_samples_DepthMap_distances* pVal);
+void Base_samples_DepthMap_remissions_Initialize(Base_samples_DepthMap_remissions* pVal);
+void Base_samples_DepthMap_Initialize(Base_samples_DepthMap* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP		3442  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_TIME		3286  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_TIME_MICROSECONDS		3275  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS		3319  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM		3308  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_MICROSECONDS		3297  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION		3326  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION		3337  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL		3359  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM		3348  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL		3377  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM		3366  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE		3384  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE		3395  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES		3417  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM		3406  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS		3435  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM		3424  /**/
+flag Base_samples_DepthMap_IsConstraintValid(const Base_samples_DepthMap* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP		3443  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_TIME_2		3293  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS		3320  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_2		3315  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION_2		3333  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION_2		3344  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL		3360  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM_2		3355  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL		3378  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM_2		3373  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE_2		3391  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE_2		3402  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DISTANCES		3418  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM_2		3413  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS		3436  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM_2		3431  /**/
+#define i3ds_asn1_Base_samples_DepthMap_REQUIRED_BYTES_FOR_ENCODING       12022
+#define i3ds_asn1_Base_samples_DepthMap_REQUIRED_BITS_FOR_ENCODING        96170
+
+flag Base_samples_DepthMap_Encode(const Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP		3444  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIME_2		3294  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS		3321  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS_ELM_2		3316  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION_2		3334  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION_2		3345  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL		3361  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM_2		3356  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL		3379  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM_2		3374  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE_2		3392  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE_2		3403  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES		3419  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM_2		3414  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS		3437  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM_2		3432  /**/
+flag Base_samples_DepthMap_Decode(Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_depthmap_unit_axis_unit_x = 0,
+    base_samples_depthmap_unit_axis_unit_y = 1,
+    base_samples_depthmap_unit_axis_unit_z = 2
+} Base_samples_DepthMap_UNIT_AXIS;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_samples_DepthMap_UNIT_AXIS_base_samples_depthmap_unit_axis_unit_x base_samples_depthmap_unit_axis_unit_x
+#define i3ds_asn1_Base_samples_DepthMap_UNIT_AXIS_base_samples_depthmap_unit_axis_unit_y base_samples_depthmap_unit_axis_unit_y
+#define i3ds_asn1_Base_samples_DepthMap_UNIT_AXIS_base_samples_depthmap_unit_axis_unit_z base_samples_depthmap_unit_axis_unit_z
+
+void Base_samples_DepthMap_UNIT_AXIS_Initialize(Base_samples_DepthMap_UNIT_AXIS* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS		51  /**/
+flag Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const Base_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS		52  /**/
+#define i3ds_asn1_Base_samples_DepthMap_UNIT_AXIS_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_samples_DepthMap_UNIT_AXIS_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_samples_DepthMap_UNIT_AXIS_Encode(const Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS		53  /**/
+flag Base_samples_DepthMap_UNIT_AXIS_Decode(Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_laser_range_errors_end_laser_range_errors = 0,
+    base_samples_laser_range_errors_max_range_error = 1,
+    base_samples_laser_range_errors_measurement_error = 2,
+    base_samples_laser_range_errors_other_range_errors = 3,
+    base_samples_laser_range_errors_too_far = 4,
+    base_samples_laser_range_errors_too_near = 5
+} Base_samples_LASER_RANGE_ERRORS;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_end_laser_range_errors base_samples_laser_range_errors_end_laser_range_errors
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_max_range_error base_samples_laser_range_errors_max_range_error
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_measurement_error base_samples_laser_range_errors_measurement_error
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_other_range_errors base_samples_laser_range_errors_other_range_errors
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_too_far base_samples_laser_range_errors_too_far
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_base_samples_laser_range_errors_too_near base_samples_laser_range_errors_too_near
+
+void Base_samples_LASER_RANGE_ERRORS_Initialize(Base_samples_LASER_RANGE_ERRORS* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_LASER_RANGE_ERRORS		58  /**/
+flag Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(const Base_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASER_RANGE_ERRORS		59  /**/
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_samples_LASER_RANGE_ERRORS_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Base_samples_LASER_RANGE_ERRORS_Encode(const Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS		60  /**/
+flag Base_samples_LASER_RANGE_ERRORS_Decode(Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_frame_frame_mode_t_compressed_modes = 0,
+    base_samples_frame_frame_mode_t_mode_bayer = 1,
+    base_samples_frame_frame_mode_t_mode_bayer_bggr = 2,
+    base_samples_frame_frame_mode_t_mode_bayer_gbrg = 3,
+    base_samples_frame_frame_mode_t_mode_bayer_grbg = 4,
+    base_samples_frame_frame_mode_t_mode_bayer_rggb = 5,
+    base_samples_frame_frame_mode_t_mode_bgr = 6,
+    base_samples_frame_frame_mode_t_mode_grayscale = 7,
+    base_samples_frame_frame_mode_t_mode_jpeg = 8,
+    base_samples_frame_frame_mode_t_mode_pjpg = 9,
+    base_samples_frame_frame_mode_t_mode_png = 10,
+    base_samples_frame_frame_mode_t_mode_rgb = 11,
+    base_samples_frame_frame_mode_t_mode_rgb32 = 12,
+    base_samples_frame_frame_mode_t_mode_undefined = 13,
+    base_samples_frame_frame_mode_t_mode_uyvy = 14,
+    base_samples_frame_frame_mode_t_raw_modes = 15
+} Base_samples_frame_frame_mode_t;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_compressed_modes base_samples_frame_frame_mode_t_compressed_modes
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer base_samples_frame_frame_mode_t_mode_bayer
+#define i3ds_asn1_i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_bggr base_samples_frame_frame_mode_t_mode_bayer_bggr
+#define i3ds_asn1_i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_gbrg base_samples_frame_frame_mode_t_mode_bayer_gbrg
+#define i3ds_asn1_i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_grbg base_samples_frame_frame_mode_t_mode_bayer_grbg
+#define i3ds_asn1_i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bayer_rggb base_samples_frame_frame_mode_t_mode_bayer_rggb
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_bgr base_samples_frame_frame_mode_t_mode_bgr
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_grayscale base_samples_frame_frame_mode_t_mode_grayscale
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_jpeg base_samples_frame_frame_mode_t_mode_jpeg
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_pjpg base_samples_frame_frame_mode_t_mode_pjpg
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_png base_samples_frame_frame_mode_t_mode_png
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_rgb base_samples_frame_frame_mode_t_mode_rgb
+#define i3ds_asn1_i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_rgb32 base_samples_frame_frame_mode_t_mode_rgb32
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_undefined base_samples_frame_frame_mode_t_mode_undefined
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_mode_uyvy base_samples_frame_frame_mode_t_mode_uyvy
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_base_samples_frame_frame_mode_t_raw_modes base_samples_frame_frame_mode_t_raw_modes
+
+void Base_samples_frame_frame_mode_t_Initialize(Base_samples_frame_frame_mode_t* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_MODE_T		65  /**/
+flag Base_samples_frame_frame_mode_t_IsConstraintValid(const Base_samples_frame_frame_mode_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_MODE_T		66  /**/
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_samples_frame_frame_mode_t_REQUIRED_BITS_FOR_ENCODING        4
+
+flag Base_samples_frame_frame_mode_t_Encode(const Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T		67  /**/
+flag Base_samples_frame_frame_mode_t_Decode(Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    base_samples_frame_frame_status_t_status_empty = 0,
+    base_samples_frame_frame_status_t_status_invalid = 1,
+    base_samples_frame_frame_status_t_status_valid = 2
+} Base_samples_frame_frame_status_t;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Base_samples_frame_frame_status_t_base_samples_frame_frame_status_t_status_empty base_samples_frame_frame_status_t_status_empty
+#define i3ds_asn1_Base_samples_frame_frame_status_t_base_samples_frame_frame_status_t_status_invalid base_samples_frame_frame_status_t_status_invalid
+#define i3ds_asn1_Base_samples_frame_frame_status_t_base_samples_frame_frame_status_t_status_valid base_samples_frame_frame_status_t_status_valid
+
+void Base_samples_frame_frame_status_t_Initialize(Base_samples_frame_frame_status_t* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_STATUS_T		72  /**/
+flag Base_samples_frame_frame_status_t_IsConstraintValid(const Base_samples_frame_frame_status_t* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T		73  /**/
+#define i3ds_asn1_Base_samples_frame_frame_status_t_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Base_samples_frame_frame_status_t_REQUIRED_BITS_FOR_ENCODING        2
+
+flag Base_samples_frame_frame_status_t_Encode(const Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T		74  /**/
+flag Base_samples_frame_frame_status_t_Decode(Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_Frame --------------------------------------------*/
+typedef struct {
+    int nCount;
+
+    byte arr[200];
+} Base_samples_frame_Frame_image;
+
+
+
+typedef struct {
+    int nCount;
+
+    Base_samples_frame_frame_attrib_t arr[200];
+} Base_samples_frame_Frame_attributes;
+typedef struct {
+    Base_Time time;
+    Base_Time received_time;
+    Base_samples_frame_Frame_image image;
+    Base_samples_frame_Frame_attributes attributes;
+    Base_samples_frame_frame_size_t size_val;
+    T_UInt32 data_depth;
+    T_UInt32 pixel_size;
+    T_UInt32 row_size;
+    Base_samples_frame_frame_mode_t frame_mode;
+    Base_samples_frame_frame_status_t frame_status;
+
+} Base_samples_frame_Frame;
+
+void Base_samples_frame_Frame_image_Initialize(Base_samples_frame_Frame_image* pVal);
+void Base_samples_frame_Frame_attributes_Initialize(Base_samples_frame_Frame_attributes* pVal);
+void Base_samples_frame_Frame_Initialize(Base_samples_frame_Frame* pVal);
+
+#define i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME		5245  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_TIME		5077  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_TIME_MICROSECONDS		5066  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME		5099  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_MICROSECONDS		5088  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_IMAGE		5110  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES		5150  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM		5139  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA		5117  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL		5128  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL		5179  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_WIDTH		5157  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_HEIGHT		5168  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH		5190  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE		5201  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE		5212  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE		5223  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS		5234  /**/
+flag Base_samples_frame_Frame_IsConstraintValid(const Base_samples_frame_Frame* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME		5246  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_TIME_2		5084  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_2		5106  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_IMAGE		5111  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES		5151  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_2		5146  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_2		5186  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH_2		5197  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE_2		5208  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE_2		5219  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE_2		5230  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS_2		5241  /**/
+#define i3ds_asn1_Base_samples_frame_Frame_REQUIRED_BYTES_FOR_ENCODING       16535
+#define i3ds_asn1_Base_samples_frame_Frame_REQUIRED_BITS_FOR_ENCODING        132278
+
+flag Base_samples_frame_Frame_Encode(const Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME		5247  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_TIME_2		5085  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_RECEIVED_TIME_2		5107  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE		5112  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES		5152  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_2		5147  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_2		5187  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH_2		5198  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE_2		5209  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE_2		5220  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE_2		5231  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS_2		5242  /**/
+flag Base_samples_frame_Frame_Decode(Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_samples_frame_FramePair --------------------------------------------*/
+typedef struct {
+    Base_Time time;
+    Base_samples_frame_Frame first;
+    Base_samples_frame_Frame second;
+    T_UInt32 id;
+
+} Base_samples_frame_FramePair;
+
+void Base_samples_frame_FramePair_Initialize(Base_samples_frame_FramePair* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR		5665  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME		5263  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_MICROSECONDS		5252  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST		5453  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_TIME		5285  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_TIME_MICROSECONDS		5274  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_RECEIVED_TIME		5307  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_RECEIVED_TIME_MICROSECONDS		5296  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE		5318  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES		5358  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM		5347  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA		5325  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL		5336  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL		5387  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_WIDTH		5365  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_HEIGHT		5376  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_DATA_DEPTH		5398  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_PIXEL_SIZE		5409  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ROW_SIZE		5420  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE		5431  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS		5442  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND		5643  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_TIME		5475  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_TIME_MICROSECONDS		5464  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_RECEIVED_TIME		5497  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_RECEIVED_TIME_MICROSECONDS		5486  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE		5508  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES		5548  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM		5537  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA		5515  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL		5526  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL		5577  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_WIDTH		5555  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_HEIGHT		5566  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_DATA_DEPTH		5588  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_PIXEL_SIZE		5599  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ROW_SIZE		5610  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE		5621  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS		5632  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_ID		5654  /**/
+flag Base_samples_frame_FramePair_IsConstraintValid(const Base_samples_frame_FramePair* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR		5666  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_2		5270  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_2		5460  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_2		5650  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAMEPAIR_ID_2		5661  /**/
+#define i3ds_asn1_Base_samples_frame_FramePair_REQUIRED_BYTES_FOR_ENCODING       33082
+#define i3ds_asn1_Base_samples_frame_FramePair_REQUIRED_BITS_FOR_ENCODING        264652
+
+flag Base_samples_frame_FramePair_Encode(const Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR		5667  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_TIME_2		5271  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_2		5461  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_2		5651  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAMEPAIR_ID_2		5662  /**/
+flag Base_samples_frame_FramePair_Decode(Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef enum {
+    wrappers_geometry_splinetype_degenerate = 0,
+    wrappers_geometry_splinetype_polynomial_bezier = 1,
+    wrappers_geometry_splinetype_polynomial_bspline = 2,
+    wrappers_geometry_splinetype_rational_bezier = 3,
+    wrappers_geometry_splinetype_rational_bspline = 4
+} Wrappers_geometry_SplineType;
+
+// please use the following macros to avoid breaking code.
+#define i3ds_asn1_Wrappers_geometry_SplineType_wrappers_geometry_splinetype_degenerate wrappers_geometry_splinetype_degenerate
+#define i3ds_asn1_Wrappers_geometry_SplineType_wrappers_geometry_splinetype_polynomial_bezier wrappers_geometry_splinetype_polynomial_bezier
+#define i3ds_asn1_Wrappers_geometry_SplineType_wrappers_geometry_splinetype_polynomial_bspline wrappers_geometry_splinetype_polynomial_bspline
+#define i3ds_asn1_Wrappers_geometry_SplineType_wrappers_geometry_splinetype_rational_bezier wrappers_geometry_splinetype_rational_bezier
+#define i3ds_asn1_Wrappers_geometry_SplineType_wrappers_geometry_splinetype_rational_bspline wrappers_geometry_splinetype_rational_bspline
+
+void Wrappers_geometry_SplineType_Initialize(Wrappers_geometry_SplineType* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINETYPE		79  /**/
+flag Wrappers_geometry_SplineType_IsConstraintValid(const Wrappers_geometry_SplineType* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINETYPE		80  /**/
+#define i3ds_asn1_Wrappers_geometry_SplineType_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_Wrappers_geometry_SplineType_REQUIRED_BITS_FOR_ENCODING        3
+
+flag Wrappers_geometry_SplineType_Encode(const Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE		81  /**/
+flag Wrappers_geometry_SplineType_Decode(Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Wrappers_geometry_Spline --------------------------------------------*/
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_geometry_Spline_knots;
+
+
+typedef struct {
+    int nCount;
+
+    T_Double arr[200];
+} Wrappers_geometry_Spline_vertices;
+typedef struct {
+    T_Double geometric_resolution;
+    T_Int32 dimension;
+    T_Int32 curve_order;
+    Wrappers_geometry_SplineType kind;
+    Wrappers_geometry_Spline_knots knots;
+    Wrappers_geometry_Spline_vertices vertices;
+
+} Wrappers_geometry_Spline;
+
+void Wrappers_geometry_Spline_knots_Initialize(Wrappers_geometry_Spline_knots* pVal);
+void Wrappers_geometry_Spline_vertices_Initialize(Wrappers_geometry_Spline_vertices* pVal);
+void Wrappers_geometry_Spline_Initialize(Wrappers_geometry_Spline* pVal);
+
+#define i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE		8104  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION		8024  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_DIMENSION		8035  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER		8046  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_KIND		8057  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS		8079  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM		8068  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES		8097  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM		8086  /**/
+flag Wrappers_geometry_Spline_IsConstraintValid(const Wrappers_geometry_Spline* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE		8105  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION_2		8031  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_DIMENSION_2		8042  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER_2		8053  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_KIND_2		8064  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS		8080  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM_2		8075  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES		8098  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM_2		8093  /**/
+#define i3ds_asn1_Wrappers_geometry_Spline_REQUIRED_BYTES_FOR_ENCODING       5224
+#define i3ds_asn1_Wrappers_geometry_Spline_REQUIRED_BITS_FOR_ENCODING        41787
+
+flag Wrappers_geometry_Spline_Encode(const Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE		8106  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION_2		8032  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_DIMENSION_2		8043  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER_2		8054  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KIND_2		8065  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS		8081  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM_2		8076  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES		8099  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM_2		8094  /**/
+flag Wrappers_geometry_Spline_Decode(Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Trajectory --------------------------------------------*/
+typedef struct {
+    T_Double speed;
+    Wrappers_geometry_Spline spline;
+
+} Base_Trajectory;
+
+void Base_Trajectory_Initialize(Base_Trajectory* pVal);
+
+#define i3ds_asn1_ERR_BASE_TRAJECTORY		1192  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPEED		1090  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE		1181  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_GEOMETRIC_RESOLUTION		1101  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_DIMENSION		1112  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_CURVE_ORDER		1123  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_KIND		1134  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_KNOTS		1156  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_KNOTS_ELM		1145  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_VERTICES		1174  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_VERTICES_ELM		1163  /**/
+flag Base_Trajectory_IsConstraintValid(const Base_Trajectory* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_BASE_TRAJECTORY		1193  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRAJECTORY_SPEED_2		1097  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRAJECTORY_SPLINE_2		1188  /**/
+#define i3ds_asn1_Base_Trajectory_REQUIRED_BYTES_FOR_ENCODING       5237
+#define i3ds_asn1_Base_Trajectory_REQUIRED_BITS_FOR_ENCODING        41891
+
+flag Base_Trajectory_Encode(const Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_BASE_TRAJECTORY		1194  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRAJECTORY_SPEED_2		1098  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRAJECTORY_SPLINE_2		1189  /**/
+flag Base_Trajectory_Decode(Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+/*-- Base_Trajectory_m --------------------------------------------*/
+typedef struct {
+    T_Double speed;
+    Wrappers_geometry_Spline spline;
+
+} Base_Trajectory_m;
+
+void Base_Trajectory_m_Initialize(Base_Trajectory_m* pVal);
+
+#define i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M		8213  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPEED		8111  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE		8202  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_GEOMETRIC_RESOLUTION		8122  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_DIMENSION		8133  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_CURVE_ORDER		8144  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_KIND		8155  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS		8177  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS_ELM		8166  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES		8195  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES_ELM		8184  /**/
+flag Base_Trajectory_m_IsConstraintValid(const Base_Trajectory_m* pVal, int* pErrCode);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRAJECTORY_M		8214  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRAJECTORY_M_SPEED_2		8118  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TRAJECTORY_M_SPLINE_2		8209  /**/
+#define i3ds_asn1_Base_Trajectory_m_REQUIRED_BYTES_FOR_ENCODING       5237
+#define i3ds_asn1_Base_Trajectory_m_REQUIRED_BITS_FOR_ENCODING        41891
+
+flag Base_Trajectory_m_Encode(const Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRAJECTORY_M		8215  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRAJECTORY_M_SPEED_2		8119  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TRAJECTORY_M_SPLINE_2		8210  /**/
+flag Base_Trajectory_m_Decode(Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+typedef struct {
+    int nCount;
+
+    Base_Trajectory_m arr[200];
+} Std_orogen_typekits_mtype_std_vector_base_Trajectory;
+
+void Std_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal);
+
+#define i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY		533  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM		522  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPEED		420  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE		511  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_GEOMETRIC_RESOLUTION		431  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_DIMENSION		442  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_CURVE_ORDER		453  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND		464  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS		486  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS_ELM		475  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES		504  /**/
+#define i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES_ELM		493  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY		534  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_2		529  /**/
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BYTES_FOR_ENCODING       1047276
+#define i3ds_asn1_Std_orogen_typekits_mtype_std_vector_base_Trajectory_REQUIRED_BITS_FOR_ENCODING        8378208
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Encode(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY		535  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_2		530  /**/
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Decode(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/taste-extended.hpp b/generated/include/i3ds_asn1/taste-extended.hpp
new file mode 100644
index 0000000..65d0e5a
--- /dev/null
+++ b/generated/include/i3ds_asn1/taste-extended.hpp
@@ -0,0 +1,176 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_taste_extended_H
+#define i3ds_asn1_GENERATED_ASN1SCC_taste_extended_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- T_Time --------------------------------------------*/
+typedef struct {
+    T_UInt32 secs;
+    T_UInt32 nsecs;
+
+} T_Time;
+
+void T_Time_Initialize(T_Time* pVal);
+
+#define i3ds_asn1_ERR_T_TIME		8291  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_T_TIME_SECS		8269  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_T_TIME_NSECS		8280  /**/
+flag T_Time_IsConstraintValid(const T_Time* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_TIME		8292  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_T_TIME_SECS_2		8276  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_T_TIME_NSECS_2		8287  /**/
+#define i3ds_asn1_T_Time_REQUIRED_BYTES_FOR_ENCODING       8
+#define i3ds_asn1_T_Time_REQUIRED_BITS_FOR_ENCODING        64
+
+flag T_Time_Encode(const T_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_TIME		8293  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_T_TIME_SECS_2		8277  /**/
+#define i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_T_TIME_NSECS_2		8288  /**/
+flag T_Time_Decode(T_Time* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1Real T_Double;
+
+
+void T_Double_Initialize(T_Double* pVal);
+
+#define i3ds_asn1_ERR_T_DOUBLE		8220  /**/
+flag T_Double_IsConstraintValid(const T_Double* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_DOUBLE		8221  /**/
+#define i3ds_asn1_T_Double_REQUIRED_BYTES_FOR_ENCODING       13
+#define i3ds_asn1_T_Double_REQUIRED_BITS_FOR_ENCODING        104
+
+flag T_Double_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_DOUBLE		8222  /**/
+flag T_Double_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1Real T_Float;
+
+
+void T_Float_Initialize(T_Float* pVal);
+
+#define i3ds_asn1_ERR_T_FLOAT		8227  /**/
+flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_FLOAT		8228  /**/
+#define i3ds_asn1_T_Float_REQUIRED_BYTES_FOR_ENCODING       13
+#define i3ds_asn1_T_Float_REQUIRED_BITS_FOR_ENCODING        104
+
+flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_FLOAT		8229  /**/
+flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccSint T_Int16;
+
+
+void T_Int16_Initialize(T_Int16* pVal);
+
+#define i3ds_asn1_ERR_T_INT16		8234  /**/
+flag T_Int16_IsConstraintValid(const T_Int16* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_INT16		8235  /**/
+#define i3ds_asn1_T_Int16_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_T_Int16_REQUIRED_BITS_FOR_ENCODING        16
+
+flag T_Int16_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_INT16		8236  /**/
+flag T_Int16_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt16;
+
+
+void T_UInt16_Initialize(T_UInt16* pVal);
+
+#define i3ds_asn1_ERR_T_UINT16		8241  /**/
+flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_UINT16		8242  /**/
+#define i3ds_asn1_T_UInt16_REQUIRED_BYTES_FOR_ENCODING       2
+#define i3ds_asn1_T_UInt16_REQUIRED_BITS_FOR_ENCODING        16
+
+flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_UINT16		8243  /**/
+flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt64;
+
+
+void T_UInt64_Initialize(T_UInt64* pVal);
+
+#define i3ds_asn1_ERR_T_UINT64		8248  /**/
+flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_UINT64		8249  /**/
+#define i3ds_asn1_T_UInt64_REQUIRED_BYTES_FOR_ENCODING       8
+#define i3ds_asn1_T_UInt64_REQUIRED_BITS_FOR_ENCODING        64
+
+flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_UINT64		8250  /**/
+flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccSint T_Int64;
+
+
+void T_Int64_Initialize(T_Int64* pVal);
+
+#define i3ds_asn1_ERR_T_INT64		8255  /**/
+flag T_Int64_IsConstraintValid(const T_Int64* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_INT64		8256  /**/
+#define i3ds_asn1_T_Int64_REQUIRED_BYTES_FOR_ENCODING       8
+#define i3ds_asn1_T_Int64_REQUIRED_BITS_FOR_ENCODING        64
+
+flag T_Int64_Encode(const T_Int64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_INT64		8257  /**/
+flag T_Int64_Decode(T_Int64* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef struct {
+    int nCount;
+
+    byte arr[40];
+} T_String;
+
+
+void T_String_Initialize(T_String* pVal);
+
+#define i3ds_asn1_ERR_T_STRING		8262  /**/
+flag T_String_IsConstraintValid(const T_String* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_STRING		8263  /**/
+#define i3ds_asn1_T_String_REQUIRED_BYTES_FOR_ENCODING       41
+#define i3ds_asn1_T_String_REQUIRED_BITS_FOR_ENCODING        326
+
+flag T_String_Encode(const T_String* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_STRING		8264  /**/
+flag T_String_Decode(T_String* pVal, BitStream* pBitStrm, int* pErrCode);
+
+extern const T_UInt32 numT_String;
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/taste-types.hpp b/generated/include/i3ds_asn1/taste-types.hpp
new file mode 100644
index 0000000..54ff9b7
--- /dev/null
+++ b/generated/include/i3ds_asn1/taste-types.hpp
@@ -0,0 +1,113 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_taste_types_H
+#define i3ds_asn1_GENERATED_ASN1SCC_taste_types_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+namespace i3ds_asn1 {
+
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef asn1SccSint T_Int32;
+
+
+void T_Int32_Initialize(T_Int32* pVal);
+
+#define i3ds_asn1_ERR_T_INT32		8298  /**/
+flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_INT32		8299  /**/
+#define i3ds_asn1_T_Int32_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_T_Int32_REQUIRED_BITS_FOR_ENCODING        32
+
+flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_INT32		8300  /**/
+flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt32;
+
+
+void T_UInt32_Initialize(T_UInt32* pVal);
+
+#define i3ds_asn1_ERR_T_UINT32		8305  /**/
+flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_UINT32		8306  /**/
+#define i3ds_asn1_T_UInt32_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_T_UInt32_REQUIRED_BITS_FOR_ENCODING        32
+
+flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_UINT32		8307  /**/
+flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccSint T_Int8;
+
+
+void T_Int8_Initialize(T_Int8* pVal);
+
+#define i3ds_asn1_ERR_T_INT8		8312  /**/
+flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_INT8		8313  /**/
+#define i3ds_asn1_T_Int8_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_T_Int8_REQUIRED_BITS_FOR_ENCODING        8
+
+flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_INT8		8314  /**/
+flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt8;
+
+
+void T_UInt8_Initialize(T_UInt8* pVal);
+
+#define i3ds_asn1_ERR_T_UINT8		8319  /**/
+flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_UINT8		8320  /**/
+#define i3ds_asn1_T_UInt8_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_T_UInt8_REQUIRED_BITS_FOR_ENCODING        8
+
+flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_UINT8		8321  /**/
+flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef flag T_Boolean;
+
+
+void T_Boolean_Initialize(T_Boolean* pVal);
+
+#define i3ds_asn1_ERR_T_BOOLEAN		8326  /**/
+flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_T_BOOLEAN		8327  /**/
+#define i3ds_asn1_T_Boolean_REQUIRED_BYTES_FOR_ENCODING       1
+#define i3ds_asn1_T_Boolean_REQUIRED_BITS_FOR_ENCODING        1
+
+flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_T_BOOLEAN		8328  /**/
+flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/include/i3ds_asn1/userdefs-base.hpp b/generated/include/i3ds_asn1/userdefs-base.hpp
new file mode 100644
index 0000000..f0ac21e
--- /dev/null
+++ b/generated/include/i3ds_asn1/userdefs-base.hpp
@@ -0,0 +1,102 @@
+#ifndef i3ds_asn1_GENERATED_ASN1SCC_userdefs_base_H
+#define i3ds_asn1_GENERATED_ASN1SCC_userdefs_base_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_UInt32 DummyBase_T;
+
+
+void DummyBase_T_Initialize(DummyBase_T* pVal);
+
+#define i3ds_asn1_ERR_DUMMYBASE_T		8333  /**/
+flag DummyBase_T_IsConstraintValid(const DummyBase_T* pVal, int* pErrCode);
+
+#define i3ds_asn1_ERR_UPER_ENCODE_DUMMYBASE_T_2		8340  /**/
+#define i3ds_asn1_DummyBase_T_REQUIRED_BYTES_FOR_ENCODING       4
+#define i3ds_asn1_DummyBase_T_REQUIRED_BITS_FOR_ENCODING        32
+
+flag DummyBase_T_Encode(const DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define i3ds_asn1_ERR_UPER_DECODE_DUMMYBASE_T_2		8341  /**/
+flag DummyBase_T_Decode(DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode);
+
+extern const T_UInt32 numBase_JointTrajectory;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_JointTransform;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Waypoint;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Wrench;
+extern const T_UInt32 numStd_vector_Wrappers_Vector4d;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Trajectory;
+extern const T_UInt32 numBase_JointLimits_names;
+extern const T_UInt32 numBase_JointLimits_elements;
+extern const T_UInt32 numBase_JointsTrajectory_names;
+extern const T_UInt32 numBase_JointsTrajectory_elements;
+extern const T_UInt32 numBase_JointsTrajectory_times_val;
+extern const T_UInt32 numBase_NamedVector_Base_JointLimitRange_names;
+extern const T_UInt32 numBase_NamedVector_Base_JointLimitRange_elements;
+extern const T_UInt32 numBase_NamedVector_Base_JointState_names;
+extern const T_UInt32 numBase_NamedVector_Base_Wrench_names;
+extern const T_UInt32 numBase_NamedVector_Base_Wrench_elements;
+extern const T_UInt32 numBase_NamedVector_Base_JointTrajectory_names;
+extern const T_UInt32 numBase_NamedVector_Base_JointTrajectory_elements;
+extern const T_UInt32 numBase_samples_DepthMap_timestamps;
+extern const T_UInt32 numBase_samples_DepthMap_vertical_interval;
+extern const T_UInt32 numBase_samples_DepthMap_horizontal_interval;
+extern const T_UInt32 numBase_samples_DepthMap_distances;
+extern const T_UInt32 numBase_samples_DepthMap_remissions;
+extern const T_UInt32 numBase_samples_DistanceImage_data;
+extern const T_UInt32 numBase_commands_Joints_names;
+extern const T_UInt32 numBase_samples_LaserScan_ranges;
+extern const T_UInt32 numBase_samples_LaserScan_remission;
+extern const T_UInt32 numBase_samples_Pointcloud_points;
+extern const T_UInt32 numBase_samples_Pointcloud_colors;
+extern const T_UInt32 numBase_samples_Sonar_timestamps;
+extern const T_UInt32 numBase_samples_Sonar_bearings;
+extern const T_UInt32 numBase_samples_Sonar_bins;
+extern const T_UInt32 numBase_samples_SonarBeam_beam;
+extern const T_UInt32 numBase_samples_SonarScan_data;
+extern const T_UInt32 numBase_samples_SonarScan_time_beams;
+extern const T_UInt32 numBase_samples_Wrenches_names;
+extern const T_UInt32 numBase_samples_Wrenches_elements;
+extern const T_UInt32 numBase_JointTransformVector_names;
+extern const T_UInt32 numBase_JointTransformVector_elements;
+extern const T_UInt32 numBase_NamedVector_Base_JointTransform_names;
+extern const T_UInt32 numBase_NamedVector_Base_JointTransform_elements;
+extern const T_UInt32 numBase_samples_frame_Frame_image;
+extern const T_UInt32 numBase_samples_frame_Frame_attributes;
+extern const T_UInt32 numWrappers_MatrixXd_data;
+extern const T_UInt32 numWrappers_VectorXd_data;
+extern const T_UInt32 numBase_JointTransformVector_m_names;
+extern const T_UInt32 numBase_NamedVector_base_JointTransform_m_names;
+extern const T_UInt32 numBase_NamedVector_base_Wrench_m_names;
+extern const T_UInt32 numBase_samples_Pointcloud_m_points;
+extern const T_UInt32 numBase_samples_Pointcloud_m_colors;
+extern const T_UInt32 numBase_samples_Wrenches_m_names;
+extern const T_UInt32 numWrappers_geometry_Spline_knots;
+extern const T_UInt32 numWrappers_geometry_Spline_vertices;
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/src/Analog.cpp b/generated/src/Analog.cpp
new file mode 100644
index 0000000..f1cde8b
--- /dev/null
+++ b/generated/src/Analog.cpp
@@ -0,0 +1,171 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Analog.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SeriesCount_Initialize(SeriesCount* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt8_Initialize(pVal);
+}
+
+flag SeriesCount_IsConstraintValid(const SeriesCount* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_SERIESCOUNT;
+
+	return ret;
+}
+
+flag SeriesCount_Encode(const SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SeriesCount_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SeriesCount_Decode(SeriesCount* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt8_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && SeriesCount_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void AnalogSeriesDescriptor_Initialize(AnalogSeriesDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set series_count */
+	T_UInt8_Initialize((&(pVal->series_count)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+}
+
+flag AnalogSeriesDescriptor_IsConstraintValid(const AnalogSeriesDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->series_count <= 255UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_SERIES_COUNT;
+        if (ret) {
+            ret = (pVal->batch_size <= 4294967295UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_ANALOGSERIESDESCRIPTOR_BATCH_SIZE;
+        }
+    }
+
+	return ret;
+}
+
+flag AnalogSeriesDescriptor_Encode(const AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? AnalogSeriesDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode series_count */
+	        ret = SeriesCount_Encode((&(pVal->series_count)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode batch_size */
+	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag AnalogSeriesDescriptor_Decode(AnalogSeriesDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode series_count */
+	    ret = SeriesCount_Decode((&(pVal->series_count)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode batch_size */
+	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && AnalogSeriesDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Camera.cpp b/generated/src/Camera.cpp
new file mode 100644
index 0000000..800d499
--- /dev/null
+++ b/generated/src/Camera.cpp
@@ -0,0 +1,805 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Camera.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SensorGain_Initialize(SensorGain* pVal)
+{
+	(void)pVal;
+
+
+	T_Float_Initialize(pVal);
+}
+
+flag SensorGain_IsConstraintValid(const SensorGain* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_SENSORGAIN;
+
+	return ret;
+}
+
+flag SensorGain_Encode(const SensorGain* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorGain_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_Float_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorGain_Decode(SensorGain* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_Float_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && SensorGain_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PatternSequence_Initialize(PatternSequence* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt16_Initialize(pVal);
+}
+
+flag PatternSequence_IsConstraintValid(const PatternSequence* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_PATTERNSEQUENCE;
+
+	return ret;
+}
+
+flag PatternSequence_Encode(const PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PatternSequence_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PatternSequence_Decode(PatternSequence* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt16_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && PatternSequence_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PatternID_Initialize(PatternID* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt16_Initialize(pVal);
+}
+
+flag PatternID_IsConstraintValid(const PatternID* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_PATTERNID;
+
+	return ret;
+}
+
+flag PatternID_Encode(const PatternID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PatternID_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PatternID_Decode(PatternID* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt16_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && PatternID_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void FlashStrength_Initialize(FlashStrength* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt8_Initialize(pVal);
+}
+
+flag FlashStrength_IsConstraintValid(const FlashStrength* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_FLASHSTRENGTH;
+
+	return ret;
+}
+
+flag FlashStrength_Encode(const FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? FlashStrength_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag FlashStrength_Decode(FlashStrength* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt8_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && FlashStrength_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ShutterTime_Initialize(ShutterTime* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag ShutterTime_IsConstraintValid(const ShutterTime* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_SHUTTERTIME;
+
+	return ret;
+}
+
+flag ShutterTime_Encode(const ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ShutterTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ShutterTime_Decode(ShutterTime* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && ShutterTime_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraExposure_Initialize(CameraExposure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set shutter */
+	T_UInt32_Initialize((&(pVal->shutter)));
+	/*set gain */
+	T_Float_Initialize((&(pVal->gain)));
+}
+
+flag CameraExposure_IsConstraintValid(const CameraExposure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->shutter <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERAEXPOSURE_SHUTTER;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->gain) && (pVal->gain <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERAEXPOSURE_GAIN;
+    }
+
+	return ret;
+}
+
+flag CameraExposure_Encode(const CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraExposure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode shutter */
+	    ret = ShutterTime_Encode((&(pVal->shutter)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode gain */
+	        ret = SensorGain_Encode((&(pVal->gain)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraExposure_Decode(CameraExposure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode shutter */
+	ret = ShutterTime_Decode((&(pVal->shutter)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode gain */
+	    ret = SensorGain_Decode((&(pVal->gain)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraExposure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraAutoExposure_Initialize(CameraAutoExposure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set max_shutter */
+	T_UInt32_Initialize((&(pVal->max_shutter)));
+	/*set max_gain */
+	T_Float_Initialize((&(pVal->max_gain)));
+}
+
+flag CameraAutoExposure_IsConstraintValid(const CameraAutoExposure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->max_shutter <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERAAUTOEXPOSURE_MAX_SHUTTER;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->max_gain) && (pVal->max_gain <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERAAUTOEXPOSURE_MAX_GAIN;
+    }
+
+	return ret;
+}
+
+flag CameraAutoExposure_Encode(const CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraAutoExposure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode max_shutter */
+	        ret = ShutterTime_Encode((&(pVal->max_shutter)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode max_gain */
+	            ret = SensorGain_Encode((&(pVal->max_gain)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraAutoExposure_Decode(CameraAutoExposure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode max_shutter */
+	    ret = ShutterTime_Decode((&(pVal->max_shutter)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode max_gain */
+	        ret = SensorGain_Decode((&(pVal->max_gain)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && CameraAutoExposure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraFlash_Initialize(CameraFlash* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set strength */
+	T_UInt8_Initialize((&(pVal->strength)));
+}
+
+flag CameraFlash_IsConstraintValid(const CameraFlash* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->strength <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERAFLASH_STRENGTH;
+
+	return ret;
+}
+
+flag CameraFlash_Encode(const CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraFlash_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode strength */
+	        ret = FlashStrength_Encode((&(pVal->strength)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraFlash_Decode(CameraFlash* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode strength */
+	    ret = FlashStrength_Decode((&(pVal->strength)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraFlash_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraRegion_Initialize(CameraRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag CameraRegion_IsConstraintValid(const CameraRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERAREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag CameraRegion_Encode(const CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraRegion_Decode(CameraRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraPattern_Initialize(CameraPattern* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set pattern_sequence */
+	T_UInt16_Initialize((&(pVal->pattern_sequence)));
+}
+
+flag CameraPattern_IsConstraintValid(const CameraPattern* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->pattern_sequence <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERAPATTERN_PATTERN_SEQUENCE;
+
+	return ret;
+}
+
+flag CameraPattern_Encode(const CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraPattern_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode pattern_sequence */
+	        ret = PatternSequence_Encode((&(pVal->pattern_sequence)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraPattern_Decode(CameraPattern* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode pattern_sequence */
+	    ret = PatternSequence_Decode((&(pVal->pattern_sequence)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CameraPattern_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CameraConfiguration_Initialize(CameraConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set shutter */
+	T_UInt32_Initialize((&(pVal->shutter)));
+	/*set gain */
+	T_Float_Initialize((&(pVal->gain)));
+	/*set auto_exposure_enabled */
+	T_Boolean_Initialize((&(pVal->auto_exposure_enabled)));
+	/*set max_shutter */
+	T_UInt32_Initialize((&(pVal->max_shutter)));
+	/*set max_gain */
+	T_Float_Initialize((&(pVal->max_gain)));
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+	/*set flash_enabled */
+	T_Boolean_Initialize((&(pVal->flash_enabled)));
+	/*set flash_strength */
+	T_UInt8_Initialize((&(pVal->flash_strength)));
+	/*set pattern_enabled */
+	T_Boolean_Initialize((&(pVal->pattern_enabled)));
+	/*set pattern_sequence */
+	T_UInt16_Initialize((&(pVal->pattern_sequence)));
+}
+
+flag CameraConfiguration_IsConstraintValid(const CameraConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->shutter <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_SHUTTER;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->gain) && (pVal->gain <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_GAIN;
+        if (ret) {
+            ret = (pVal->max_shutter <= 4294967295UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_MAX_SHUTTER;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->max_gain) && (pVal->max_gain <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_MAX_GAIN;
+                if (ret) {
+                    ret = (pVal->region.offset_x <= 65535UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_OFFSET_X;
+                    if (ret) {
+                        ret = (pVal->region.offset_y <= 65535UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_OFFSET_Y;
+                        if (ret) {
+                            ret = (pVal->region.size_x <= 65535UL);
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_SIZE_X;
+                            if (ret) {
+                                ret = (pVal->region.size_y <= 65535UL);
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_REGION_SIZE_Y;
+                            }
+                        }
+                    }
+                    if (ret) {
+                        ret = (pVal->flash_strength <= 255UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_FLASH_STRENGTH;
+                        if (ret) {
+                            ret = (pVal->pattern_sequence <= 65535UL);
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CAMERACONFIGURATION_PATTERN_SEQUENCE;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag CameraConfiguration_Encode(const CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CameraConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode shutter */
+	    ret = ShutterTime_Encode((&(pVal->shutter)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode gain */
+	        ret = SensorGain_Encode((&(pVal->gain)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode auto_exposure_enabled */
+	            ret = T_Boolean_Encode((&(pVal->auto_exposure_enabled)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode max_shutter */
+	                ret = ShutterTime_Encode((&(pVal->max_shutter)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode max_gain */
+	                    ret = SensorGain_Encode((&(pVal->max_gain)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode region_enabled */
+	                        ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode region */
+	                            ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode flash_enabled */
+	                                ret = T_Boolean_Encode((&(pVal->flash_enabled)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode flash_strength */
+	                                    ret = FlashStrength_Encode((&(pVal->flash_strength)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode pattern_enabled */
+	                                        ret = T_Boolean_Encode((&(pVal->pattern_enabled)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode pattern_sequence */
+	                                            ret = PatternSequence_Encode((&(pVal->pattern_sequence)), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CameraConfiguration_Decode(CameraConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode shutter */
+	ret = ShutterTime_Decode((&(pVal->shutter)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode gain */
+	    ret = SensorGain_Decode((&(pVal->gain)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode auto_exposure_enabled */
+	        ret = T_Boolean_Decode((&(pVal->auto_exposure_enabled)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode max_shutter */
+	            ret = ShutterTime_Decode((&(pVal->max_shutter)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode max_gain */
+	                ret = SensorGain_Decode((&(pVal->max_gain)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode region_enabled */
+	                    ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode region */
+	                        ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode flash_enabled */
+	                            ret = T_Boolean_Decode((&(pVal->flash_enabled)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode flash_strength */
+	                                ret = FlashStrength_Decode((&(pVal->flash_strength)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode pattern_enabled */
+	                                    ret = T_Boolean_Decode((&(pVal->pattern_enabled)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode pattern_sequence */
+	                                        ret = PatternSequence_Decode((&(pVal->pattern_sequence)), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && CameraConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Common.cpp b/generated/src/Common.cpp
new file mode 100644
index 0000000..49e7447
--- /dev/null
+++ b/generated/src/Common.cpp
@@ -0,0 +1,346 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Common.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Timepoint_Initialize(Timepoint* pVal)
+{
+	(void)pVal;
+
+
+	T_Int64_Initialize(pVal);
+}
+
+flag Timepoint_IsConstraintValid(const Timepoint* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag Timepoint_Encode(const Timepoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Timepoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_Int64_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Timepoint_Decode(Timepoint* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_Int64_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && Timepoint_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void NodeID_Initialize(NodeID* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag NodeID_IsConstraintValid(const NodeID* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 16777215UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_NODEID;
+
+	return ret;
+}
+
+flag NodeID_Encode(const NodeID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? NodeID_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag NodeID_Decode(NodeID* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_NODEID;
+
+	return ret  && NodeID_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void EndpointID_Initialize(EndpointID* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag EndpointID_IsConstraintValid(const EndpointID* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_ENDPOINTID;
+
+	return ret;
+}
+
+flag EndpointID_Encode(const EndpointID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? EndpointID_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag EndpointID_Decode(EndpointID* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_ENDPOINTID;
+
+	return ret  && EndpointID_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ResultCode_Initialize(ResultCode* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = success;
+}
+
+flag ResultCode_IsConstraintValid(const ResultCode* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((*(pVal)) == success)) || (((*(pVal)) == error_node_id)))) || (((*(pVal)) == error_endpoint_id)))) || (((*(pVal)) == error_unsupported)))) || (((*(pVal)) == error_state)))) || (((*(pVal)) == error_value)))) || (((*(pVal)) == error_other)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_RESULTCODE;
+
+	return ret;
+}
+
+flag ResultCode_Encode(const ResultCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ResultCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case success:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
+	        	break;
+	        case error_node_id:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
+	        	break;
+	        case error_endpoint_id:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
+	        	break;
+	        case error_unsupported:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
+	        	break;
+	        case error_state:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
+	        	break;
+	        case error_value:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
+	        	break;
+	        case error_other:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_RESULTCODE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ResultCode_Decode(ResultCode* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_RESULTCODE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = success;
+	                break;
+	            case 1:
+	                (*(pVal)) = error_node_id;
+	                break;
+	            case 2:
+	                (*(pVal)) = error_endpoint_id;
+	                break;
+	            case 3:
+	                (*(pVal)) = error_unsupported;
+	                break;
+	            case 4:
+	                (*(pVal)) = error_state;
+	                break;
+	            case 5:
+	                (*(pVal)) = error_value;
+	                break;
+	            case 6:
+	                (*(pVal)) = error_other;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_RESULTCODE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = success;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && ResultCode_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void CommandResponse_Initialize(CommandResponse* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set result */
+	ResultCode_Initialize((&(pVal->result)));
+	/*set message */
+	T_String_Initialize((&(pVal->message)));
+}
+
+flag CommandResponse_IsConstraintValid(const CommandResponse* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (((((((((((((pVal->result == success)) || ((pVal->result == error_node_id)))) || ((pVal->result == error_endpoint_id)))) || ((pVal->result == error_unsupported)))) || ((pVal->result == error_state)))) || ((pVal->result == error_value)))) || ((pVal->result == error_other)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_COMMANDRESPONSE_RESULT;
+    if (ret) {
+        ret = (pVal->message.nCount <= 40);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_COMMANDRESPONSE_MESSAGE;
+    }
+
+	return ret;
+}
+
+flag CommandResponse_Encode(const CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? CommandResponse_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode result */
+	    ret = ResultCode_Encode((&(pVal->result)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode message */
+	        ret = T_String_Encode((&(pVal->message)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag CommandResponse_Decode(CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode result */
+	ret = ResultCode_Decode((&(pVal->result)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode message */
+	    ret = T_String_Decode((&(pVal->message)), pBitStrm, pErrCode);
+	}
+
+	return ret  && CommandResponse_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/DepthMap.cpp b/generated/src/DepthMap.cpp
new file mode 100644
index 0000000..bb1531c
--- /dev/null
+++ b/generated/src/DepthMap.cpp
@@ -0,0 +1,224 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/DepthMap.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Depth_format_t_Initialize(Depth_format_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = depth_f;
+}
+
+flag Depth_format_t_IsConstraintValid(const Depth_format_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) == depth_f);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_DEPTH_FORMAT_T;
+
+	return ret;
+}
+
+flag Depth_format_t_Encode(const Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Depth_format_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case depth_f:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_DEPTH_FORMAT_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Depth_format_t_Decode(Depth_format_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_DEPTH_FORMAT_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = depth_f;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_DEPTH_FORMAT_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = depth_f;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Depth_format_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void DepthMapDescriptor_Initialize(DepthMapDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set depth_format */
+	Depth_format_t_Initialize((&(pVal->depth_format)));
+	/*set depth_size */
+	T_UInt8_Initialize((&(pVal->depth_size)));
+	/*set width */
+	T_UInt16_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt16_Initialize((&(pVal->height)));
+}
+
+flag DepthMapDescriptor_IsConstraintValid(const DepthMapDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->depth_format == depth_f);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_DEPTH_FORMAT;
+        if (ret) {
+            ret = (pVal->depth_size <= 255UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_DEPTH_SIZE;
+            if (ret) {
+                ret = (pVal->width <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_WIDTH;
+                if (ret) {
+                    ret = (pVal->height <= 65535UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_DEPTHMAPDESCRIPTOR_HEIGHT;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag DepthMapDescriptor_Encode(const DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? DepthMapDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode depth_format */
+	        ret = Depth_format_t_Encode((&(pVal->depth_format)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode depth_size */
+	            ret = T_UInt8_Encode((&(pVal->depth_size)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode width */
+	                ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode height */
+	                    ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag DepthMapDescriptor_Decode(DepthMapDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode depth_format */
+	    ret = Depth_format_t_Decode((&(pVal->depth_format)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode depth_size */
+	        ret = T_UInt8_Decode((&(pVal->depth_size)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode width */
+	            ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode height */
+	                ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && DepthMapDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Flash.cpp b/generated/src/Flash.cpp
new file mode 100644
index 0000000..6a2032f
--- /dev/null
+++ b/generated/src/Flash.cpp
@@ -0,0 +1,83 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Flash.hpp>
+namespace i3ds_asn1 {
+
+
+
+void FlashSetup_Initialize(FlashSetup* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set duration */
+	T_UInt32_Initialize((&(pVal->duration)));
+	/*set strength */
+	T_UInt8_Initialize((&(pVal->strength)));
+}
+
+flag FlashSetup_IsConstraintValid(const FlashSetup* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->duration <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_FLASHSETUP_DURATION;
+    if (ret) {
+        ret = (pVal->strength <= 255UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_FLASHSETUP_STRENGTH;
+    }
+
+	return ret;
+}
+
+flag FlashSetup_Encode(const FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? FlashSetup_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode duration */
+	    ret = ShutterTime_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode strength */
+	        ret = FlashStrength_Encode((&(pVal->strength)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag FlashSetup_Decode(FlashSetup* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode duration */
+	ret = ShutterTime_Decode((&(pVal->duration)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode strength */
+	    ret = FlashStrength_Decode((&(pVal->strength)), pBitStrm, pErrCode);
+	}
+
+	return ret  && FlashSetup_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Frame.cpp b/generated/src/Frame.cpp
new file mode 100644
index 0000000..1249766
--- /dev/null
+++ b/generated/src/Frame.cpp
@@ -0,0 +1,328 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Frame.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Frame_mode_t_Initialize(Frame_mode_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = mode_undefined;
+}
+
+flag Frame_mode_t_IsConstraintValid(const Frame_mode_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((((((((((((((((*(pVal)) == mode_undefined)) || (((*(pVal)) == mode_mono)))) || (((*(pVal)) == mode_rgb)))) || (((*(pVal)) == mode_bgr)))) || (((*(pVal)) == mode_uyvy)))) || (((*(pVal)) == mode_rgba)))) || (((*(pVal)) == mode_bayer_rggb)))) || (((*(pVal)) == mode_bayer_grbg)))) || (((*(pVal)) == mode_bayer_bggr)))) || (((*(pVal)) == mode_bayer_gbrg)))) || (((*(pVal)) == mode_pjpg)))) || (((*(pVal)) == mode_jpeg)))) || (((*(pVal)) == mode_png)))) || (((*(pVal)) == mode_tiff)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_FRAME_MODE_T;
+
+	return ret;
+}
+
+flag Frame_mode_t_Encode(const Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case mode_undefined:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 13);
+	        	break;
+	        case mode_mono:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 13);
+	        	break;
+	        case mode_rgb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 13);
+	        	break;
+	        case mode_bgr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 13);
+	        	break;
+	        case mode_uyvy:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 13);
+	        	break;
+	        case mode_rgba:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 13);
+	        	break;
+	        case mode_bayer_rggb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 13);
+	        	break;
+	        case mode_bayer_grbg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 13);
+	        	break;
+	        case mode_bayer_bggr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 13);
+	        	break;
+	        case mode_bayer_gbrg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 13);
+	        	break;
+	        case mode_pjpg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 13);
+	        	break;
+	        case mode_jpeg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 13);
+	        	break;
+	        case mode_png:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 13);
+	        	break;
+	        case mode_tiff:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 13);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_FRAME_MODE_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Frame_mode_t_Decode(Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 13);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_FRAME_MODE_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = mode_undefined;
+	                break;
+	            case 1:
+	                (*(pVal)) = mode_mono;
+	                break;
+	            case 2:
+	                (*(pVal)) = mode_rgb;
+	                break;
+	            case 3:
+	                (*(pVal)) = mode_bgr;
+	                break;
+	            case 4:
+	                (*(pVal)) = mode_uyvy;
+	                break;
+	            case 5:
+	                (*(pVal)) = mode_rgba;
+	                break;
+	            case 6:
+	                (*(pVal)) = mode_bayer_rggb;
+	                break;
+	            case 7:
+	                (*(pVal)) = mode_bayer_grbg;
+	                break;
+	            case 8:
+	                (*(pVal)) = mode_bayer_bggr;
+	                break;
+	            case 9:
+	                (*(pVal)) = mode_bayer_gbrg;
+	                break;
+	            case 10:
+	                (*(pVal)) = mode_pjpg;
+	                break;
+	            case 11:
+	                (*(pVal)) = mode_jpeg;
+	                break;
+	            case 12:
+	                (*(pVal)) = mode_png;
+	                break;
+	            case 13:
+	                (*(pVal)) = mode_tiff;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_FRAME_MODE_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = mode_undefined;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Frame_mode_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void FrameDescriptor_Initialize(FrameDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set frame_mode */
+	Frame_mode_t_Initialize((&(pVal->frame_mode)));
+	/*set data_depth */
+	T_UInt8_Initialize((&(pVal->data_depth)));
+	/*set pixel_size */
+	T_UInt8_Initialize((&(pVal->pixel_size)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+	/*set image_count */
+	T_UInt8_Initialize((&(pVal->image_count)));
+}
+
+flag FrameDescriptor_IsConstraintValid(const FrameDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (((((((((((((((((((((((((((pVal->frame_mode == mode_undefined)) || ((pVal->frame_mode == mode_mono)))) || ((pVal->frame_mode == mode_rgb)))) || ((pVal->frame_mode == mode_bgr)))) || ((pVal->frame_mode == mode_uyvy)))) || ((pVal->frame_mode == mode_rgba)))) || ((pVal->frame_mode == mode_bayer_rggb)))) || ((pVal->frame_mode == mode_bayer_grbg)))) || ((pVal->frame_mode == mode_bayer_bggr)))) || ((pVal->frame_mode == mode_bayer_gbrg)))) || ((pVal->frame_mode == mode_pjpg)))) || ((pVal->frame_mode == mode_jpeg)))) || ((pVal->frame_mode == mode_png)))) || ((pVal->frame_mode == mode_tiff)));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_FRAME_MODE;
+        if (ret) {
+            ret = (pVal->data_depth <= 255UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_DATA_DEPTH;
+            if (ret) {
+                ret = (pVal->pixel_size <= 255UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_PIXEL_SIZE;
+                if (ret) {
+                    ret = (pVal->region.offset_x <= 65535UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_OFFSET_X;
+                    if (ret) {
+                        ret = (pVal->region.offset_y <= 65535UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_OFFSET_Y;
+                        if (ret) {
+                            ret = (pVal->region.size_x <= 65535UL);
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_SIZE_X;
+                            if (ret) {
+                                ret = (pVal->region.size_y <= 65535UL);
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_REGION_SIZE_Y;
+                            }
+                        }
+                    }
+                    if (ret) {
+                        ret = (pVal->image_count <= 255UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_FRAMEDESCRIPTOR_IMAGE_COUNT;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag FrameDescriptor_Encode(const FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? FrameDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode frame_mode */
+	        ret = Frame_mode_t_Encode((&(pVal->frame_mode)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode data_depth */
+	            ret = T_UInt8_Encode((&(pVal->data_depth)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode pixel_size */
+	                ret = T_UInt8_Encode((&(pVal->pixel_size)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode region */
+	                    ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode image_count */
+	                        ret = T_UInt8_Encode((&(pVal->image_count)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag FrameDescriptor_Decode(FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode frame_mode */
+	    ret = Frame_mode_t_Decode((&(pVal->frame_mode)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode data_depth */
+	        ret = T_UInt8_Decode((&(pVal->data_depth)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode pixel_size */
+	            ret = T_UInt8_Decode((&(pVal->pixel_size)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode region */
+	                ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode image_count */
+	                    ret = T_UInt8_Decode((&(pVal->image_count)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && FrameDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/IMU.cpp b/generated/src/IMU.cpp
new file mode 100644
index 0000000..b7e35d8
--- /dev/null
+++ b/generated/src/IMU.cpp
@@ -0,0 +1,300 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/IMU.hpp>
+namespace i3ds_asn1 {
+
+
+
+void IMUSample_Initialize(IMUSample* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set axis_x_rate */
+	T_Double_Initialize((&(pVal->axis_x_rate)));
+	/*set axis_x_acceleration */
+	T_Double_Initialize((&(pVal->axis_x_acceleration)));
+	/*set axis_y_rate */
+	T_Double_Initialize((&(pVal->axis_y_rate)));
+	/*set axis_y_acceleration */
+	T_Double_Initialize((&(pVal->axis_y_acceleration)));
+	/*set axis_z_rate */
+	T_Double_Initialize((&(pVal->axis_z_rate)));
+	/*set axis_z_acceleration */
+	T_Double_Initialize((&(pVal->axis_z_acceleration)));
+}
+
+flag IMUSample_IsConstraintValid(const IMUSample* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->axis_x_rate) && (pVal->axis_x_rate <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_X_RATE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->axis_x_acceleration) && (pVal->axis_x_acceleration <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_X_ACCELERATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->axis_y_rate) && (pVal->axis_y_rate <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Y_RATE;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->axis_y_acceleration) && (pVal->axis_y_acceleration <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Y_ACCELERATION;
+                if (ret) {
+                    ret = ((-1.79769313486231570000E+308 <= pVal->axis_z_rate) && (pVal->axis_z_rate <= 1.79769313486231570000E+308));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Z_RATE;
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->axis_z_acceleration) && (pVal->axis_z_acceleration <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUSAMPLE_AXIS_Z_ACCELERATION;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag IMUSample_Encode(const IMUSample* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? IMUSample_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode axis_x_rate */
+	    ret = T_Double_Encode((&(pVal->axis_x_rate)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode axis_x_acceleration */
+	        ret = T_Double_Encode((&(pVal->axis_x_acceleration)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode axis_y_rate */
+	            ret = T_Double_Encode((&(pVal->axis_y_rate)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode axis_y_acceleration */
+	                ret = T_Double_Encode((&(pVal->axis_y_acceleration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode axis_z_rate */
+	                    ret = T_Double_Encode((&(pVal->axis_z_rate)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode axis_z_acceleration */
+	                        ret = T_Double_Encode((&(pVal->axis_z_acceleration)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag IMUSample_Decode(IMUSample* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode axis_x_rate */
+	ret = T_Double_Decode((&(pVal->axis_x_rate)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode axis_x_acceleration */
+	    ret = T_Double_Decode((&(pVal->axis_x_acceleration)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode axis_y_rate */
+	        ret = T_Double_Decode((&(pVal->axis_y_rate)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode axis_y_acceleration */
+	            ret = T_Double_Decode((&(pVal->axis_y_acceleration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode axis_z_rate */
+	                ret = T_Double_Decode((&(pVal->axis_z_rate)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode axis_z_acceleration */
+	                    ret = T_Double_Decode((&(pVal->axis_z_acceleration)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && IMUSample_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void IMUMeasurement20_samples_Initialize(IMUMeasurement20_samples* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 20) {
+	    IMUSample_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 0;
+}
+void IMUMeasurement20_Initialize(IMUMeasurement20* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set samples */
+	IMUMeasurement20_samples_Initialize((&(pVal->samples)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+}
+
+flag IMUMeasurement20_IsConstraintValid(const IMUMeasurement20* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->samples.nCount <= 20);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->samples.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_x_rate) && (pVal->samples.arr[i1].axis_x_rate <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_RATE;
+            	if (ret) {
+            	    ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_x_acceleration) && (pVal->samples.arr[i1].axis_x_acceleration <= 1.79769313486231570000E+308));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_ACCELERATION;
+            	    if (ret) {
+            	        ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_y_rate) && (pVal->samples.arr[i1].axis_y_rate <= 1.79769313486231570000E+308));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_RATE;
+            	        if (ret) {
+            	            ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_y_acceleration) && (pVal->samples.arr[i1].axis_y_acceleration <= 1.79769313486231570000E+308));
+            	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_ACCELERATION;
+            	            if (ret) {
+            	                ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_z_rate) && (pVal->samples.arr[i1].axis_z_rate <= 1.79769313486231570000E+308));
+            	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_RATE;
+            	                if (ret) {
+            	                    ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_z_acceleration) && (pVal->samples.arr[i1].axis_z_acceleration <= 1.79769313486231570000E+308));
+            	                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_ACCELERATION;
+            	                }
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+        if (ret) {
+            ret = (pVal->batch_size <= 4294967295UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_IMUMEASUREMENT20_BATCH_SIZE;
+        }
+    }
+
+	return ret;
+}
+
+flag IMUMeasurement20_Encode(const IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? IMUMeasurement20_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode samples */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->samples.nCount, 0, 20);
+	        	
+	        for(i1=0; (i1 < (int)pVal->samples.nCount) && ret; i1++)
+	        {
+	        	ret = IMUSample_Encode((&(pVal->samples.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode batch_size */
+	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag IMUMeasurement20_Decode(IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode samples */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 20);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_IMUMEASUREMENT20_SAMPLES;
+	    pVal->samples.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->samples.nCount) && ret; i1++)
+	    {
+	    	ret = IMUSample_Decode((&(pVal->samples.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode batch_size */
+	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && IMUMeasurement20_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/LIDAR.cpp b/generated/src/LIDAR.cpp
new file mode 100644
index 0000000..934e6d5
--- /dev/null
+++ b/generated/src/LIDAR.cpp
@@ -0,0 +1,167 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/LIDAR.hpp>
+namespace i3ds_asn1 {
+
+
+
+void LIDARRegion_Initialize(LIDARRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PolarRegion_Initialize((&(pVal->region)));
+}
+
+flag LIDARRegion_IsConstraintValid(const LIDARRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_x) && (pVal->region.offset_x <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_y) && (pVal->region.offset_y <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->region.size_x) && (pVal->region.size_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->region.size_y) && (pVal->region.size_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag LIDARRegion_Encode(const LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? LIDARRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PolarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag LIDARRegion_Decode(LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PolarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && LIDARRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void LIDARConfiguration_Initialize(LIDARConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PolarRegion_Initialize((&(pVal->region)));
+}
+
+flag LIDARConfiguration_IsConstraintValid(const LIDARConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_x) && (pVal->region.offset_x <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_OFFSET_X;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_y) && (pVal->region.offset_y <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->region.size_x) && (pVal->region.size_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_SIZE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->region.size_y) && (pVal->region.size_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_LIDARCONFIGURATION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag LIDARConfiguration_Encode(const LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? LIDARConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode region_enabled */
+	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PolarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag LIDARConfiguration_Decode(LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode region_enabled */
+	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PolarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && LIDARConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/PointCloud.cpp b/generated/src/PointCloud.cpp
new file mode 100644
index 0000000..8945f37
--- /dev/null
+++ b/generated/src/PointCloud.cpp
@@ -0,0 +1,224 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/PointCloud.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Point_format_t_Initialize(Point_format_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = fields_xyz_f;
+}
+
+flag Point_format_t_IsConstraintValid(const Point_format_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) == fields_xyz_f);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_POINT_FORMAT_T;
+
+	return ret;
+}
+
+flag Point_format_t_Encode(const Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Point_format_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case fields_xyz_f:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_POINT_FORMAT_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Point_format_t_Decode(Point_format_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_POINT_FORMAT_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = fields_xyz_f;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_POINT_FORMAT_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = fields_xyz_f;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Point_format_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PointCloudDescriptor_Initialize(PointCloudDescriptor* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set point_format */
+	Point_format_t_Initialize((&(pVal->point_format)));
+	/*set point_size */
+	T_UInt16_Initialize((&(pVal->point_size)));
+	/*set width */
+	T_UInt32_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt32_Initialize((&(pVal->height)));
+}
+
+flag PointCloudDescriptor_IsConstraintValid(const PointCloudDescriptor* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = (pVal->point_format == fields_xyz_f);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_POINT_FORMAT;
+        if (ret) {
+            ret = (pVal->point_size <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_POINT_SIZE;
+            if (ret) {
+                ret = (pVal->width <= 4294967295UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_WIDTH;
+                if (ret) {
+                    ret = (pVal->height <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POINTCLOUDDESCRIPTOR_HEIGHT;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PointCloudDescriptor_Encode(const PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PointCloudDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode point_format */
+	        ret = Point_format_t_Encode((&(pVal->point_format)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode point_size */
+	            ret = T_UInt16_Encode((&(pVal->point_size)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode width */
+	                ret = T_UInt32_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode height */
+	                    ret = T_UInt32_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PointCloudDescriptor_Decode(PointCloudDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode point_format */
+	    ret = Point_format_t_Decode((&(pVal->point_format)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode point_size */
+	        ret = T_UInt16_Decode((&(pVal->point_size)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode width */
+	            ret = T_UInt32_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode height */
+	                ret = T_UInt32_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && PointCloudDescriptor_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/PoseEstimator.cpp b/generated/src/PoseEstimator.cpp
new file mode 100644
index 0000000..f7b552b
--- /dev/null
+++ b/generated/src/PoseEstimator.cpp
@@ -0,0 +1,301 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/PoseEstimator.hpp>
+namespace i3ds_asn1 {
+
+
+
+void PoseEstimatorMeasurement_Initialize(PoseEstimatorMeasurement* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set estimated_pose */
+	Base_Pose_Initialize((&(pVal->estimated_pose)));
+}
+
+flag PoseEstimatorMeasurement_IsConstraintValid(const PoseEstimatorMeasurement* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->estimated_pose.position.data.nCount) && (pVal->estimated_pose.position.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->estimated_pose.position.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->estimated_pose.position.data.arr[i1]) && (pVal->estimated_pose.position.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_POSITION_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->estimated_pose.orientation.im.nCount) && (pVal->estimated_pose.orientation.im.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->estimated_pose.orientation.im.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->estimated_pose.orientation.im.arr[i1]) && (pVal->estimated_pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_IM_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->estimated_pose.orientation.re) && (pVal->estimated_pose.orientation.re <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORMEASUREMENT_ESTIMATED_POSE_ORIENTATION_RE;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PoseEstimatorMeasurement_Encode(const PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorMeasurement_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode estimated_pose */
+	        ret = Base_Pose_Encode((&(pVal->estimated_pose)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorMeasurement_Decode(PoseEstimatorMeasurement* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode estimated_pose */
+	    ret = Base_Pose_Decode((&(pVal->estimated_pose)), pBitStrm, pErrCode);
+	}
+
+	return ret  && PoseEstimatorMeasurement_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PoseEstimatorImagingMode_Initialize(PoseEstimatorImagingMode* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set imaging_mode */
+	T_Boolean_Initialize((&(pVal->imaging_mode)));
+}
+
+flag PoseEstimatorImagingMode_IsConstraintValid(const PoseEstimatorImagingMode* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag PoseEstimatorImagingMode_Encode(const PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorImagingMode_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode imaging_mode */
+	    ret = T_Boolean_Encode((&(pVal->imaging_mode)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorImagingMode_Decode(PoseEstimatorImagingMode* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode imaging_mode */
+	ret = T_Boolean_Decode((&(pVal->imaging_mode)), pBitStrm, pErrCode);
+
+	return ret  && PoseEstimatorImagingMode_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PoseEstimatorCameraSelect_Initialize(PoseEstimatorCameraSelect* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set camera_select */
+	T_UInt8_Initialize((&(pVal->camera_select)));
+}
+
+flag PoseEstimatorCameraSelect_IsConstraintValid(const PoseEstimatorCameraSelect* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->camera_select <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORCAMERASELECT_CAMERA_SELECT;
+
+	return ret;
+}
+
+flag PoseEstimatorCameraSelect_Encode(const PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorCameraSelect_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode camera_select */
+	    ret = T_UInt8_Encode((&(pVal->camera_select)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorCameraSelect_Decode(PoseEstimatorCameraSelect* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode camera_select */
+	ret = T_UInt8_Decode((&(pVal->camera_select)), pBitStrm, pErrCode);
+
+	return ret  && PoseEstimatorCameraSelect_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PoseEstimatorConfiguration_Initialize(PoseEstimatorConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set imaging_mode */
+	T_Boolean_Initialize((&(pVal->imaging_mode)));
+	/*set camera_select */
+	T_UInt8_Initialize((&(pVal->camera_select)));
+}
+
+flag PoseEstimatorConfiguration_IsConstraintValid(const PoseEstimatorConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->camera_select <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POSEESTIMATORCONFIGURATION_CAMERA_SELECT;
+
+	return ret;
+}
+
+flag PoseEstimatorConfiguration_Encode(const PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PoseEstimatorConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode imaging_mode */
+	    ret = T_Boolean_Encode((&(pVal->imaging_mode)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode camera_select */
+	        ret = T_UInt8_Encode((&(pVal->camera_select)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PoseEstimatorConfiguration_Decode(PoseEstimatorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode imaging_mode */
+	ret = T_Boolean_Decode((&(pVal->imaging_mode)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode camera_select */
+	    ret = T_UInt8_Decode((&(pVal->camera_select)), pBitStrm, pErrCode);
+	}
+
+	return ret  && PoseEstimatorConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Power.cpp b/generated/src/Power.cpp
new file mode 100644
index 0000000..c45548d
--- /dev/null
+++ b/generated/src/Power.cpp
@@ -0,0 +1,132 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Power.hpp>
+namespace i3ds_asn1 {
+
+
+
+void PowerMask_Initialize(PowerMask* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 16) {
+	    T_Boolean_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+
+}
+
+flag PowerMask_IsConstraintValid(const PowerMask* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag PowerMask_Encode(const PowerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? PowerMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    	
+	    for(i1=0; (i1 < (int)16) && ret; i1++)
+	    {
+	    	ret = T_Boolean_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PowerMask_Decode(PowerMask* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+
+		
+	for(i1=0; (i1 < (int)16) && ret; i1++)
+	{
+		ret = T_Boolean_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && PowerMask_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PowerOutput_Initialize(PowerOutput* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag PowerOutput_IsConstraintValid(const PowerOutput* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 16UL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_POWEROUTPUT;
+
+	return ret;
+}
+
+flag PowerOutput_Encode(const PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PowerOutput_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 16);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PowerOutput_Decode(PowerOutput* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 16);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_POWEROUTPUT;
+
+	return ret  && PowerOutput_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Radar.cpp b/generated/src/Radar.cpp
new file mode 100644
index 0000000..b8a00f5
--- /dev/null
+++ b/generated/src/Radar.cpp
@@ -0,0 +1,167 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Radar.hpp>
+namespace i3ds_asn1 {
+
+
+
+void RadarRegion_Initialize(RadarRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag RadarRegion_IsConstraintValid(const RadarRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag RadarRegion_Encode(const RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? RadarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag RadarRegion_Decode(RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && RadarRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void RadarConfiguration_Initialize(RadarConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag RadarConfiguration_IsConstraintValid(const RadarConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_RADARCONFIGURATION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag RadarConfiguration_Encode(const RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? RadarConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode region_enabled */
+	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag RadarConfiguration_Decode(RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode region_enabled */
+	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && RadarConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Region.cpp b/generated/src/Region.cpp
new file mode 100644
index 0000000..635fc8c
--- /dev/null
+++ b/generated/src/Region.cpp
@@ -0,0 +1,207 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Region.hpp>
+namespace i3ds_asn1 {
+
+
+
+void PlanarRegion_Initialize(PlanarRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set offset_x */
+	T_UInt16_Initialize((&(pVal->offset_x)));
+	/*set offset_y */
+	T_UInt16_Initialize((&(pVal->offset_y)));
+	/*set size_x */
+	T_UInt16_Initialize((&(pVal->size_x)));
+	/*set size_y */
+	T_UInt16_Initialize((&(pVal->size_y)));
+}
+
+flag PlanarRegion_IsConstraintValid(const PlanarRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_PLANARREGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PlanarRegion_Encode(const PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PlanarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode offset_x */
+	    ret = T_UInt16_Encode((&(pVal->offset_x)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode offset_y */
+	        ret = T_UInt16_Encode((&(pVal->offset_y)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode size_x */
+	            ret = T_UInt16_Encode((&(pVal->size_x)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode size_y */
+	                ret = T_UInt16_Encode((&(pVal->size_y)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PlanarRegion_Decode(PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode offset_x */
+	ret = T_UInt16_Decode((&(pVal->offset_x)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode offset_y */
+	    ret = T_UInt16_Decode((&(pVal->offset_y)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode size_x */
+	        ret = T_UInt16_Decode((&(pVal->size_x)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode size_y */
+	            ret = T_UInt16_Decode((&(pVal->size_y)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && PlanarRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void PolarRegion_Initialize(PolarRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set offset_x */
+	T_Float_Initialize((&(pVal->offset_x)));
+	/*set offset_y */
+	T_Float_Initialize((&(pVal->offset_y)));
+	/*set size_x */
+	T_Float_Initialize((&(pVal->size_x)));
+	/*set size_y */
+	T_Float_Initialize((&(pVal->size_y)));
+}
+
+flag PolarRegion_IsConstraintValid(const PolarRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->offset_x) && (pVal->offset_x <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POLARREGION_OFFSET_X;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->offset_y) && (pVal->offset_y <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POLARREGION_OFFSET_Y;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->size_x) && (pVal->size_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POLARREGION_SIZE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->size_y) && (pVal->size_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_POLARREGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag PolarRegion_Encode(const PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? PolarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode offset_x */
+	    ret = T_Float_Encode((&(pVal->offset_x)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode offset_y */
+	        ret = T_Float_Encode((&(pVal->offset_y)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode size_x */
+	            ret = T_Float_Encode((&(pVal->size_x)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode size_y */
+	                ret = T_Float_Encode((&(pVal->size_y)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag PolarRegion_Decode(PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode offset_x */
+	ret = T_Float_Decode((&(pVal->offset_x)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode offset_y */
+	    ret = T_Float_Decode((&(pVal->offset_y)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode size_x */
+	        ret = T_Float_Decode((&(pVal->size_x)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode size_y */
+	            ret = T_Float_Decode((&(pVal->size_y)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && PolarRegion_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/SampleAttribute.cpp b/generated/src/SampleAttribute.cpp
new file mode 100644
index 0000000..a9025e9
--- /dev/null
+++ b/generated/src/SampleAttribute.cpp
@@ -0,0 +1,479 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/SampleAttribute.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SampleValidity_Initialize(SampleValidity* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = sample_empty;
+}
+
+flag SampleValidity_IsConstraintValid(const SampleValidity* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == sample_empty)) || (((*(pVal)) == sample_valid)))) || (((*(pVal)) == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_SAMPLEVALIDITY;
+
+	return ret;
+}
+
+flag SampleValidity_Encode(const SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SampleValidity_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case sample_empty:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case sample_valid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case sample_invalid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_SAMPLEVALIDITY; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SampleValidity_Decode(SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_SAMPLEVALIDITY;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = sample_empty;
+	                break;
+	            case 1:
+	                (*(pVal)) = sample_valid;
+	                break;
+	            case 2:
+	                (*(pVal)) = sample_invalid;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_SAMPLEVALIDITY;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = sample_empty;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && SampleValidity_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_String8_Initialize(T_String8* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 8);
+	pVal->nCount = 0;
+
+}
+
+flag T_String8_IsConstraintValid(const T_String8* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->nCount <= 8);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_T_STRING8;
+
+	return ret;
+}
+
+flag T_String8_Encode(const T_String8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? T_String8_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 8);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_String8_Decode(T_String8* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 8);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_T_STRING8;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1]));
+		*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_T_STRING8;
+	}
+
+	return ret  && T_String8_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Attribute_value_t_Initialize(Attribute_value_t* pVal)
+{
+	(void)pVal;
+
+
+	/*set boolean_value*/
+	pVal->kind = boolean_value_PRESENT;
+	T_Boolean_Initialize((&(pVal->u.boolean_value)));
+}
+
+flag Attribute_value_t_IsConstraintValid(const Attribute_value_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    if (pVal->kind == real_value_PRESENT) {
+    	ret = ((-1.79769313486231570000E+308 <= pVal->u.real_value) && (pVal->u.real_value <= 1.79769313486231570000E+308));
+    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_ATTRIBUTE_VALUE_T_REAL_VALUE;
+    }
+    if (ret) {
+        if (pVal->kind == string_value_PRESENT) {
+        	ret = (pVal->u.string_value.nCount <= 8);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_ATTRIBUTE_VALUE_T_STRING_VALUE;
+        }
+    }
+
+	return ret;
+}
+
+flag Attribute_value_t_Encode(const Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Attribute_value_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch(pVal->kind)
+	    {
+	    case boolean_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	    	ret = T_Boolean_Encode((&(pVal->u.boolean_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    case discrete_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	    	ret = T_Int64_Encode((&(pVal->u.discrete_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    case real_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	    	ret = T_Double_Encode((&(pVal->u.real_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    case string_value_PRESENT:
+	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	    	ret = T_String8_Encode((&(pVal->u.string_value)), pBitStrm, pErrCode, FALSE);
+	    	break;
+	    default:                            /*COVERAGE_IGNORE*/
+	        *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T;         /*COVERAGE_IGNORE*/
+	        ret = FALSE;                    /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Attribute_value_t_Decode(Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	asn1SccSint Attribute_value_t_index_tmp;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &Attribute_value_t_index_tmp, 0, 3);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_ATTRIBUTE_VALUE_T;
+	if (ret) {
+	    switch(Attribute_value_t_index_tmp)
+	    {
+	    case 0:
+	    	pVal->kind = boolean_value_PRESENT;
+	    	ret = T_Boolean_Decode((&(pVal->u.boolean_value)), pBitStrm, pErrCode);
+	    	break;
+	    case 1:
+	    	pVal->kind = discrete_value_PRESENT;
+	    	ret = T_Int64_Decode((&(pVal->u.discrete_value)), pBitStrm, pErrCode);
+	    	break;
+	    case 2:
+	    	pVal->kind = real_value_PRESENT;
+	    	ret = T_Double_Decode((&(pVal->u.real_value)), pBitStrm, pErrCode);
+	    	break;
+	    case 3:
+	    	pVal->kind = string_value_PRESENT;
+	    	ret = T_String8_Decode((&(pVal->u.string_value)), pBitStrm, pErrCode);
+	    	break;
+	    default:                        /*COVERAGE_IGNORE*/
+	        *pErrCode = i3ds_asn1_ERR_UPER_DECODE_ATTRIBUTE_VALUE_T;     /*COVERAGE_IGNORE*/
+	        ret = FALSE;                /*COVERAGE_IGNORE*/
+	    }
+	}  /*COVERAGE_IGNORE*/
+
+	return ret  && Attribute_value_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Sample_attribute_t_Initialize(Sample_attribute_t* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attribute_key */
+	T_UInt8_Initialize((&(pVal->attribute_key)));
+	/*set attribute_value */
+	Attribute_value_t_Initialize((&(pVal->attribute_value)));
+}
+
+flag Sample_attribute_t_IsConstraintValid(const Sample_attribute_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->attribute_key <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY;
+    if (ret) {
+        if (pVal->attribute_value.kind == real_value_PRESENT) {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->attribute_value.u.real_value) && (pVal->attribute_value.u.real_value <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_REAL_VALUE;
+        }
+        if (ret) {
+            if (pVal->attribute_value.kind == string_value_PRESENT) {
+            	ret = (pVal->attribute_value.u.string_value.nCount <= 8);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_STRING_VALUE;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Sample_attribute_t_Encode(const Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Sample_attribute_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attribute_key */
+	    ret = T_UInt8_Encode((&(pVal->attribute_key)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode attribute_value */
+	        ret = Attribute_value_t_Encode((&(pVal->attribute_value)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Sample_attribute_t_Decode(Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attribute_key */
+	ret = T_UInt8_Decode((&(pVal->attribute_key)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode attribute_value */
+	    ret = Attribute_value_t_Decode((&(pVal->attribute_value)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Sample_attribute_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SampleAttributes_attributes_Initialize(SampleAttributes_attributes* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 4) {
+	    Sample_attribute_t_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 0;
+}
+void SampleAttributes_Initialize(SampleAttributes* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set timestamp */
+	T_Int64_Initialize((&(pVal->timestamp)));
+	/*set validity */
+	SampleValidity_Initialize((&(pVal->validity)));
+	/*set attributes */
+	SampleAttributes_attributes_Initialize((&(pVal->attributes)));
+}
+
+flag SampleAttributes_IsConstraintValid(const SampleAttributes* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->validity == sample_empty)) || ((pVal->validity == sample_valid)))) || ((pVal->validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag SampleAttributes_Encode(const SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? SampleAttributes_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode timestamp */
+	    ret = Timepoint_Encode((&(pVal->timestamp)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode validity */
+	        ret = SampleValidity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode attributes */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 0, 4);
+	            	
+	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	            {
+	            	ret = Sample_attribute_t_Encode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SampleAttributes_Decode(SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode timestamp */
+	ret = Timepoint_Decode((&(pVal->timestamp)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode validity */
+	    ret = SampleValidity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode attributes */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 4);
+	        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_SAMPLEATTRIBUTES_ATTRIBUTES;
+	        pVal->attributes.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	        {
+	        	ret = Sample_attribute_t_Decode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && SampleAttributes_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Sensor.cpp b/generated/src/Sensor.cpp
new file mode 100644
index 0000000..9fd21ea
--- /dev/null
+++ b/generated/src/Sensor.cpp
@@ -0,0 +1,597 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Sensor.hpp>
+namespace i3ds_asn1 {
+
+
+
+void SamplePeriod_Initialize(SamplePeriod* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag SamplePeriod_IsConstraintValid(const SamplePeriod* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_SAMPLEPERIOD;
+
+	return ret;
+}
+
+flag SamplePeriod_Encode(const SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SamplePeriod_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SamplePeriod_Decode(SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && SamplePeriod_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void BatchSize_Initialize(BatchSize* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag BatchSize_IsConstraintValid(const BatchSize* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_BATCHSIZE;
+
+	return ret;
+}
+
+flag BatchSize_Encode(const BatchSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? BatchSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag BatchSize_Decode(BatchSize* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && BatchSize_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void BatchCount_Initialize(BatchCount* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag BatchCount_IsConstraintValid(const BatchCount* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_BATCHCOUNT;
+
+	return ret;
+}
+
+flag BatchCount_Encode(const BatchCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? BatchCount_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag BatchCount_Decode(BatchCount* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && BatchCount_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SampleCommand_Initialize(SampleCommand* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set period */
+	T_UInt32_Initialize((&(pVal->period)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+	/*set batch_count */
+	T_UInt32_Initialize((&(pVal->batch_count)));
+}
+
+flag SampleCommand_IsConstraintValid(const SampleCommand* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->period <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SAMPLECOMMAND_PERIOD;
+    if (ret) {
+        ret = (pVal->batch_size <= 4294967295UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SAMPLECOMMAND_BATCH_SIZE;
+        if (ret) {
+            ret = (pVal->batch_count <= 4294967295UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SAMPLECOMMAND_BATCH_COUNT;
+        }
+    }
+
+	return ret;
+}
+
+flag SampleCommand_Encode(const SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SampleCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode period */
+	    ret = SamplePeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode batch_size */
+	        ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode batch_count */
+	            ret = BatchCount_Encode((&(pVal->batch_count)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SampleCommand_Decode(SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode period */
+	ret = SamplePeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode batch_size */
+	    ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode batch_count */
+	        ret = BatchCount_Decode((&(pVal->batch_count)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && SampleCommand_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SensorConfiguration_Initialize(SensorConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set device_name */
+	T_String_Initialize((&(pVal->device_name)));
+	/*set period */
+	T_UInt32_Initialize((&(pVal->period)));
+	/*set batch_size */
+	T_UInt32_Initialize((&(pVal->batch_size)));
+	/*set batch_count */
+	T_UInt32_Initialize((&(pVal->batch_count)));
+}
+
+flag SensorConfiguration_IsConstraintValid(const SensorConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->device_name.nCount <= 40);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_DEVICE_NAME;
+    if (ret) {
+        ret = (pVal->period <= 4294967295UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_PERIOD;
+        if (ret) {
+            ret = (pVal->batch_size <= 4294967295UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_BATCH_SIZE;
+            if (ret) {
+                ret = (pVal->batch_count <= 4294967295UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SENSORCONFIGURATION_BATCH_COUNT;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag SensorConfiguration_Encode(const SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode device_name */
+	    ret = T_String_Encode((&(pVal->device_name)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode period */
+	        ret = SamplePeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode batch_size */
+	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode batch_count */
+	                ret = BatchCount_Encode((&(pVal->batch_count)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorConfiguration_Decode(SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode device_name */
+	ret = T_String_Decode((&(pVal->device_name)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode period */
+	    ret = SamplePeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode batch_size */
+	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode batch_count */
+	            ret = BatchCount_Decode((&(pVal->batch_count)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && SensorConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SensorState_Initialize(SensorState* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = inactive;
+}
+
+flag SensorState_IsConstraintValid(const SensorState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((*(pVal)) == inactive)) || (((*(pVal)) == standby)))) || (((*(pVal)) == operational)))) || (((*(pVal)) == failure)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_SENSORSTATE;
+
+	return ret;
+}
+
+flag SensorState_Encode(const SensorState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case inactive:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	        	break;
+	        case standby:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	        	break;
+	        case operational:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	        	break;
+	        case failure:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_SENSORSTATE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorState_Decode(SensorState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_SENSORSTATE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = inactive;
+	                break;
+	            case 1:
+	                (*(pVal)) = standby;
+	                break;
+	            case 2:
+	                (*(pVal)) = operational;
+	                break;
+	            case 3:
+	                (*(pVal)) = failure;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_SENSORSTATE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = inactive;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && SensorState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void SensorStatus_Initialize(SensorStatus* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set current_state */
+	SensorState_Initialize((&(pVal->current_state)));
+	/*set device_temperature */
+	Base_Temperature_Initialize((&(pVal->device_temperature)));
+}
+
+flag SensorStatus_IsConstraintValid(const SensorStatus* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (((((((pVal->current_state == inactive)) || ((pVal->current_state == standby)))) || ((pVal->current_state == operational)))) || ((pVal->current_state == failure)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_SENSORSTATUS_CURRENT_STATE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->device_temperature.kelvin) && (pVal->device_temperature.kelvin <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_SENSORSTATUS_DEVICE_TEMPERATURE_KELVIN;
+    }
+
+	return ret;
+}
+
+flag SensorStatus_Encode(const SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? SensorStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode current_state */
+	    ret = SensorState_Encode((&(pVal->current_state)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode device_temperature */
+	        ret = Base_Temperature_Encode((&(pVal->device_temperature)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag SensorStatus_Decode(SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode current_state */
+	ret = SensorState_Decode((&(pVal->current_state)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode device_temperature */
+	    ret = Base_Temperature_Decode((&(pVal->device_temperature)), pBitStrm, pErrCode);
+	}
+
+	return ret  && SensorStatus_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void StateCommand_Initialize(StateCommand* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = activate;
+}
+
+flag StateCommand_IsConstraintValid(const StateCommand* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((*(pVal)) == activate)) || (((*(pVal)) == start)))) || (((*(pVal)) == stop)))) || (((*(pVal)) == deactivate)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_STATECOMMAND;
+
+	return ret;
+}
+
+flag StateCommand_Encode(const StateCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? StateCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case activate:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	        	break;
+	        case start:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	        	break;
+	        case stop:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	        	break;
+	        case deactivate:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_STATECOMMAND; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag StateCommand_Decode(StateCommand* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_STATECOMMAND;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = activate;
+	                break;
+	            case 1:
+	                (*(pVal)) = start;
+	                break;
+	            case 2:
+	                (*(pVal)) = stop;
+	                break;
+	            case 3:
+	                (*(pVal)) = deactivate;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_STATECOMMAND;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = activate;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && StateCommand_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/StarTracker.cpp b/generated/src/StarTracker.cpp
new file mode 100644
index 0000000..9fa78ff
--- /dev/null
+++ b/generated/src/StarTracker.cpp
@@ -0,0 +1,118 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/StarTracker.hpp>
+namespace i3ds_asn1 {
+
+
+
+void StarTrackerMeasurement_Initialize(StarTrackerMeasurement* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set attributes */
+	SampleAttributes_Initialize((&(pVal->attributes)));
+	/*set position */
+	Wrappers_Quaterniond_Initialize((&(pVal->position)));
+}
+
+flag StarTrackerMeasurement_IsConstraintValid(const StarTrackerMeasurement* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_VALIDITY;
+    if (ret) {
+        ret = (pVal->attributes.attributes.nCount <= 4);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY;
+            	if (ret) {
+            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE;
+            	    }
+            	    if (ret) {
+            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
+            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->position.im.nCount) && (pVal->position.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_POSITION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->position.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->position.im.arr[i1]) && (pVal->position.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_POSITION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->position.re) && (pVal->position.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STARTRACKERMEASUREMENT_POSITION_RE;
+        }
+    }
+
+	return ret;
+}
+
+flag StarTrackerMeasurement_Encode(const StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? StarTrackerMeasurement_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode attributes */
+	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode position */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag StarTrackerMeasurement_Decode(StarTrackerMeasurement* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode attributes */
+	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode position */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	}
+
+	return ret  && StarTrackerMeasurement_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/ToFCamera.cpp b/generated/src/ToFCamera.cpp
new file mode 100644
index 0000000..6fd1e4e
--- /dev/null
+++ b/generated/src/ToFCamera.cpp
@@ -0,0 +1,263 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/ToFCamera.hpp>
+namespace i3ds_asn1 {
+
+
+
+void ToFRange_Initialize(ToFRange* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set min_depth */
+	T_Float_Initialize((&(pVal->min_depth)));
+	/*set max_depth */
+	T_Float_Initialize((&(pVal->max_depth)));
+}
+
+flag ToFRange_IsConstraintValid(const ToFRange* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_TOFRANGE_MIN_DEPTH;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_TOFRANGE_MAX_DEPTH;
+    }
+
+	return ret;
+}
+
+flag ToFRange_Encode(const ToFRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ToFRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode min_depth */
+	    ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode max_depth */
+	        ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ToFRange_Decode(ToFRange* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode min_depth */
+	ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode max_depth */
+	    ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
+	}
+
+	return ret  && ToFRange_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ToFRegion_Initialize(ToFRegion* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set enable */
+	T_Boolean_Initialize((&(pVal->enable)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+}
+
+flag ToFRegion_IsConstraintValid(const ToFRegion* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFREGION_REGION_SIZE_Y;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag ToFRegion_Encode(const ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ToFRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode enable */
+	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ToFRegion_Decode(ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode enable */
+	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	}
+
+	return ret  && ToFRegion_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ToFConfiguration_Initialize(ToFConfiguration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set region_enabled */
+	T_Boolean_Initialize((&(pVal->region_enabled)));
+	/*set region */
+	PlanarRegion_Initialize((&(pVal->region)));
+	/*set min_depth */
+	T_Float_Initialize((&(pVal->min_depth)));
+	/*set max_depth */
+	T_Float_Initialize((&(pVal->max_depth)));
+}
+
+flag ToFConfiguration_IsConstraintValid(const ToFConfiguration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->region.offset_x <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_OFFSET_X;
+    if (ret) {
+        ret = (pVal->region.offset_y <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_OFFSET_Y;
+        if (ret) {
+            ret = (pVal->region.size_x <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_SIZE_X;
+            if (ret) {
+                ret = (pVal->region.size_y <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_REGION_SIZE_Y;
+            }
+        }
+    }
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_MIN_DEPTH;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_TOFCONFIGURATION_MAX_DEPTH;
+        }
+    }
+
+	return ret;
+}
+
+flag ToFConfiguration_Encode(const ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ToFConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode region_enabled */
+	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode region */
+	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode min_depth */
+	            ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode max_depth */
+	                ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ToFConfiguration_Decode(ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode region_enabled */
+	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode region */
+	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode min_depth */
+	        ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode max_depth */
+	            ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && ToFConfiguration_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/Trigger.cpp b/generated/src/Trigger.cpp
new file mode 100644
index 0000000..5802d70
--- /dev/null
+++ b/generated/src/Trigger.cpp
@@ -0,0 +1,677 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/Trigger.hpp>
+namespace i3ds_asn1 {
+
+
+
+void TriggerMask_Initialize(TriggerMask* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 8) {
+	    T_Boolean_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+
+}
+
+flag TriggerMask_IsConstraintValid(const TriggerMask* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag TriggerMask_Encode(const TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? TriggerMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    	
+	    for(i1=0; (i1 < (int)8) && ret; i1++)
+	    {
+	    	ret = T_Boolean_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerMask_Decode(TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+
+		
+	for(i1=0; (i1 < (int)8) && ret; i1++)
+	{
+		ret = T_Boolean_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && TriggerMask_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerGenerator_Initialize(TriggerGenerator* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag TriggerGenerator_IsConstraintValid(const TriggerGenerator* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 4UL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_TRIGGERGENERATOR;
+
+	return ret;
+}
+
+flag TriggerGenerator_Encode(const TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerGenerator_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 4);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerGenerator_Decode(TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 4);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_TRIGGERGENERATOR;
+
+	return ret  && TriggerGenerator_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerInput_Initialize(TriggerInput* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag TriggerInput_IsConstraintValid(const TriggerInput* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 4UL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_TRIGGERINPUT;
+
+	return ret;
+}
+
+flag TriggerInput_Encode(const TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerInput_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 4);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerInput_Decode(TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 4);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_TRIGGERINPUT;
+
+	return ret  && TriggerInput_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerOutput_Initialize(TriggerOutput* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 1;
+}
+
+flag TriggerOutput_IsConstraintValid(const TriggerOutput* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 8UL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_TRIGGEROUTPUT;
+
+	return ret;
+}
+
+flag TriggerOutput_Encode(const TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerOutput_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 8);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerOutput_Decode(TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 8);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_TRIGGEROUTPUT;
+
+	return ret  && TriggerOutput_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerPeriod_Initialize(TriggerPeriod* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag TriggerPeriod_IsConstraintValid(const TriggerPeriod* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 16777215UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_TRIGGERPERIOD;
+
+	return ret;
+}
+
+flag TriggerPeriod_Encode(const TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerPeriod_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerPeriod_Decode(TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_TRIGGERPERIOD;
+
+	return ret  && TriggerPeriod_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void GeneratorSetup_Initialize(GeneratorSetup* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set source */
+	TriggerGenerator_Initialize((&(pVal->source)));
+	/*set period */
+	TriggerPeriod_Initialize((&(pVal->period)));
+}
+
+flag GeneratorSetup_IsConstraintValid(const GeneratorSetup* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_GENERATORSETUP_SOURCE;
+    if (ret) {
+        ret = (pVal->period <= 16777215UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_GENERATORSETUP_PERIOD;
+    }
+
+	return ret;
+}
+
+flag GeneratorSetup_Encode(const GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? GeneratorSetup_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode source */
+	    ret = TriggerGenerator_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode period */
+	        ret = TriggerPeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag GeneratorSetup_Decode(GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode source */
+	ret = TriggerGenerator_Decode((&(pVal->source)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode period */
+	    ret = TriggerPeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
+	}
+
+	return ret  && GeneratorSetup_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerOffset_Initialize(TriggerOffset* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag TriggerOffset_IsConstraintValid(const TriggerOffset* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 16777215UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_TRIGGEROFFSET;
+
+	return ret;
+}
+
+flag TriggerOffset_Encode(const TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerOffset_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerOffset_Decode(TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_TRIGGEROFFSET;
+
+	return ret  && TriggerOffset_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void TriggerDuration_Initialize(TriggerDuration* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag TriggerDuration_IsConstraintValid(const TriggerDuration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 1023UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_TRIGGERDURATION;
+
+	return ret;
+}
+
+flag TriggerDuration_Encode(const TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? TriggerDuration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1023);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag TriggerDuration_Decode(TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1023);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_TRIGGERDURATION;
+
+	return ret  && TriggerDuration_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ChannelInternal_Initialize(ChannelInternal* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set output_channel */
+	TriggerOutput_Initialize((&(pVal->output_channel)));
+	/*set source */
+	TriggerGenerator_Initialize((&(pVal->source)));
+	/*set offset */
+	TriggerOffset_Initialize((&(pVal->offset)));
+	/*set duration */
+	TriggerDuration_Initialize((&(pVal->duration)));
+	/*set invert */
+	T_Boolean_Initialize((&(pVal->invert)));
+}
+
+flag ChannelInternal_IsConstraintValid(const ChannelInternal* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= pVal->output_channel) && (pVal->output_channel <= 8UL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_OUTPUT_CHANNEL;
+    if (ret) {
+        ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_SOURCE;
+        if (ret) {
+            ret = (pVal->offset <= 16777215UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_OFFSET;
+            if (ret) {
+                ret = (pVal->duration <= 1023UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELINTERNAL_DURATION;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag ChannelInternal_Encode(const ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ChannelInternal_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode output_channel */
+	    ret = TriggerOutput_Encode((&(pVal->output_channel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode source */
+	        ret = TriggerGenerator_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode offset */
+	            ret = TriggerOffset_Encode((&(pVal->offset)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode duration */
+	                ret = TriggerDuration_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode invert */
+	                    ret = T_Boolean_Encode((&(pVal->invert)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ChannelInternal_Decode(ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode output_channel */
+	ret = TriggerOutput_Decode((&(pVal->output_channel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode source */
+	    ret = TriggerGenerator_Decode((&(pVal->source)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode offset */
+	        ret = TriggerOffset_Decode((&(pVal->offset)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode duration */
+	            ret = TriggerDuration_Decode((&(pVal->duration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode invert */
+	                ret = T_Boolean_Decode((&(pVal->invert)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && ChannelInternal_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void ChannelExternal_Initialize(ChannelExternal* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set output_channel */
+	TriggerOutput_Initialize((&(pVal->output_channel)));
+	/*set source */
+	TriggerInput_Initialize((&(pVal->source)));
+	/*set offset */
+	TriggerOffset_Initialize((&(pVal->offset)));
+	/*set duration */
+	TriggerDuration_Initialize((&(pVal->duration)));
+	/*set bypass */
+	T_Boolean_Initialize((&(pVal->bypass)));
+	/*set invert */
+	T_Boolean_Initialize((&(pVal->invert)));
+}
+
+flag ChannelExternal_IsConstraintValid(const ChannelExternal* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1UL <= pVal->output_channel) && (pVal->output_channel <= 8UL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_OUTPUT_CHANNEL;
+    if (ret) {
+        ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_SOURCE;
+        if (ret) {
+            ret = (pVal->offset <= 16777215UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_OFFSET;
+            if (ret) {
+                ret = (pVal->duration <= 1023UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_CHANNELEXTERNAL_DURATION;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag ChannelExternal_Encode(const ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? ChannelExternal_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode output_channel */
+	    ret = TriggerOutput_Encode((&(pVal->output_channel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode source */
+	        ret = TriggerInput_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode offset */
+	            ret = TriggerOffset_Encode((&(pVal->offset)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode duration */
+	                ret = TriggerDuration_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode bypass */
+	                    ret = T_Boolean_Encode((&(pVal->bypass)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode invert */
+	                        ret = T_Boolean_Encode((&(pVal->invert)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag ChannelExternal_Decode(ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode output_channel */
+	ret = TriggerOutput_Decode((&(pVal->output_channel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode source */
+	    ret = TriggerInput_Decode((&(pVal->source)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode offset */
+	        ret = TriggerOffset_Decode((&(pVal->offset)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode duration */
+	            ret = TriggerDuration_Decode((&(pVal->duration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode bypass */
+	                ret = T_Boolean_Decode((&(pVal->bypass)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode invert */
+	                    ret = T_Boolean_Decode((&(pVal->invert)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && ChannelExternal_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/asn1crt.cpp b/generated/src/asn1crt.cpp
new file mode 100644
index 0000000..22841e9
--- /dev/null
+++ b/generated/src/asn1crt.cpp
@@ -0,0 +1,117 @@
+#include <string.h>
+#include <assert.h>
+#include <math.h>
+#include <float.h>
+
+#include <i3ds_asn1/asn1crt.hpp>
+namespace i3ds_asn1 {
+
+
+
+
+
+int GetCharIndex(char ch, byte Set[], int setLen)
+{
+    int i=0;
+    for(i=0; i<setLen; i++)
+        if (ch == Set[i])
+            return i;
+    return 0;
+}
+
+
+
+void ByteStream_Init(ByteStream* pStrm, byte* buf, long count)
+{
+    pStrm->count = count;
+    pStrm->buf = buf;
+    memset(pStrm->buf,0x0,(size_t)count);
+    pStrm->currentByte = 0;
+    pStrm->EncodeWhiteSpace = FALSE;
+}
+
+void ByteStream_AttachBuffer(ByteStream* pStrm, unsigned char* buf, long count)
+{
+    pStrm->count = count;
+    pStrm->buf = buf;
+    pStrm->currentByte = 0;
+}
+
+asn1SccSint ByteStream_GetLength(ByteStream* pStrm)
+{
+    return pStrm->currentByte;
+}
+
+#if i3ds_asn1_WORD_SIZE==8
+const asn1SccUint64 ber_aux[] = {
+    0xFF,
+    0xFF00,
+    0xFF0000,
+    0xFF000000,
+    0xFF00000000ULL,
+    0xFF0000000000ULL,
+    0xFF000000000000ULL,
+    0xFF00000000000000ULL };
+#else
+const asn1SccUint32 ber_aux[] = {
+    0xFF,
+    0xFF00,
+    0xFF0000,
+    0xFF000000 };
+#endif
+
+
+
+
+
+
+
+/*
+
+#######                                      ###
+#     # #####       # ######  ####  #####     #  #####  ###### #    # ##### # ###### # ###### #####
+#     # #    #      # #      #    #   #       #  #    # #      ##   #   #   # #      # #      #    #
+#     # #####       # #####  #        #       #  #    # #####  # #  #   #   # #####  # #####  #    #
+#     # #    #      # #      #        #       #  #    # #      #  # #   #   # #      # #      #####
+#     # #    # #    # #      #    #   #       #  #    # #      #   ##   #   # #      # #      #   #
+####### #####   ####  ######  ####    #      ### #####  ###### #    #   #   # #      # ###### #    #
+
+Object Identifier
+
+*/
+
+void ObjectIdentifier_Init(Asn1ObjectIdentifier *pVal) {
+	int i;
+	for (i = 0; i < i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH; i++) {
+		pVal->values[i] = 0;
+	}
+	pVal->nCount = 0;
+}
+
+flag ObjectIdentifier_isValid(const Asn1ObjectIdentifier *pVal) {
+	return (pVal->nCount >= 2) && (pVal->values[0] <= 2) && (pVal->values[1] <= 39);
+}
+
+flag RelativeOID_isValid(const Asn1ObjectIdentifier *pVal) {
+	return pVal->nCount > 0;
+}
+
+flag ObjectIdentifier_equal(const Asn1ObjectIdentifier *pVal1, const Asn1ObjectIdentifier *pVal2) {
+	int i;
+	if ((pVal1 != NULL) && (pVal2 != NULL) && pVal1->nCount == pVal2->nCount && pVal1->nCount <= i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH) {
+		flag ret = true;
+		for (i = 0; i < pVal1->nCount && ret; i++)
+		{
+			ret = (pVal1->values[i] == pVal2->values[i]);
+		}
+		return ret;
+	}
+	else {
+		return FALSE;
+	}
+}
+
+
+
+} // namespace i3ds_asn1
+
diff --git a/generated/src/asn1crt_encoding.cpp b/generated/src/asn1crt_encoding.cpp
new file mode 100644
index 0000000..d942561
--- /dev/null
+++ b/generated/src/asn1crt_encoding.cpp
@@ -0,0 +1,1004 @@
+#include <string.h>
+#include <assert.h>
+#include <math.h>
+#include <float.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+namespace i3ds_asn1 {
+
+
+
+static byte masks[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
+static byte masksb[] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F, 0xFF };
+
+static asn1SccUint32 masks2[] = { 0x0,
+0xFF,
+0xFF00,
+0xFF0000,
+0xFF000000 };
+
+/***********************************************************************************************/
+/*   Bit Stream Functions                                                                      */
+/***********************************************************************************************/
+
+flag OctetString_equal(int len1, int len2, const byte arr1[], const byte arr2[])
+{
+	return (len1 == len2) && (memcmp(arr1, arr2, len1) == 0);
+}
+
+flag BitString_equal(int nBitsLength1, int nBitsLength2, const byte arr1[], const byte arr2[])
+{
+	return
+		(nBitsLength1 == nBitsLength2) &&
+		(nBitsLength1 / 8 == 0 || memcmp(arr1, arr2, nBitsLength1 / 8) == 0) &&
+		(nBitsLength1 % 8 > 0 ? (arr1[nBitsLength1 / 8] >> (8 - nBitsLength1 % 8) == arr2[nBitsLength1 / 8] >> (8 - nBitsLength1 % 8)) : TRUE);
+}
+
+
+void BitStream_Init(BitStream* pBitStrm, unsigned char* buf, long count)
+{
+	pBitStrm->count = count;
+	pBitStrm->buf = buf;
+	memset(pBitStrm->buf, 0x0, (size_t)count);
+	pBitStrm->currentByte = 0;
+	pBitStrm->currentBit = 0;
+}
+
+void BitStream_AttachBuffer(BitStream* pBitStrm, unsigned char* buf, long count)
+{
+	pBitStrm->count = count;
+	pBitStrm->buf = buf;
+	pBitStrm->currentByte = 0;
+	pBitStrm->currentBit = 0;
+}
+
+asn1SccSint BitStream_GetLength(BitStream* pBitStrm)
+{
+	int ret = pBitStrm->currentByte;
+	if (pBitStrm->currentBit)
+		ret++;
+	return ret;
+}
+
+
+void BitStream_AppendBitOne(BitStream* pBitStrm)
+{
+	pBitStrm->buf[pBitStrm->currentByte] |= masks[pBitStrm->currentBit];
+
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+}
+
+void BitStream_AppendBitZero(BitStream* pBitStrm)
+{
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+}
+
+void BitStream_AppendNBitZero(BitStream* pBitStrm, int nbits)
+{
+	int totalBits = pBitStrm->currentBit + nbits;
+	pBitStrm->currentBit = totalBits % 8;
+	pBitStrm->currentByte += totalBits / 8;
+}
+
+void BitStream_AppendNBitOne(BitStream* pBitStrm, int nbits)
+{
+	int i;
+
+	while (nbits >= 8) {
+		BitStream_AppendByte(pBitStrm, 0xFF, FALSE);
+		nbits -= 8;
+	}
+	for (i = 0; i<nbits; i++)
+		BitStream_AppendBitOne(pBitStrm);
+
+}
+
+void BitStream_AppendBits(BitStream* pBitStrm, const byte* srcBuffer, int nbits)
+{
+	int i = 0;
+	byte lastByte = 0;
+
+	while (nbits >= 8) {
+		BitStream_AppendByte(pBitStrm, srcBuffer[i], FALSE);
+		nbits -= 8;
+		i++;
+	}
+	if (nbits > 0) {
+		lastByte = (byte)(srcBuffer[i] >> (8 - nbits));
+		BitStream_AppendPartialByte(pBitStrm, lastByte, (byte)nbits, FALSE);
+	}
+}
+
+void BitStream_AppendBit(BitStream* pBitStrm, flag v)
+{
+	if (v)
+		pBitStrm->buf[pBitStrm->currentByte] |= masks[pBitStrm->currentBit];
+
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+}
+
+
+flag BitStream_ReadBit(BitStream* pBitStrm, flag* v)
+{
+	*v = pBitStrm->buf[pBitStrm->currentByte] & masks[pBitStrm->currentBit];
+
+	if (pBitStrm->currentBit<7)
+		pBitStrm->currentBit++;
+	else {
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+	}
+	return pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8;
+}
+
+void BitStream_AppendByte(BitStream* pBitStrm, byte v, flag negate)
+{
+	int cb = pBitStrm->currentBit;
+	int ncb = 8 - cb;
+	if (negate)
+		v = (byte)~v;
+	pBitStrm->buf[pBitStrm->currentByte++] |= (byte)(v >> cb);
+
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+
+	if (cb)
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << ncb);
+
+}
+
+void BitStream_AppendByte0(BitStream* pBitStrm, byte v)
+{
+	int cb = pBitStrm->currentBit;
+	int ncb = 8 - cb;
+
+	pBitStrm->buf[pBitStrm->currentByte++] |= (byte)(v >> cb);
+
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+
+	if (cb)
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << ncb);
+
+}
+
+
+flag BitStream_ReadByte(BitStream* pBitStrm, byte* v)
+{
+	int cb = pBitStrm->currentBit;
+	int ncb = 8 - pBitStrm->currentBit;
+	*v = (byte)(pBitStrm->buf[pBitStrm->currentByte++] << cb);
+
+	if (cb) {
+		*v |= (byte)(pBitStrm->buf[pBitStrm->currentByte] >> ncb);
+	}
+
+	return pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8;
+}
+
+flag BitStream_ReadBits(BitStream* pBitStrm, byte* BuffToWrite, int nbits)
+{
+	int i = 0;
+
+	while (nbits >= 8) {
+		if (!BitStream_ReadByte(pBitStrm, &BuffToWrite[i]))
+			return FALSE;
+		nbits -= 8;
+		i++;
+	}
+
+	if (nbits > 0) {
+		if (!BitStream_ReadPartialByte(pBitStrm, &BuffToWrite[i], (byte)nbits))
+			return FALSE;
+		BuffToWrite[i] = (byte)(BuffToWrite[i] << (8 - nbits));
+	}
+
+	return TRUE;
+}
+
+/* nbits 1..7*/
+void BitStream_AppendPartialByte(BitStream* pBitStrm, byte v, byte nbits, flag negate)
+{
+	int cb = pBitStrm->currentBit;
+	int totalBits = cb + nbits;
+	int totalBitsForNextByte;
+	if (negate)
+		v = masksb[nbits] & ((byte)~v);
+
+	if (totalBits <= 8) {
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << (8 - totalBits));
+		pBitStrm->currentBit += nbits;
+		if (pBitStrm->currentBit == 8) {
+			pBitStrm->currentBit = 0;
+			pBitStrm->currentByte++;
+		}
+	}
+	else {
+		totalBitsForNextByte = totalBits - 8;
+		pBitStrm->buf[pBitStrm->currentByte++] |= (byte)(v >> totalBitsForNextByte);
+		pBitStrm->buf[pBitStrm->currentByte] |= (byte)(v << (8 - totalBitsForNextByte));
+		pBitStrm->currentBit = totalBitsForNextByte;
+	}
+	assert(pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8);
+
+}
+
+/* nbits 1..7*/
+flag BitStream_ReadPartialByte(BitStream* pBitStrm, byte *v, byte nbits)
+{
+	int cb = pBitStrm->currentBit;
+	int totalBits = cb + nbits;
+	int totalBitsForNextByte;
+
+	if (totalBits <= 8) {
+		*v = (byte)((pBitStrm->buf[pBitStrm->currentByte] >> (8 - totalBits)) & masksb[nbits]);
+		pBitStrm->currentBit += nbits;
+		if (pBitStrm->currentBit == 8) {
+			pBitStrm->currentBit = 0;
+			pBitStrm->currentByte++;
+		}
+	}
+	else {
+		totalBitsForNextByte = totalBits - 8;
+		*v = (byte)(pBitStrm->buf[pBitStrm->currentByte++] << totalBitsForNextByte);
+		*v |= (byte)(pBitStrm->buf[pBitStrm->currentByte] >> (8 - totalBitsForNextByte));
+		*v &= masksb[nbits];
+		pBitStrm->currentBit = totalBitsForNextByte;
+	}
+	return pBitStrm->currentByte * 8 + pBitStrm->currentBit <= pBitStrm->count * 8;
+}
+
+
+
+
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+/*   Integer Functions                                                                     */
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+/***********************************************************************************************/
+
+
+
+static void BitStream_EncodeNonNegativeInteger32Neg(BitStream* pBitStrm,
+	asn1SccUint32 v,
+	flag negate)
+{
+	int cc;
+	asn1SccUint32 curMask;
+	int pbits;
+
+	if (v == 0)
+		return;
+
+	if (v<0x100) {
+		cc = 8;
+		curMask = 0x80;
+	}
+	else if (v<0x10000) {
+		cc = 16;
+		curMask = 0x8000;
+	}
+	else if (v<0x1000000) {
+		cc = 24;
+		curMask = 0x800000;
+	}
+	else {
+		cc = 32;
+		curMask = 0x80000000;
+	}
+
+	while ((v & curMask) == 0) {
+		curMask >>= 1;
+		cc--;
+	}
+
+	pbits = cc % 8;
+	if (pbits) {
+		cc -= pbits;
+		BitStream_AppendPartialByte(pBitStrm, (byte)(v >> cc), (byte)pbits, negate);
+	}
+
+	while (cc) {
+		asn1SccUint32 t1 = v & masks2[cc >> 3];
+		cc -= 8;
+		BitStream_AppendByte(pBitStrm, (byte)(t1 >> cc), negate);
+	}
+
+}
+
+static flag BitStream_DecodeNonNegativeInteger32Neg(BitStream* pBitStrm,
+	asn1SccUint32* v,
+	int nBits)
+{
+	byte b;
+	*v = 0;
+	while (nBits >= 8) {
+		*v <<= 8;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		*v |= b;
+		nBits -= 8;
+	}
+	if (nBits)
+	{
+		*v <<= nBits;
+		if (!BitStream_ReadPartialByte(pBitStrm, &b, (byte)nBits))
+			return FALSE;
+		*v |= b;
+	}
+
+	return TRUE;
+}
+
+
+
+void BitStream_EncodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint v)
+{
+
+#if i3ds_asn1_WORD_SIZE==8
+	if (v<0x100000000LL)
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, (asn1SccUint32)v, 0);
+	else {
+		asn1SccUint32 hi = (asn1SccUint32)(v >> 32);
+		asn1SccUint32 lo = (asn1SccUint32)v;
+		int nBits;
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, hi, 0);
+
+		nBits = GetNumberOfBitsForNonNegativeInteger(lo);
+		BitStream_AppendNBitZero(pBitStrm, 32 - nBits);
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, lo, 0);
+	}
+#else
+	BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, v, 0);
+#endif
+}
+
+
+flag BitStream_DecodeNonNegativeInteger(BitStream* pBitStrm, asn1SccUint* v, int nBits)
+{
+#if i3ds_asn1_WORD_SIZE==8
+	asn1SccUint32 hi = 0;
+	asn1SccUint32 lo = 0;
+	flag ret;
+
+	if (nBits <= 32)
+	{
+		ret = BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, &lo, nBits);
+		*v = lo;
+		return ret;
+	}
+
+	ret = BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, &hi, 32) && BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, &lo, nBits - 32);
+
+	*v = hi;
+	*v <<= nBits - 32;
+	*v |= lo;
+	return ret;
+#else
+	return BitStream_DecodeNonNegativeInteger32Neg(pBitStrm, v, nBits);
+#endif
+}
+
+
+void BitStream_EncodeNonNegativeIntegerNeg(BitStream* pBitStrm, asn1SccUint v, flag negate)
+{
+#if i3ds_asn1_WORD_SIZE==8
+	if (v<0x100000000LL)
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, (asn1SccUint32)v, negate);
+	else {
+		int nBits;
+		asn1SccUint32 hi = (asn1SccUint32)(v >> 32);
+		asn1SccUint32 lo = (asn1SccUint32)v;
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, hi, negate);
+
+		/*bug !!!!*/
+		if (negate)
+			lo = ~lo;
+		nBits = GetNumberOfBitsForNonNegativeInteger(lo);
+		BitStream_AppendNBitZero(pBitStrm, 32 - nBits);
+		BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, lo, 0);
+	}
+#else
+	BitStream_EncodeNonNegativeInteger32Neg(pBitStrm, v, negate);
+#endif
+}
+
+static int GetNumberOfBitsForNonNegativeInteger32(asn1SccUint32 v)
+{
+	int ret = 0;
+
+	if (v<0x100) {
+		ret = 0;
+	}
+	else if (v<0x10000) {
+		ret = 8;
+		v >>= 8;
+	}
+	else if (v<0x1000000) {
+		ret = 16;
+		v >>= 16;
+	}
+	else {
+		ret = 24;
+		v >>= 24;
+	}
+	while (v>0) {
+		v >>= 1;
+		ret++;
+	}
+	return ret;
+}
+
+int GetNumberOfBitsForNonNegativeInteger(asn1SccUint v)
+{
+#if i3ds_asn1_WORD_SIZE==8
+	if (v<0x100000000LL)
+		return GetNumberOfBitsForNonNegativeInteger32((asn1SccUint32)v);
+	else {
+		asn1SccUint32 hi = (asn1SccUint32)(v >> 32);
+		return 32 + GetNumberOfBitsForNonNegativeInteger32(hi);
+	}
+#else
+	return GetNumberOfBitsForNonNegativeInteger32(v);
+#endif
+}
+
+int GetLengthInBytesOfUInt(asn1SccUint64 v)
+{
+	int ret = 0;
+	asn1SccUint32 v32 = (asn1SccUint32)v;
+#if i3ds_asn1_WORD_SIZE==8
+	if (v>0xFFFFFFFF) {
+		ret = 4;
+		v32 = (asn1SccUint32)(v >> 32);
+	}
+#endif
+
+	if (v32<0x100)
+		return ret + 1;
+	if (v32<0x10000)
+		return ret + 2;
+	if (v32<0x1000000)
+		return ret + 3;
+	return ret + 4;
+}
+
+static int GetLengthSIntHelper(asn1SccUint v)
+{
+	int ret = 0;
+	asn1SccUint32 v32 = (asn1SccUint32)v;
+#if i3ds_asn1_WORD_SIZE==8
+	if (v>0x7FFFFFFF) {
+		ret = 4;
+		v32 = (asn1SccUint32)(v >> 32);
+	}
+#endif
+
+	if (v32 <= 0x7F)
+		return ret + 1;
+	if (v32 <= 0x7FFF)
+		return ret + 2;
+	if (v32 <= 0x7FFFFF)
+		return ret + 3;
+	return ret + 4;
+}
+
+int GetLengthInBytesOfSInt(asn1SccSint v)
+{
+	if (v >= 0)
+		return GetLengthSIntHelper((asn1SccUint)v);
+
+	return GetLengthSIntHelper((asn1SccUint)(-v - 1));
+}
+
+
+
+void BitStream_EncodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min, asn1SccSint max)
+{
+	int nRangeBits;
+	int nBits;
+	asn1SccUint range;
+	assert(min <= max);
+	range = (asn1SccUint)(max - min);
+	if (!range)
+		return;
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+	nBits = GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(v - min));
+	BitStream_AppendNBitZero(pBitStrm, nRangeBits - nBits);
+	BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)(v - min));
+}
+
+void BitStream_EncodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min, asn1SccUint max)
+{
+	int nRangeBits;
+	int nBits;
+	asn1SccUint range;
+	assert(min <= v);
+	assert(v <= max);
+	range = (asn1SccUint)(max - min);
+	if (!range)
+		return;
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+	nBits = GetNumberOfBitsForNonNegativeInteger(v - min);
+	BitStream_AppendNBitZero(pBitStrm, nRangeBits - nBits);
+	BitStream_EncodeNonNegativeInteger(pBitStrm, v - min);
+}
+
+
+flag BitStream_DecodeConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min, asn1SccSint max)
+{
+	asn1SccUint uv;
+	int nRangeBits;
+	asn1SccUint range = (asn1SccUint)(max - min);
+
+	i3ds_asn1_ASSERT_OR_RETURN_FALSE(min <= max);
+
+
+	*v = 0;
+	if (!range) {
+		*v = min;
+		return TRUE;
+	}
+
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+
+
+	if (BitStream_DecodeNonNegativeInteger(pBitStrm, &uv, nRangeBits))
+	{
+		*v = ((asn1SccSint)uv) + min;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+flag BitStream_DecodeConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min, asn1SccUint max)
+{
+	asn1SccUint uv;
+	int nRangeBits;
+	asn1SccUint range = max - min;
+
+	i3ds_asn1_ASSERT_OR_RETURN_FALSE(min <= max);
+
+
+	*v = 0;
+	if (!range) {
+		*v = min;
+		return TRUE;
+	}
+
+	nRangeBits = GetNumberOfBitsForNonNegativeInteger(range);
+
+	if (BitStream_DecodeNonNegativeInteger(pBitStrm, &uv, nRangeBits))
+	{
+		*v = uv + min;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+
+void BitStream_EncodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v, asn1SccSint min)
+{
+	int nBytes;
+	assert(v >= min);
+	nBytes = GetLengthInBytesOfUInt((asn1SccUint)(v - min));
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, nBytes, 0, 255); /*8 bits, first bit is always 0*/
+																	 /* put required zeros*/
+	BitStream_AppendNBitZero(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(v - min)));
+	/*Encode number */
+	BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)(v - min));
+}
+
+void BitStream_EncodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint v, asn1SccUint min)
+{
+	int nBytes;
+	assert(v >= min);
+	nBytes = GetLengthInBytesOfUInt(v - min);
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, nBytes, 0, 255); /*8 bits, first bit is always 0*/
+																	 /* put required zeros*/
+	BitStream_AppendNBitZero(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger(v - min));
+	/*Encode number */
+	BitStream_EncodeNonNegativeInteger(pBitStrm, (v - min));
+}
+
+
+flag BitStream_DecodeSemiConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v, asn1SccSint min)
+{
+	asn1SccSint nBytes;
+	int i;
+	*v = 0;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nBytes, 0, 255))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		*v = (*v << 8) | b;
+	}
+	*v += min;
+	return TRUE;
+}
+
+flag BitStream_DecodeSemiConstraintPosWholeNumber(BitStream* pBitStrm, asn1SccUint* v, asn1SccUint min)
+{
+	asn1SccSint nBytes;
+	int i;
+	*v = 0;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nBytes, 0, 255))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		*v = (*v << 8) | b;
+	}
+	*v += min;
+	return TRUE;
+}
+
+
+void BitStream_EncodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint v)
+{
+	int nBytes = GetLengthInBytesOfSInt(v);
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, nBytes, 0, 255); /*8 bits, first bit is always 0*/
+
+	if (v >= 0) {
+		BitStream_AppendNBitZero(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)v));
+		BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)(v));
+	}
+	else {
+		BitStream_AppendNBitOne(pBitStrm, nBytes * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(-v - 1)));
+		BitStream_EncodeNonNegativeIntegerNeg(pBitStrm, (asn1SccUint)(-v - 1), 1);
+	}
+}
+
+flag BitStream_DecodeUnConstraintWholeNumber(BitStream* pBitStrm, asn1SccSint* v)
+{
+	asn1SccSint nBytes;
+	int i;
+	flag valIsNegative = FALSE;
+	*v = 0;
+
+
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nBytes, 0, 255))
+		return FALSE;
+
+
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (!i) {
+			valIsNegative = b>0x7F;
+			if (valIsNegative)
+				*v = -1;
+		}
+		*v = (*v << 8) | b;
+	}
+	return TRUE;
+}
+
+
+
+#ifndef INFINITY
+#ifdef __GNUC__
+#define INFINITY (__builtin_inf())
+#endif
+#endif
+
+/*
+Bynary encoding will be used
+REAL = M*B^E
+where
+M = S*N*2^F
+
+ENCODING is done within three parts
+part 1 is 1 byte header
+part 2 is 1 or more byte for exponent
+part 3 is 3 or more byte for mantissa (N)
+
+First byte
+S :0-->+, S:1-->-1
+Base will be always be 2 (implied by 6th and 5th bit which are zero)
+ab: F  (0..3)
+cd:00 --> 1 byte for exponent as 2's complement
+cd:01 --> 2 byte for exponent as 2's complement
+cd:10 --> 3 byte for exponent as 2's complement
+cd:11 --> 1 byte for encoding the length of the exponent, then the expoent
+
+8 7 6 5 4 3 2 1
++-+-+-+-+-+-+-+-+
+|1|S|0|0|a|b|c|d|
++-+-+-+-+-+-+-+-+
+*/
+
+#if FP_i3ds_asn1_WORD_SIZE==8
+
+#define ExpoBitMask  0x7FF0000000000000ULL
+#define MantBitMask  0x000FFFFFFFFFFFFFULL
+#define MantBitMask2 0xFFE0000000000000ULL
+#define MantisaExtraBit 0x0010000000000000ULL
+#else				
+
+#define ExpoBitMask  0x7F800000U
+#define MantBitMask  0x007FFFFFU
+#define MantBitMask2 0xF0000000U
+#define MantisaExtraBit 0x00800000U
+
+#endif
+
+
+void CalculateMantissaAndExponent(asn1Real d, int* exponent, asn1SccUint64* mantissa)
+{
+
+#if FP_i3ds_asn1_WORD_SIZE==8
+	union {
+		asn1Real in;
+		asn1SccUint64 out;
+	} double2uint;
+	asn1SccUint64 ll = 0;
+#else
+	union {
+		asn1Real in;
+		asn1SccUint32 out;
+	} double2uint;
+	asn1SccUint32 ll = 0;
+#endif
+
+	double2uint.in = d;
+	ll = double2uint.out;
+
+	*exponent = 0;
+	*mantissa = 0;
+
+#if FP_i3ds_asn1_WORD_SIZE==8
+	* exponent = (int)(((ll & ExpoBitMask) >> 52) - 1023 - 52);
+	*mantissa = ll & MantBitMask;
+	(*mantissa) |= MantisaExtraBit;
+#else
+	*exponent = (int)(((ll & ExpoBitMask) >> 23) - 127 - 23);
+
+	*mantissa = ll & MantBitMask;
+	(*mantissa) |= MantisaExtraBit;
+#endif
+}
+
+asn1Real GetDoubleByMantissaAndExp(asn1SccUint mantissa, int exponent)
+{
+	asn1Real ret = 1.0;
+	if (mantissa == 0)
+		return 0.0;
+
+	if (exponent >= 0) {
+		while (exponent) {
+			ret = ret * 2.0;
+			exponent--;
+		}
+		return (asn1Real)mantissa*ret;
+	}
+	else {
+		exponent = -exponent;
+		while (exponent) {
+			ret = ret * 2.0;
+			exponent--;
+		}
+		return ((asn1Real)mantissa) / ret;
+	}
+}
+
+
+
+
+void BitStream_EncodeReal(BitStream* pBitStrm, asn1Real v)
+{
+	byte header = 0x80;
+	int nExpLen;
+	int nManLen;
+	int exponent;
+	asn1SccUint64 mantissa;
+
+
+	if (v == 0.0)
+	{
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0xFF);
+		return;
+	}
+
+	if (v == INFINITY)
+	{
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 0xFF);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0x40, 0, 0xFF);
+		return;
+	}
+
+	if (v == -INFINITY)
+	{
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 0xFF);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0x41, 0, 0xFF);
+		return;
+	}
+	if (v < 0) {
+		header |= 0x40;
+		v = -v;
+	}
+
+	CalculateMantissaAndExponent(v, &exponent, &mantissa);
+	nExpLen = GetLengthInBytesOfSInt(exponent);
+	nManLen = GetLengthInBytesOfUInt(mantissa);
+	assert(nExpLen <= 3);
+	if (nExpLen == 2)
+		header |= 1;
+	else if (nExpLen == 3)
+		header |= 2;
+
+
+	/* encode length */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1 + nExpLen + nManLen, 0, 0xFF);
+
+	/* encode header */
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, header, 0, 0xFF);
+
+	/* encode exponent */
+	if (exponent >= 0) {
+		BitStream_AppendNBitZero(pBitStrm, nExpLen * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)exponent));
+		BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)exponent);
+	}
+	else {
+		BitStream_AppendNBitOne(pBitStrm, nExpLen * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(-exponent - 1)));
+		BitStream_EncodeNonNegativeIntegerNeg(pBitStrm, (asn1SccUint)(-exponent - 1), 1);
+	}
+
+
+	/* encode mantissa */
+	BitStream_AppendNBitZero(pBitStrm, nManLen * 8 - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(mantissa)));
+	BitStream_EncodeNonNegativeInteger(pBitStrm, mantissa);
+
+}
+
+flag DecodeRealAsBinaryEncoding(BitStream* pBitStrm, int length, byte header, asn1Real* v);
+
+flag BitStream_DecodeReal(BitStream* pBitStrm, asn1Real* v)
+{
+	byte header;
+	byte length;
+
+	if (!BitStream_ReadByte(pBitStrm, &length))
+		return FALSE;
+	if (length == 0)
+	{
+		*v = 0.0;
+		return TRUE;
+	}
+
+	if (!BitStream_ReadByte(pBitStrm, &header))
+		return FALSE;
+
+	if (header == 0x40)
+	{
+		*v = INFINITY;
+		return TRUE;
+	}
+
+	if (header == 0x41)
+	{
+		*v = -INFINITY;
+		return TRUE;
+	}
+
+	return DecodeRealAsBinaryEncoding(pBitStrm, length - 1, header, v);
+}
+
+
+flag DecodeRealAsBinaryEncoding(BitStream* pBitStrm, int length, byte header, asn1Real* v)
+{
+	int sign = 1;
+	/*int base=2;*/
+	int F;
+	unsigned factor = 1;
+	int expLen;
+	int exponent = 0;
+	int expFactor = 1;
+	asn1SccUint N = 0;
+	int i;
+
+	if (header & 0x40)
+		sign = -1;
+	if (header & 0x10) {
+		/*base = 8;*/
+		expFactor = 3;
+	}
+	else if (header & 0x20) {
+		/*base = 16;*/
+		expFactor = 4;
+	}
+
+	F = (header & 0x0C) >> 2;
+	factor <<= F;
+
+	expLen = (header & 0x03) + 1;
+
+	if (expLen>length)
+		return FALSE;
+
+	for (i = 0; i<expLen; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (!i) {
+			if (b>0x7F)
+				exponent = -1;
+		}
+		exponent = exponent << 8 | b;
+	}
+	length -= expLen;
+
+	for (i = 0; i<length; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		N = N << 8 | b;
+	}
+
+
+	/*  *v = N*factor * pow(base,exp);*/
+	*v = GetDoubleByMantissaAndExp(N*factor, expFactor*exponent);
+
+	if (sign<0)
+		*v = -(*v);
+
+
+	return TRUE;
+}
+
+asn1SccUint int2uint(asn1SccSint v) {
+    asn1SccUint ret = 0;
+    if (v < 0) {
+        ret = (asn1SccUint)(-v - 1);
+        ret = ~ret;
+    }
+    else {
+        ret = (asn1SccUint)v;
+    };
+    return ret;
+}
+
+asn1SccSint uint2int(asn1SccUint v, int uintSizeInBytes) {
+    int i;
+    asn1SccUint tmp = 0x80;
+    flag bIsNegative = (v & (tmp << ((uintSizeInBytes - 1) * 8)))>0;
+    if (!bIsNegative)
+        return (asn1SccSint)v;
+    for (i = i3ds_asn1_WORD_SIZE - 1; i >= uintSizeInBytes; i--)
+        v |= ber_aux[i];
+    return -(asn1SccSint)(~v) - 1;
+}
+
+
+} // namespace i3ds_asn1
+
diff --git a/generated/src/asn1crt_encoding_acn.cpp b/generated/src/asn1crt_encoding_acn.cpp
new file mode 100644
index 0000000..fe76aa2
--- /dev/null
+++ b/generated/src/asn1crt_encoding_acn.cpp
@@ -0,0 +1,1454 @@
+#include <string.h>
+#include <assert.h>
+
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+namespace i3ds_asn1 {
+
+static byte masks[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
+
+static flag RequiresReverse(void)
+{
+	short int word = 0x0001;
+	char *b = (char *)&word;
+	return b[0] == 1;
+}
+
+
+
+void Acn_AlignToNextByte(BitStream* pBitStrm)
+{
+	if (pBitStrm->currentBit != 0)
+	{
+		pBitStrm->currentBit = 0;
+		pBitStrm->currentByte++;
+
+		i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+	}
+}
+
+void Acn_AlignToNextWord(BitStream* pBitStrm)
+{
+	Acn_AlignToNextByte(pBitStrm);
+
+	pBitStrm->currentByte += pBitStrm->currentByte % 2;
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_AlignToNextDWord(BitStream* pBitStrm)
+{
+	Acn_AlignToNextByte(pBitStrm);
+
+	pBitStrm->currentByte += pBitStrm->currentByte % 4;
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+/*ACN Integer functions*/
+void Acn_Enc_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBits)
+{
+	int nBits = 0;
+	if (encodedSizeInBits == 0)
+		return;
+	/* Get number of bits*/
+	nBits = GetNumberOfBitsForNonNegativeInteger(intVal);
+	/* put required zeros*/
+	BitStream_AppendNBitZero(pBitStrm, encodedSizeInBits - nBits);
+	/*Encode number */
+	BitStream_EncodeNonNegativeInteger(pBitStrm, intVal);
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+void Acn_Enc_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	BitStream_AppendByte0(pBitStrm, (byte)intVal);
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+static void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(BitStream* pBitStrm,
+	asn1SccUint intVal,
+	int size)
+{
+	int i = 0;
+	asn1SccUint tmp = intVal;
+	asn1SccUint mask = 0xFF;
+	mask <<= (size - 1) * 8;
+
+	for (i = 0; i<size; i++) {
+		byte ByteToEncode = (byte)((tmp & mask) >> ((size - i - 1) * 8));
+		BitStream_AppendByte0(pBitStrm, ByteToEncode);
+		mask >>= 8;
+	}
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(pBitStrm, intVal, 2);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(pBitStrm, intVal, 4);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_B(pBitStrm, intVal, 8);
+}
+
+static void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(BitStream* pBitStrm,
+	asn1SccUint intVal,
+	int size)
+{
+	int i = 0;
+	asn1SccUint tmp = intVal;
+
+	for (i = 0; i<size; i++) {
+		byte ByteToEncode = (byte)tmp;
+		BitStream_AppendByte0(pBitStrm, ByteToEncode);
+		tmp >>= 8;
+	}
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, intVal, 2);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, intVal, 4);
+}
+
+void Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, intVal, 8);
+}
+
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBits)
+{
+	asn1SccUint tmp = 0;
+	if (BitStream_DecodeNonNegativeInteger(pBitStrm, &tmp, encodedSizeInBits))
+	{
+		*pIntVal = tmp;
+		return TRUE;
+	}
+	return FALSE;
+
+}
+
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_8(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte v = 0;
+	if (!BitStream_ReadByte(pBitStrm, &v))
+		return FALSE;
+	*pIntVal = v;
+	return TRUE;
+}
+
+static flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(BitStream* pBitStrm,
+	asn1SccUint* pIntVal,
+	int SizeInBytes)
+{
+	int i;
+	asn1SccUint ret = 0;
+
+	*pIntVal = 0;
+
+	for (i = 0; i<SizeInBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		ret <<= 8;
+		ret |= b;
+	}
+	*pIntVal = ret;
+	return TRUE;
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(pBitStrm, pIntVal, 2);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(pBitStrm, pIntVal, 4);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_N(pBitStrm, pIntVal, 8);
+}
+
+static flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(BitStream* pBitStrm,
+	asn1SccUint* pIntVal,
+	int SizeInBytes)
+{
+	int i;
+	asn1SccUint ret = 0;
+	asn1SccUint tmp = 0;
+
+	*pIntVal = 0;
+
+	for (i = 0; i<SizeInBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		tmp = b;
+		tmp <<= i * 8;
+		ret |= tmp;
+	}
+	*pIntVal = ret;
+	return TRUE;
+
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, pIntVal, 2);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, pIntVal, 4);
+}
+
+flag Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_N(pBitStrm, pIntVal, 8);
+}
+
+
+
+
+static void Encode_UnsignedInteger(BitStream* pBitStrm, asn1SccUint val, byte nBytes)
+{
+#if i3ds_asn1_WORD_SIZE==8
+#define MAX_BYTE_MASK 0xFF00000000000000LL
+#else
+#define MAX_BYTE_MASK 0xFF000000
+#endif
+	int i = 0;
+	assert(nBytes <= 8);
+	val <<= (sizeof(asn1SccUint) * 8U - nBytes * 8U);
+	for (i = 0; i<nBytes; i++) {
+		byte ByteToEncode = (byte)((val & MAX_BYTE_MASK) >> ((sizeof(asn1SccUint) - 1) * 8));
+		BitStream_AppendByte0(pBitStrm, ByteToEncode);
+		val <<= 8;
+	}
+}
+
+
+int GetLengthInBytesOfUInt(asn1SccUint64 v);
+
+
+void Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	asn1SccUint val = intVal;
+	byte nBytes = (byte)GetLengthInBytesOfUInt(val);
+
+
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, nBytes);
+	/* Encode integer data*/
+	Encode_UnsignedInteger(pBitStrm, val, nBytes);
+
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+flag Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte nBytes;
+	int i;
+	asn1SccUint v = 0;
+	if (!BitStream_ReadByte(pBitStrm, &nBytes))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		v = (v << 8) | b;
+	}
+	*pIntVal = v;
+	return TRUE;
+}
+
+
+void Acn_Enc_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBits)
+{
+	if (intVal >= 0) {
+		BitStream_AppendNBitZero(pBitStrm, encodedSizeInBits - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)intVal));
+		BitStream_EncodeNonNegativeInteger(pBitStrm, (asn1SccUint)intVal);
+	}
+	else {
+		BitStream_AppendNBitOne(pBitStrm, encodedSizeInBits - GetNumberOfBitsForNonNegativeInteger((asn1SccUint)(-intVal - 1)));
+		BitStream_EncodeNonNegativeIntegerNeg(pBitStrm, (asn1SccUint)(-intVal - 1), 1);
+	}
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+
+
+
+void Acn_Enc_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_8(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, int2uint(intVal));
+}
+
+void Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(pBitStrm, int2uint(intVal));
+}
+
+
+
+
+flag Acn_Dec_Int_TwosComplement_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBits)
+{
+	int i;
+	flag valIsNegative = FALSE;
+	int nBytes = encodedSizeInBits / 8;
+	int rstBits = encodedSizeInBits % 8;
+	byte b = 0;
+
+	*pIntVal = 0;
+
+
+	for (i = 0; i<nBytes; i++) {
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (i == 0) {
+			valIsNegative = b>0x7F;
+			if (valIsNegative)
+				*pIntVal = -1;
+		}
+		*pIntVal = (*pIntVal << 8) | b;
+	}
+
+	if (rstBits>0)
+	{
+		if (!BitStream_ReadPartialByte(pBitStrm, &b, (byte)rstBits))
+			return FALSE;
+		if (nBytes == 0)
+		{
+			valIsNegative = b & masks[8 - rstBits];
+			if (valIsNegative)
+				*pIntVal = -1;
+		}
+		*pIntVal = (*pIntVal << rstBits) | b;
+	}
+
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_8(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_8(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 1);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 2);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 4);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 8);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 2);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 4);
+	return TRUE;
+}
+
+flag Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	asn1SccUint tmp = 0;
+	if (!Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(pBitStrm, &tmp))
+		return FALSE;
+	*pIntVal = uint2int(tmp, 8);
+	return TRUE;
+}
+
+
+
+
+static asn1SccUint To_UInt(asn1SccSint intVal) {
+	asn1SccUint ret = 0;
+	if (intVal <0) {
+		ret = (asn1SccUint)(-intVal - 1);
+		ret = ~ret;
+	}
+	else {
+		ret = (asn1SccUint)intVal;
+	}
+	return ret;
+}
+
+
+int GetLengthInBytesOfSInt(asn1SccSint v);
+
+
+void Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal)
+{
+
+	byte nBytes = (byte)GetLengthInBytesOfSInt(intVal);
+
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, nBytes);
+	/* Encode integer data*/
+	Encode_UnsignedInteger(pBitStrm, To_UInt(intVal), nBytes);
+
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+
+flag Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+
+#if i3ds_asn1_WORD_SIZE==8
+#define MAX_INT 0xFFFFFFFFFFFFFFFFULL
+#else
+#define MAX_INT 0xFFFFFFFF
+#endif
+
+	byte nBytes;
+	int i;
+	asn1SccUint v = 0;
+	flag isNegative = 0;
+	if (!BitStream_ReadByte(pBitStrm, &nBytes))
+		return FALSE;
+	for (i = 0; i<nBytes; i++) {
+		byte b = 0;
+		if (!BitStream_ReadByte(pBitStrm, &b))
+			return FALSE;
+		if (i == 0 && (b & 0x80)>0) {
+			v = MAX_INT;
+			isNegative = 1;
+		}
+
+		v = (v << 8) | b;
+	}
+	if (isNegative) {
+		*pIntVal = -((asn1SccSint)(~v)) - 1;
+	}
+	else {
+		*pIntVal = (asn1SccSint)v;
+	}
+	return TRUE;
+
+}
+
+
+//return values is in nibbles
+static int Acn_Get_Int_Size_BCD(asn1SccUint intVal)
+{
+	int ret = 0;
+	while (intVal>0)
+	{
+		intVal /= 10;
+		ret++;
+	}
+	return ret;
+}
+
+
+
+
+void Acn_Enc_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInNibbles)
+{
+	int i = 0;
+	int totalNibbles = 0;
+	char tmp[100];
+
+	memset(tmp, 0x0, sizeof(tmp));
+
+	assert(100 >= encodedSizeInNibbles);
+
+	while (intVal>0) {
+		tmp[totalNibbles++] = (char)(intVal % 10);
+		intVal /= 10;
+	}
+	assert(encodedSizeInNibbles >= totalNibbles);
+
+	for (i = encodedSizeInNibbles - 1; i >= 0; i--) {
+		BitStream_AppendPartialByte(pBitStrm, (byte)tmp[i], 4, 0);
+	}
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+
+
+flag Acn_Dec_Int_BCD_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInNibbles)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+
+
+	while (encodedSizeInNibbles>0)
+	{
+		if (!BitStream_ReadPartialByte(pBitStrm, &digit, 4))
+			return FALSE;
+
+		ret *= 10;
+		ret += digit;
+
+		encodedSizeInNibbles--;
+	}
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+
+void Acn_Enc_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	int nNibbles = Acn_Get_Int_Size_BCD(intVal);
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, (byte)nNibbles);
+
+
+	/* Encode Number */
+	Acn_Enc_Int_BCD_ConstSize(pBitStrm, intVal, nNibbles);
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+flag Acn_Dec_Int_BCD_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte nNibbles = 0;
+	if (BitStream_ReadByte(pBitStrm, &nNibbles))
+		return Acn_Dec_Int_BCD_ConstSize(pBitStrm, pIntVal, nNibbles);
+
+	return FALSE;
+
+}
+
+
+
+//encoding puts an 'F' at the end
+void Acn_Enc_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal)
+{
+
+	int nNibbles = Acn_Get_Int_Size_BCD(intVal);
+
+	/* Encode Number */
+	Acn_Enc_Int_BCD_ConstSize(pBitStrm, intVal, nNibbles);
+
+	BitStream_AppendPartialByte(pBitStrm, 0xF, 4, 0);
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+flag Acn_Dec_Int_BCD_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+
+	for (;;)
+	{
+		if (!BitStream_ReadPartialByte(pBitStrm, &digit, 4))
+			return FALSE;
+		if (digit>9)
+			break;
+
+		ret *= 10;
+		ret += digit;
+
+	}
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+
+void Acn_Enc_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint intVal, int encodedSizeInBytes)
+{
+	int i = 0;
+	int totalNibbles = 0;
+	char tmp[100];
+
+	memset(tmp, 0x0, sizeof(tmp));
+
+	assert(100 >= encodedSizeInBytes);
+
+	while (intVal>0) {
+		tmp[totalNibbles++] = (char)(intVal % 10);
+		intVal /= 10;
+	}
+	assert(encodedSizeInBytes >= totalNibbles);
+
+	for (i = encodedSizeInBytes - 1; i >= 0; i--) {
+		BitStream_AppendByte0(pBitStrm, (byte)(tmp[i] + '0'));
+	}
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+
+void Acn_Enc_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint intVal, int encodedSizeInBytes)
+{
+	asn1SccUint absIntVal = intVal >= 0 ? (asn1SccUint)intVal : (asn1SccUint)(-intVal);
+
+	/* encode sign */
+	BitStream_AppendByte0(pBitStrm, intVal >= 0 ? '+' : '-');
+	encodedSizeInBytes--;
+
+
+
+	Acn_Enc_UInt_ASCII_ConstSize(pBitStrm, absIntVal, encodedSizeInBytes);
+
+}
+
+flag Acn_Dec_UInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccUint* pIntVal, int encodedSizeInBytes)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+
+	while (encodedSizeInBytes>0)
+	{
+		if (!BitStream_ReadByte(pBitStrm, &digit))
+			return FALSE;
+		i3ds_asn1_ASSERT_OR_RETURN_FALSE(digit >= '0' && digit <= '9');
+		digit = (byte)((int)digit - '0');
+
+		ret *= 10;
+		ret += digit;
+
+		encodedSizeInBytes--;
+	}
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+flag Acn_Dec_SInt_ASCII_ConstSize(BitStream* pBitStrm, asn1SccSint* pIntVal, int encodedSizeInBytes)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+	int sign = 1;
+
+	if (!BitStream_ReadByte(pBitStrm, &digit))
+		return FALSE;
+	if (digit == '+')
+		sign = 1;
+	else if (digit == '-')
+		sign = -1;
+	else {
+		i3ds_asn1_ASSERT_OR_RETURN_FALSE(0);
+	}
+	encodedSizeInBytes--;
+
+
+	if (!Acn_Dec_UInt_ASCII_ConstSize(pBitStrm, &ret, encodedSizeInBytes)) {
+		return false;
+	}
+
+	*pIntVal = (asn1SccSint)ret;
+
+	*pIntVal = sign*(*pIntVal);
+	return TRUE;
+
+}
+
+
+
+void getIntegerDigits(asn1SccUint intVal, byte digitsArray100[], byte* totalDigits) {
+	int i = 0;
+	*totalDigits = 0;
+	byte reversedDigitsArray[100];
+	memset(reversedDigitsArray, 0x0, 100);
+	memset(digitsArray100, 0x0, 100);
+	if (intVal > 0) {
+		while (intVal > 0 && *totalDigits < 100) {
+			reversedDigitsArray[*totalDigits] = '0' + (byte)(intVal % 10);
+			(*totalDigits)++;
+			intVal /= 10;
+		}
+		for (i = *totalDigits - 1; i >= 0; i--) {
+			digitsArray100[(*totalDigits - 1) - i] = reversedDigitsArray[i];
+		}
+	}
+	else {
+		digitsArray100[0] = '0';
+		*totalDigits = 1;
+	}
+}
+
+
+void Acn_Enc_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint intVal)
+{
+	byte digitsArray100[100];
+	int i = 0;
+	byte nChars;
+	asn1SccUint absIntVal = intVal >= 0 ? (asn1SccUint)intVal : (asn1SccUint)(-intVal);
+	getIntegerDigits(absIntVal, digitsArray100, &nChars);
+
+	/* encode length, plus 1 for sign */
+	BitStream_AppendByte0(pBitStrm, nChars + 1);
+
+	/* encode sign */
+	BitStream_AppendByte0(pBitStrm, intVal >= 0 ? '+' : '-');
+
+	/* encode digits */
+	while (digitsArray100[i] != 0x0 && i<100) {
+		BitStream_AppendByte0(pBitStrm, digitsArray100[i]);
+		i++;
+	}
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+void Acn_Enc_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint intVal)
+{
+	byte digitsArray100[100];
+	int i = 0;
+	byte nChars;
+	getIntegerDigits(intVal, digitsArray100, &nChars);
+
+	/* encode length */
+	BitStream_AppendByte0(pBitStrm, nChars);
+	/* encode digits */
+	while (digitsArray100[i] != 0x0 && i<100) {
+		BitStream_AppendByte0(pBitStrm, digitsArray100[i]);
+		i++;
+	}
+
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+
+}
+
+
+flag Acn_Dec_UInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccUint* pIntVal)
+{
+	byte nChars = 0;
+	if (BitStream_ReadByte(pBitStrm, &nChars))
+		return Acn_Dec_UInt_ASCII_ConstSize(pBitStrm, pIntVal, nChars);
+
+	return FALSE;
+}
+
+flag Acn_Dec_SInt_ASCII_VarSize_LengthEmbedded(BitStream* pBitStrm, asn1SccSint* pIntVal)
+{
+	byte nChars = 0;
+	if (BitStream_ReadByte(pBitStrm, &nChars))
+		return Acn_Dec_SInt_ASCII_ConstSize(pBitStrm, pIntVal, nChars);
+
+	return FALSE;
+}
+
+
+
+void Acn_Enc_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint intVal, const byte null_characters[], size_t null_characters_size)
+{
+	byte digitsArray100[100];
+	byte nChars;
+	size_t i = 0;
+	getIntegerDigits(intVal, digitsArray100, &nChars);
+	while (digitsArray100[i] != 0x0 && i<100) {
+		BitStream_AppendByte0(pBitStrm, digitsArray100[i]);
+		i++;
+	}
+	for (i = 0; i<null_characters_size; i++)
+		BitStream_AppendByte0(pBitStrm, null_characters[i]);
+	i3ds_asn1_CHECK_BIT_STREAM(pBitStrm);
+}
+
+void Acn_Enc_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint intVal, const byte null_characters[], size_t null_characters_size)
+{
+	asn1SccUint absValue = intVal >= 0 ? (asn1SccUint)intVal : (asn1SccUint)(-intVal);
+	BitStream_AppendByte0(pBitStrm, intVal >= 0 ? '+' : '-');
+
+	Acn_Enc_UInt_ASCII_VarSize_NullTerminated(pBitStrm, absValue, null_characters, null_characters_size);
+}
+
+/*
+flag Acn_Dec_String_Ascii_Null_Teminated_mult(BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size,   char* strVal)
+{
+byte tmp[10];
+size_t sz = null_character_size < 10 ? null_character_size : 10;
+memset(tmp, 0x0, 10);
+memset(strVal, 0x0, (size_t)max + 1);
+//read null_character_size characters into the tmp buffer
+for (int j = 0; j < (int)null_character_size; j++) {
+if (!BitStream_ReadByte(pBitStrm, &(tmp[j])))
+return FALSE;
+}
+
+asn1SccSint i = 0;
+while (i <= max && (memcmp(null_character, tmp, sz) != 0)) {
+strVal[i] = tmp[0];
+i++;
+for (int j = 0; j < (int)null_character_size - 1; j++)
+tmp[j] = tmp[j + 1];
+if (!BitStream_ReadByte(pBitStrm, &(tmp[null_character_size - 1])))
+return FALSE;
+}
+
+strVal[i] = 0x0;
+return memcmp(null_character, tmp, sz) == 0;
+
+}
+
+
+*/
+
+flag Acn_Dec_UInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccUint* pIntVal, const byte null_characters[], size_t null_characters_size)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+	byte tmp[10];
+	size_t sz = null_characters_size < 10 ? null_characters_size : 10;
+	memset(tmp, 0x0, 10);
+	asn1SccSint i = 0;
+
+	//read null_character_size characters into the tmp buffer
+	for (int j = 0; j < (int)null_characters_size; j++) {
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[j])))
+			return FALSE;
+	}
+
+	while (memcmp(null_characters, tmp, sz) != 0) {
+		digit = tmp[0];
+		i++;
+		for (int j = 0; j < (int)null_characters_size - 1; j++)
+			tmp[j] = tmp[j + 1];
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[null_characters_size - 1])))
+			return FALSE;
+
+		digit = (byte)((int)digit - '0');
+
+		ret *= 10;
+		ret += digit;
+	}
+
+	*pIntVal = ret;
+
+	return TRUE;
+}
+
+
+flag Acn_Dec_SInt_ASCII_VarSize_NullTerminated(BitStream* pBitStrm, asn1SccSint* pIntVal, const byte null_characters[], size_t null_characters_size)
+{
+	byte digit;
+	asn1SccUint ret = 0;
+	flag isNegative = FALSE;
+
+	if (!BitStream_ReadByte(pBitStrm, &digit))
+		return FALSE;
+	i3ds_asn1_ASSERT_OR_RETURN_FALSE(digit == '-' || digit == '+');
+	if (digit == '-')
+		isNegative = TRUE;
+
+	if (!Acn_Dec_UInt_ASCII_VarSize_NullTerminated(pBitStrm, &ret, null_characters, null_characters_size))
+		return false;
+
+	*pIntVal = (asn1SccSint)ret;
+	if (isNegative)
+		*pIntVal = -(*pIntVal);
+	return TRUE;
+}
+
+
+
+
+
+/* Boolean Decode */
+
+flag BitStream_ReadBitPattern(BitStream* pBitStrm, const byte* patternToRead, int nBitsToRead, flag* pBoolValue)
+{
+	int nBytesToRead = nBitsToRead / 8;
+	int nRemainingBitsToRead = nBitsToRead % 8;
+	byte curByte;
+	int i = 0;
+
+	*pBoolValue = TRUE;
+	for (i = 0; i<nBytesToRead; i++) {
+		if (!BitStream_ReadByte(pBitStrm, &curByte))
+			return FALSE;
+		if (curByte != patternToRead[i])
+			*pBoolValue = FALSE;
+	}
+
+	if (nRemainingBitsToRead > 0) {
+		if (!BitStream_ReadPartialByte(pBitStrm, &curByte, (byte)nRemainingBitsToRead))
+			return FALSE;
+		if (curByte != patternToRead[nBytesToRead] >> (8 - nRemainingBitsToRead))
+			*pBoolValue = FALSE;
+	}
+
+	return TRUE;
+}
+
+/*Real encoding functions*/
+typedef union _float_tag
+{
+	float f;
+	byte b[sizeof(float)];
+} _float;
+
+typedef union _double_tag
+{
+	double f;
+	byte b[sizeof(double)];
+} _double;
+
+
+#define Acn_enc_real_big_endian(type)       \
+    int i;                      \
+    _##type dat1;               \
+    dat1.f = (type)realValue;   \
+    if (!RequiresReverse()) {   \
+        for(i=0;i<(int)sizeof(dat1);i++)        \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    } else {    \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--)   \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    }   \
+
+
+#define Acn_dec_real_big_endian(type)   \
+    int i;                  \
+    _##type dat1;           \
+    dat1.f=0.0;             \
+    if (!RequiresReverse()) {       \
+        for(i=0;i<(int)sizeof(dat1);i++) {  \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))  \
+                return FALSE;       \
+        }                           \
+    } else {                        \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--) {         \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))      \
+                return FALSE;           \
+        }       \
+    }       \
+    *pRealValue = dat1.f;   \
+    return TRUE;            \
+
+
+void Acn_Enc_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_big_endian(float)
+}
+
+flag Acn_Dec_Real_IEEE754_32_big_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_big_endian(float)
+}
+
+void Acn_Enc_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_big_endian(double)
+}
+
+flag Acn_Dec_Real_IEEE754_64_big_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_big_endian(double)
+}
+
+
+
+
+#define Acn_enc_real_little_endian(type)        \
+    int i;                      \
+    _##type dat1;               \
+    dat1.f = (type)realValue;   \
+    if (RequiresReverse()) {    \
+        for(i=0;i<(int)sizeof(dat1);i++)        \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    } else {    \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--)   \
+            BitStream_AppendByte0(pBitStrm,dat1.b[i]);  \
+    }   \
+
+
+#define Acn_dec_real_little_endian(type)    \
+    int i;                  \
+    _##type dat1;           \
+    dat1.f=0.0;             \
+    if (RequiresReverse()) {        \
+        for(i=0;i<(int)sizeof(dat1);i++) {  \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))  \
+                return FALSE;       \
+        }                           \
+    } else {                        \
+        for(i=(int)(sizeof(dat1)-1);i>=0;i--) {         \
+            if (!BitStream_ReadByte(pBitStrm, &dat1.b[i]))      \
+                return FALSE;           \
+        }       \
+    }       \
+    *pRealValue = dat1.f;   \
+    return TRUE;            \
+
+
+void Acn_Enc_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_little_endian(float)
+}
+
+flag Acn_Dec_Real_IEEE754_32_little_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_little_endian(float)
+}
+
+void Acn_Enc_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real realValue)
+{
+	Acn_enc_real_little_endian(double)
+}
+
+flag Acn_Dec_Real_IEEE754_64_little_endian(BitStream* pBitStrm, asn1Real* pRealValue)
+{
+	Acn_dec_real_little_endian(double)
+}
+
+
+
+
+/* String functions*/
+void Acn_Enc_String_Ascii_FixSize(BitStream* pBitStrm, asn1SccSint max, const char* strVal)
+{
+	asn1SccSint i = 0;
+	while (i<max) {
+		BitStream_AppendByte(pBitStrm, strVal[i], FALSE);
+		i++;
+	}
+}
+
+static asn1SccSint Acn_Enc_String_Ascii_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	const char* strVal)
+{
+	asn1SccSint i = 0;
+	while ((strVal[i] != '\0') && (i<max)) {
+		BitStream_AppendByte(pBitStrm, strVal[i], FALSE);
+		i++;
+	}
+	return i;
+}
+
+void Acn_Enc_String_Ascii_Null_Teminated(BitStream* pBitStrm, asn1SccSint max, char null_character, const char* strVal)
+{
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+	BitStream_AppendByte(pBitStrm, null_character, FALSE);
+}
+
+void Acn_Enc_String_Ascii_Null_Teminated_mult(BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, const char* strVal) {
+	size_t i = 0;
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+	for (i = 0; i<null_character_size; i++) {
+		BitStream_AppendByte(pBitStrm, null_character[i], FALSE);
+	}
+}
+
+
+void Acn_Enc_String_Ascii_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, const char* strVal)
+{
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+}
+
+void Acn_Enc_String_Ascii_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal)
+{
+	int strLen = strlen(strVal);
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, strLen <= max ? strLen : max, min, max);
+	Acn_Enc_String_Ascii_private(pBitStrm, max, strVal);
+}
+
+void Acn_Enc_String_CharIndex_FixSize(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal)
+{
+	asn1SccSint i = 0;
+	while (i<max) {
+		int charIndex = GetCharIndex(strVal[i], allowedCharSet, charSetSize);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, charSetSize - 1);
+		i++;
+	}
+}
+
+static asn1SccSint Acn_Enc_String_CharIndex_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	byte allowedCharSet[],
+	int charSetSize,
+	const char* strVal)
+{
+	asn1SccSint i = 0;
+	while ((strVal[i] != '\0') && (i<max)) {
+		int charIndex = GetCharIndex(strVal[i], allowedCharSet, charSetSize);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, charIndex, 0, charSetSize - 1);
+		i++;
+	}
+	return i;
+}
+
+
+void Acn_Enc_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, const char* strVal)
+{
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, charSetSize, strVal);
+}
+
+void Acn_Enc_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, const char* strVal)
+{
+	int strLen = strlen(strVal);
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, strLen <= max ? strLen : max, min, max);
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, charSetSize, strVal);
+}
+
+
+void Acn_Enc_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, const char* strVal)
+{
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, 128, strVal);
+}
+
+void Acn_Enc_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, const char* strVal)
+{
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+	int strLen = strlen(strVal);
+	BitStream_EncodeConstraintWholeNumber(pBitStrm, strLen <= max ? strLen : max, min, max);
+	Acn_Enc_String_CharIndex_private(pBitStrm, max, allowedCharSet, 128, strVal);
+}
+
+
+static flag Acn_Dec_String_Ascii_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	asn1SccSint charactersToDecode,
+	char* strVal)
+{
+	asn1SccSint i = 0;
+	byte decodedCharacter;
+	memset(strVal, 0x0, (size_t)max + 1);
+	while (i<charactersToDecode) {
+		if (!BitStream_ReadByte(pBitStrm, &decodedCharacter))
+			return FALSE;
+		strVal[i] = decodedCharacter;
+		i++;
+	}
+	return TRUE;
+}
+
+
+flag Acn_Dec_String_Ascii_FixSize(BitStream* pBitStrm, asn1SccSint max, char* strVal)
+{
+	return Acn_Dec_String_Ascii_private(pBitStrm, max, max, strVal);
+}
+
+/*
+int put_byte_in_last_dec_bytes(byte last_dec_bytes[], size_t* pCur_size, size_t null_characters_size, byte decodedCharacter, byte *pDiscardedCharacter) {
+int i;
+if (*pCur_size < null_characters_size) {
+last_dec_bytes[*pCur_size] = decodedCharacter;
+(*pCur_size)++;
+*pDiscardedCharacter = NULL;
+return 0;
+} else {
+*pDiscardedCharacter = last_dec_bytes[0];
+for (i = 1; i < null_characters_size; i++) {
+last_dec_bytes[i - 1] = last_dec_bytes[i];
+}
+last_dec_bytes[null_characters_size - 1] = decodedCharacter;
+return 1;
+}
+}
+
+flag Acn_Dec_String_Ascii_Null_Teminated(BitStream* pBitStrm, asn1SccSint max, const byte null_characters[], size_t null_characters_size, char* strVal)
+{
+asn1SccSint i = 0;
+byte decodedCharacter;
+byte characterToAppendInString;
+size_t cur_size_of_last_dec_bytes = 0;
+byte last_dec_bytes[128];
+int ret;
+
+assert(null_characters_size<128);
+memset(last_dec_bytes, 0x0, sizeof(last_dec_bytes));
+memset(strVal, 0x0, (size_t)max+1);
+while (i<=max) {
+if (!BitStream_ReadByte(pBitStrm, &decodedCharacter))
+return FALSE;
+ret = put_byte_in_last_dec_bytes(last_dec_bytes, &cur_size_of_last_dec_bytes, null_characters_size, decodedCharacter, &characterToAppendInString);
+
+
+//if (decodedCharacter == (byte)null_character) {
+if ((ret == 1) && (memcmp(last_dec_bytes,null_characters,null_characters_size) == 0)) {
+strVal[i] = 0x0;
+return TRUE;
+} else if (ret == 1) {
+strVal[i] = characterToAppendInString;
+i++;
+}
+}
+
+return FALSE;
+
+}
+
+*/
+
+
+flag Acn_Dec_String_Ascii_Null_Teminated(BitStream* pBitStrm, asn1SccSint max, char null_character, char* strVal)
+{
+	asn1SccSint i = 0;
+	byte decodedCharacter;
+	memset(strVal, 0x0, (size_t)max + 1);
+	while (i <= max) {
+		if (!BitStream_ReadByte(pBitStrm, &decodedCharacter))
+			return FALSE;
+		if (decodedCharacter != (byte)null_character) {
+			strVal[i] = decodedCharacter;
+			i++;
+		}
+		else {
+			strVal[i] = 0x0;
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+
+}
+
+flag Acn_Dec_String_Ascii_Null_Teminated_mult(BitStream* pBitStrm, asn1SccSint max, const byte null_character[], size_t null_character_size, char* strVal)
+{
+	byte tmp[10];
+	size_t sz = null_character_size < 10 ? null_character_size : 10;
+	memset(tmp, 0x0, 10);
+	memset(strVal, 0x0, (size_t)max + 1);
+	//read null_character_size characters into the tmp buffer
+	for (int j = 0; j < (int)null_character_size; j++) {
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[j])))
+			return FALSE;
+	}
+
+	asn1SccSint i = 0;
+	while (i <= max && (memcmp(null_character, tmp, sz) != 0)) {
+		strVal[i] = tmp[0];
+		i++;
+		for (int j = 0; j < (int)null_character_size - 1; j++)
+			tmp[j] = tmp[j + 1];
+		if (!BitStream_ReadByte(pBitStrm, &(tmp[null_character_size - 1])))
+			return FALSE;
+	}
+
+	strVal[i] = 0x0;
+	return memcmp(null_character, tmp, sz) == 0;
+
+}
+
+
+flag Acn_Dec_String_Ascii_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal)
+{
+	return Acn_Dec_String_Ascii_private(pBitStrm, max, extSizeDeterminatFld <= max ? extSizeDeterminatFld : max, strVal);
+}
+
+flag Acn_Dec_String_Ascii_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal)
+{
+	asn1SccSint nCount;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, min, max))
+		return FALSE;
+
+	return Acn_Dec_String_Ascii_private(pBitStrm, max, nCount <= max ? nCount : max, strVal);
+
+}
+
+static flag Acn_Dec_String_CharIndex_private(BitStream* pBitStrm,
+	asn1SccSint max,
+	asn1SccSint charactersToDecode,
+	byte allowedCharSet[],
+	int charSetSize,
+	char* strVal)
+{
+	asn1SccSint i = 0;
+	memset(strVal, 0x0, (size_t)max + 1);
+	while (i<charactersToDecode) {
+		asn1SccSint charIndex = 0;
+		if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &charIndex, 0, charSetSize - 1))
+			return FALSE;
+		strVal[i] = allowedCharSet[charIndex];
+		i++;
+	}
+	return TRUE;
+}
+
+
+flag Acn_Dec_String_CharIndex_FixSize(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, char* strVal)
+{
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, max, allowedCharSet, charSetSize, strVal);
+}
+
+flag Acn_Dec_String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint extSizeDeterminatFld, char* strVal)
+{
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, extSizeDeterminatFld <= max ? extSizeDeterminatFld : max, allowedCharSet, charSetSize, strVal);
+}
+
+flag Acn_Dec_String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, byte allowedCharSet[], int charSetSize, asn1SccSint min, char* strVal)
+{
+	asn1SccSint nCount;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, min, max))
+		return FALSE;
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, nCount <= max ? nCount : max, allowedCharSet, charSetSize, strVal);
+}
+
+
+
+
+flag Acn_Dec_IA5String_CharIndex_External_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint extSizeDeterminatFld, char* strVal)
+{
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, extSizeDeterminatFld <= max ? extSizeDeterminatFld : max, allowedCharSet, 128, strVal);
+}
+
+flag Acn_Dec_IA5String_CharIndex_Internal_Field_Determinant(BitStream* pBitStrm, asn1SccSint max, asn1SccSint min, char* strVal)
+{
+	asn1SccSint nCount;
+	static byte allowedCharSet[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
+		0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,
+		0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,
+		0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
+		0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,
+		0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,
+		0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,
+		0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
+		0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
+		0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x62,0x63,
+		0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,
+		0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
+		0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F };
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, min, max))
+		return FALSE;
+	return Acn_Dec_String_CharIndex_private(pBitStrm, max, nCount <= max ? nCount : max, allowedCharSet, 128, strVal);
+}
+
+
+
+
+
+
+/* Length Determinant functions*/
+void Acn_Enc_Length(BitStream* pBitStrm, asn1SccUint lengthValue, int lengthSizeInBits)
+{
+	/* encode length */
+	Acn_Enc_Int_PositiveInteger_ConstSize(pBitStrm, lengthValue, lengthSizeInBits);
+}
+
+flag Acn_Dec_Length(BitStream* pBitStrm, asn1SccUint* pLengthValue, int lengthSizeInBits)
+{
+	return Acn_Dec_Int_PositiveInteger_ConstSize(pBitStrm, pLengthValue, lengthSizeInBits);
+}
+
+asn1SccSint milbus_encode(asn1SccSint val)
+{
+	return val == 32 ? 0 : val;
+}
+
+asn1SccSint milbus_decode(asn1SccSint val)
+{
+	return val == 0 ? 32 : val;
+}
+
+} // namespace i3ds_asn1
+
diff --git a/generated/src/asn1crt_encoding_uper.cpp b/generated/src/asn1crt_encoding_uper.cpp
new file mode 100644
index 0000000..cc03cd7
--- /dev/null
+++ b/generated/src/asn1crt_encoding_uper.cpp
@@ -0,0 +1,163 @@
+#include <string.h>
+#include <assert.h>
+#include <math.h>
+#include <float.h>
+
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+namespace i3ds_asn1 {
+
+
+
+void ObjectIdentifier_subidentifiers_uper_encode(byte* encodingBuf, int* pSize, asn1SccUint siValue) {
+	flag lastOctet = FALSE;
+	byte tmp[16];
+	int nSize = 0;
+	int i;
+	while (!lastOctet)
+	{
+		byte curByte = siValue % 128;
+		siValue = siValue / 128;
+		lastOctet = (siValue == 0);
+		tmp[nSize] = curByte;
+		nSize++;
+	}
+	for (i = 0; i < nSize; i++) {
+		byte curByte = (i == nSize - 1) ? tmp[nSize - i - 1] : tmp[nSize - i - 1] | 0x80;
+
+		encodingBuf[*pSize] = curByte;
+		(*pSize)++;
+	}
+}
+
+
+void ObjectIdentifier_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal) {
+	//a subifentifier (i.e. a component) should not take more than size(asn1SccUint) + 2 to be encoded
+	//(the above statement is true for 8 byte integers. If we ever user larger integer then it should be adjusted)
+	byte tmp[i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH * (sizeof(asn1SccUint) + 2)];
+	int totalSize = 0;
+
+	int i = 0;
+	ObjectIdentifier_subidentifiers_uper_encode(tmp, &totalSize, pVal->values[0] * 40 + pVal->values[1]);
+	for (i = 2; i < pVal->nCount; i++) {
+		ObjectIdentifier_subidentifiers_uper_encode(tmp, &totalSize, pVal->values[i]);
+	}
+
+	if (totalSize <= 0x7F)
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0xFF);
+	else
+	{
+		BitStream_AppendBit(pBitStrm, 1);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0x7FFF);
+	}
+
+	for (i = 0; i < totalSize; i++) {
+		BitStream_AppendByte0(pBitStrm, tmp[i]);
+	}
+
+}
+
+void RelativeOID_uper_encode(BitStream* pBitStrm, const Asn1ObjectIdentifier *pVal) {
+	//a subifentifier (i.e. a component) should not take more than size(asn1SccUint) + 2 to be encoded
+	//(the above statement is true for 8 byte integers. If we ever user larger integer then it should be adjusted)
+	byte tmp[i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH * (sizeof(asn1SccUint) + 2)];
+	int totalSize = 0;
+	int i = 0;
+
+	for (i = 0; i < pVal->nCount; i++) {
+		ObjectIdentifier_subidentifiers_uper_encode(tmp, &totalSize, pVal->values[i]);
+	}
+
+
+	if (totalSize <= 0x7F)
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0xFF);
+	else
+	{
+		BitStream_AppendBit(pBitStrm, 1);
+		BitStream_EncodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0x7FFF);
+	}
+
+
+	for (i = 0; i < totalSize; i++) {
+		BitStream_AppendByte0(pBitStrm, tmp[i]);
+	}
+}
+
+flag ObjectIdentifier_subidentifiers_uper_decode(BitStream* pBitStrm, asn1SccSint* pRemainingOctets, asn1SccUint* siValue) {
+	byte curByte;
+	flag bLastOctet = FALSE;
+	asn1SccUint curOctetValue = 0;
+	*siValue = 0;
+	while (*pRemainingOctets > 0 && !bLastOctet)
+	{
+		curByte = 0;
+		if (!BitStream_ReadByte(pBitStrm, &curByte))
+			return FALSE;
+		(*pRemainingOctets)--;
+
+		bLastOctet = ((curByte & 0x80) == 0);
+		curOctetValue = curByte & 0x7F;
+		(*siValue) <<= 7;
+		(*siValue) |= curOctetValue;
+	}
+	return TRUE;
+}
+
+flag ObjectIdentifier_uper_decode_lentg(BitStream* pBitStrm, asn1SccSint* totalSize) {
+	asn1SccSint len2;
+	if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, totalSize, 0, 0xFF))
+		return FALSE;
+	if (*totalSize > 0x7F) {
+		if (!BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF))
+			return false;
+		(*totalSize) <<= 8;
+		(*totalSize) |= len2;
+		(*totalSize) &= 0x7FFF;
+	}
+	return true;
+}
+flag ObjectIdentifier_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal) {
+	asn1SccUint si;
+	asn1SccSint totalSize;
+	ObjectIdentifier_Init(pVal);
+
+
+	if (!ObjectIdentifier_uper_decode_lentg(pBitStrm, &totalSize))
+		return FALSE;
+
+	if (!ObjectIdentifier_subidentifiers_uper_decode(pBitStrm, &totalSize, &si))
+		return FALSE;
+	pVal->nCount = 2;
+	pVal->values[0] = si / 40;
+	pVal->values[1] = si % 40;
+	while (totalSize > 0 && pVal->nCount < i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH)
+	{
+		if (!ObjectIdentifier_subidentifiers_uper_decode(pBitStrm, &totalSize, &si))
+			return FALSE;
+
+		pVal->values[pVal->nCount] = si;
+		pVal->nCount++;
+	}
+	//return true, if totalSize reduced to zero. Otherwise we exit the loop because more components we present than i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH
+	return totalSize == 0;
+}
+
+flag RelativeOID_uper_decode(BitStream* pBitStrm, Asn1ObjectIdentifier *pVal) {
+	asn1SccUint si;
+	asn1SccSint totalSize;
+	ObjectIdentifier_Init(pVal);
+
+	if (!ObjectIdentifier_uper_decode_lentg(pBitStrm, &totalSize))
+		return FALSE;
+
+	while (totalSize > 0 && pVal->nCount < i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH)
+	{
+		if (!ObjectIdentifier_subidentifiers_uper_decode(pBitStrm, &totalSize, &si))
+			return FALSE;
+		pVal->values[pVal->nCount] = si;
+		pVal->nCount++;
+	}
+	//return true, if totalSize is zero. Otherwise we exit the loop because more components were present than i3ds_asn1_OBJECT_IDENTIFIER_MAX_LENGTH
+	return totalSize == 0;
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/base.cpp b/generated/src/base.cpp
new file mode 100644
index 0000000..fb12855
--- /dev/null
+++ b/generated/src/base.cpp
@@ -0,0 +1,11530 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/base.hpp>
+namespace i3ds_asn1 {
+
+
+
+void Base_Angle_Initialize(Base_Angle* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set rad */
+	T_Double_Initialize((&(pVal->rad)));
+}
+
+flag Base_Angle_IsConstraintValid(const Base_Angle* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->rad) && (pVal->rad <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_ANGLE_RAD;
+
+	return ret;
+}
+
+flag Base_Angle_Encode(const Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Angle_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode rad */
+	    ret = T_Double_Encode((&(pVal->rad)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Angle_Decode(Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode rad */
+	ret = T_Double_Decode((&(pVal->rad)), pBitStrm, pErrCode);
+
+	return ret  && Base_Angle_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_Motion2D_Initialize(Base_commands_Motion2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	T_Double_Initialize((&(pVal->translation)));
+	/*set rotation */
+	T_Double_Initialize((&(pVal->rotation)));
+	/*set heading */
+	Base_Angle_Initialize((&(pVal->heading)));
+}
+
+flag Base_commands_Motion2D_IsConstraintValid(const Base_commands_Motion2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D_TRANSLATION;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D_ROTATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_MOTION2D_HEADING_RAD;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_Motion2D_Encode(const Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rotation */
+	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heading */
+	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_Motion2D_Decode(Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rotation */
+	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heading */
+	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_PoseUpdateThreshold_Initialize(Base_PoseUpdateThreshold* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set distance */
+	T_Double_Initialize((&(pVal->distance)));
+	/*set angle */
+	T_Double_Initialize((&(pVal->angle)));
+}
+
+flag Base_PoseUpdateThreshold_IsConstraintValid(const Base_PoseUpdateThreshold* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->distance) && (pVal->distance <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSEUPDATETHRESHOLD_DISTANCE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSEUPDATETHRESHOLD_ANGLE;
+    }
+
+	return ret;
+}
+
+flag Base_PoseUpdateThreshold_Encode(const Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode distance */
+	    ret = T_Double_Encode((&(pVal->distance)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode angle */
+	        ret = T_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_PoseUpdateThreshold_Decode(Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode distance */
+	ret = T_Double_Decode((&(pVal->distance)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode angle */
+	    ret = T_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Temperature_Initialize(Base_Temperature* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set kelvin */
+	T_Double_Initialize((&(pVal->kelvin)));
+}
+
+flag Base_Temperature_IsConstraintValid(const Base_Temperature* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->kelvin) && (pVal->kelvin <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_TEMPERATURE_KELVIN;
+
+	return ret;
+}
+
+flag Base_Temperature_Encode(const Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Temperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode kelvin */
+	    ret = T_Double_Encode((&(pVal->kelvin)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Temperature_Decode(Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode kelvin */
+	ret = T_Double_Decode((&(pVal->kelvin)), pBitStrm, pErrCode);
+
+	return ret  && Base_Temperature_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_Speed6D_Initialize(Base_commands_Speed6D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set surge */
+	T_Double_Initialize((&(pVal->surge)));
+	/*set sway */
+	T_Double_Initialize((&(pVal->sway)));
+	/*set heave */
+	T_Double_Initialize((&(pVal->heave)));
+	/*set roll */
+	T_Double_Initialize((&(pVal->roll)));
+	/*set pitch */
+	T_Double_Initialize((&(pVal->pitch)));
+	/*set yaw */
+	T_Double_Initialize((&(pVal->yaw)));
+}
+
+flag Base_commands_Speed6D_IsConstraintValid(const Base_commands_Speed6D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->surge) && (pVal->surge <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_SURGE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->sway) && (pVal->sway <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_SWAY;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heave) && (pVal->heave <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_HEAVE;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->roll) && (pVal->roll <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_ROLL;
+                if (ret) {
+                    ret = ((-1.79769313486231570000E+308 <= pVal->pitch) && (pVal->pitch <= 1.79769313486231570000E+308));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_PITCH;
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->yaw) && (pVal->yaw <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_SPEED6D_YAW;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_Speed6D_Encode(const Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_commands_Speed6D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode surge */
+	    ret = T_Double_Encode((&(pVal->surge)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode sway */
+	        ret = T_Double_Encode((&(pVal->sway)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heave */
+	            ret = T_Double_Encode((&(pVal->heave)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode roll */
+	                ret = T_Double_Encode((&(pVal->roll)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode pitch */
+	                    ret = T_Double_Encode((&(pVal->pitch)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode yaw */
+	                        ret = T_Double_Encode((&(pVal->yaw)), pBitStrm, pErrCode, FALSE);
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_Speed6D_Decode(Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode surge */
+	ret = T_Double_Decode((&(pVal->surge)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode sway */
+	    ret = T_Double_Decode((&(pVal->sway)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heave */
+	        ret = T_Double_Decode((&(pVal->heave)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode roll */
+	            ret = T_Double_Decode((&(pVal->roll)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode pitch */
+	                ret = T_Double_Decode((&(pVal->pitch)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode yaw */
+	                    ret = T_Double_Decode((&(pVal->yaw)), pBitStrm, pErrCode);
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_commands_Speed6D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_AngleAxisd_axis_Initialize(Wrappers_AngleAxisd_axis* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 3) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_AngleAxisd_Initialize(Wrappers_AngleAxisd* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set angle */
+	T_Double_Initialize((&(pVal->angle)));
+	/*set axis */
+	Wrappers_AngleAxisd_axis_Initialize((&(pVal->axis)));
+}
+
+flag Wrappers_AngleAxisd_IsConstraintValid(const Wrappers_AngleAxisd* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_ANGLEAXISD_ANGLE;
+    if (ret) {
+        ret = ((1 <= pVal->axis.nCount) && (pVal->axis.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_ANGLEAXISD_AXIS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->axis.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->axis.arr[i1]) && (pVal->axis.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_ANGLEAXISD_AXIS_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_AngleAxisd_Encode(const Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode angle */
+	    ret = T_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode axis */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->axis.nCount, 1, 3);
+	        	
+	        for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++)
+	        {
+	        	ret = T_Double_Encode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_AngleAxisd_Decode(Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode angle */
+	ret = T_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode axis */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS;
+	    pVal->axis.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Decode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Wrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector2d_data_Initialize(Wrappers_Vector2d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 2) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector2d_Initialize(Wrappers_Vector2d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector2d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector2d_IsConstraintValid(const Wrappers_Vector2d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 2));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR2D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR2D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector2d_Encode(const Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 2);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector2d_Decode(Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector2d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose2D_Initialize(Base_Pose2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector2d_Initialize((&(pVal->position)));
+	/*set orientation */
+	T_Double_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose2D_IsConstraintValid(const Base_Pose2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_ORIENTATION;
+    }
+
+	return ret;
+}
+
+flag Base_Pose2D_Encode(const Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = T_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose2D_Decode(Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = T_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose2D_m_Initialize(Base_Pose2D_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector2d_Initialize((&(pVal->position)));
+	/*set orientation */
+	T_Double_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose2D_m_IsConstraintValid(const Base_Pose2D_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE2D_M_ORIENTATION;
+    }
+
+	return ret;
+}
+
+flag Base_Pose2D_m_Encode(const Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose2D_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = T_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose2D_m_Decode(Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = T_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose2D_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix2d_data_Initialize(Wrappers_Matrix2d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 4) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix2d_Initialize(Wrappers_Matrix2d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix2d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix2d_IsConstraintValid(const Wrappers_Matrix2d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX2D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX2D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix2d_Encode(const Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix2d_Decode(Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix2d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector3d_data_Initialize(Wrappers_Vector3d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 3) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector3d_Initialize(Wrappers_Vector3d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector3d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector3d_IsConstraintValid(const Wrappers_Vector3d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR3D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR3D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector3d_Encode(const Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 3);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector3d_Decode(Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector3d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Wrench_Initialize(Base_Wrench* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+}
+
+flag Base_Wrench_IsConstraintValid(const Base_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Wrench_Encode(const Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Wrench_Decode(Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Waypoint_Initialize(Base_Waypoint* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set heading */
+	T_Double_Initialize((&(pVal->heading)));
+	/*set tol_position */
+	T_Double_Initialize((&(pVal->tol_position)));
+	/*set tol_heading */
+	T_Double_Initialize((&(pVal->tol_heading)));
+}
+
+flag Base_Waypoint_IsConstraintValid(const Base_Waypoint* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_HEADING;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_TOL_POSITION;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_TOL_HEADING;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Waypoint_Encode(const Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode heading */
+	        ret = T_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode tol_position */
+	            ret = T_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode tol_heading */
+	                ret = T_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Waypoint_Decode(Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode heading */
+	    ret = T_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode tol_position */
+	        ret = T_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode tol_heading */
+	            ret = T_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_Waypoint_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Waypoint_m_Initialize(Base_Waypoint_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set heading */
+	T_Double_Initialize((&(pVal->heading)));
+	/*set tol_position */
+	T_Double_Initialize((&(pVal->tol_position)));
+	/*set tol_heading */
+	T_Double_Initialize((&(pVal->tol_heading)));
+}
+
+flag Base_Waypoint_m_IsConstraintValid(const Base_Waypoint_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_HEADING;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_TOL_POSITION;
+            if (ret) {
+                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WAYPOINT_M_TOL_HEADING;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Waypoint_m_Encode(const Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Waypoint_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode heading */
+	        ret = T_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode tol_position */
+	            ret = T_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode tol_heading */
+	                ret = T_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Waypoint_m_Decode(Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode heading */
+	    ret = T_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode tol_position */
+	        ret = T_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode tol_heading */
+	            ret = T_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_Waypoint_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Waypoint_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((1 <= pVal->arr[i1].position.data.nCount) && (pVal->arr[i1].position.data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->arr[i1].position.data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position.data.arr[i2]) && (pVal->arr[i1].position.data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA_ELM;
+        	    }
+        	}
+        	if (ret) {
+        	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].heading) && (pVal->arr[i1].heading <= 1.79769313486231570000E+308));
+        	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_HEADING;
+        	    if (ret) {
+        	        ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_position) && (pVal->arr[i1].tol_position <= 1.79769313486231570000E+308));
+        	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_POSITION;
+        	        if (ret) {
+        	            ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_heading) && (pVal->arr[i1].tol_heading <= 1.79769313486231570000E+308));
+        	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_HEADING;
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Encode(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_Waypoint_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Decode(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_Waypoint_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Wrench_m_Initialize(Base_Wrench_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+}
+
+flag Base_Wrench_m_IsConstraintValid(const Base_Wrench_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_WRENCH_M_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Wrench_m_Encode(const Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Wrench_m_Decode(Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Wrench_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Wrench_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((1 <= pVal->arr[i1].force.data.nCount) && (pVal->arr[i1].force.data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->arr[i1].force.data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].force.data.arr[i2]) && (pVal->arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA_ELM;
+        	    }
+        	}
+        	if (ret) {
+        	    ret = ((1 <= pVal->arr[i1].torque.data.nCount) && (pVal->arr[i1].torque.data.nCount <= 3));
+        	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA;
+        	    if (ret) {
+        	        for(i2 = 0; ret && i2 < pVal->arr[i1].torque.data.nCount; i2++)
+        	        {
+        	        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].torque.data.arr[i2]) && (pVal->arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+        	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA_ELM;
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_Wrench_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_Wrench_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix3d_data_Initialize(Wrappers_Matrix3d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 9) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix3d_Initialize(Wrappers_Matrix3d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix3d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix3d_IsConstraintValid(const Wrappers_Matrix3d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 9));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX3D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX3D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix3d_Encode(const Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 9);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix3d_Decode(Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix3d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector4d_data_Initialize(Wrappers_Vector4d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 4) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector4d_Initialize(Wrappers_Vector4d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector4d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector4d_IsConstraintValid(const Wrappers_Vector4d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR4D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR4D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector4d_Encode(const Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector4d_Decode(Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_vector_Wrappers_Vector4d_Initialize(Std_vector_Wrappers_Vector4d* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_vector_Wrappers_Vector4d_IsConstraintValid(const Std_vector_Wrappers_Vector4d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_STD_VECTOR_WRAPPERS_VECTOR4D;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((1 <= pVal->arr[i1].data.nCount) && (pVal->arr[i1].data.nCount <= 4));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->arr[i1].data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].data.arr[i2]) && (pVal->arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA_ELM;
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_vector_Wrappers_Vector4d_Encode(const Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Wrappers_Vector4d_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_vector_Wrappers_Vector4d_Decode(Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Wrappers_Vector4d_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix4d_data_Initialize(Wrappers_Matrix4d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 16) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix4d_Initialize(Wrappers_Matrix4d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix4d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix4d_IsConstraintValid(const Wrappers_Matrix4d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 16));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX4D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX4D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix4d_Encode(const Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 16);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix4d_Decode(Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix4d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Vector6d_data_Initialize(Wrappers_Vector6d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 6) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Vector6d_Initialize(Wrappers_Vector6d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Vector6d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Vector6d_IsConstraintValid(const Wrappers_Vector6d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 6));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR6D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTOR6D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Vector6d_Encode(const Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Vector6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 6);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Vector6d_Decode(Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Vector6d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Matrix6d_data_Initialize(Wrappers_Matrix6d_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 36) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Matrix6d_Initialize(Wrappers_Matrix6d* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_Matrix6d_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_Matrix6d_IsConstraintValid(const Wrappers_Matrix6d* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 36));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX6D_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIX6D_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_Matrix6d_Encode(const Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Matrix6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 36);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Matrix6d_Decode(Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Matrix6d_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TwistWithCovariance_Initialize(Base_TwistWithCovariance* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set vel */
+	Wrappers_Vector3d_Initialize((&(pVal->vel)));
+	/*set rot */
+	Wrappers_Vector3d_Initialize((&(pVal->rot)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TwistWithCovariance_IsConstraintValid(const Base_TwistWithCovariance* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TwistWithCovariance_Encode(const Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TwistWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode vel */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rot */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TwistWithCovariance_Decode(Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode vel */
+	ret = Wrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rot */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TwistWithCovariance_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TwistWithCovariance_m_Initialize(Base_TwistWithCovariance_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set vel */
+	Wrappers_Vector3d_Initialize((&(pVal->vel)));
+	/*set rot */
+	Wrappers_Vector3d_Initialize((&(pVal->rot)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TwistWithCovariance_m_IsConstraintValid(const Base_TwistWithCovariance_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TwistWithCovariance_m_Encode(const Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode vel */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rot */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TwistWithCovariance_m_Decode(Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode vel */
+	ret = Wrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rot */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_Quaterniond_im_Initialize(Wrappers_Quaterniond_im* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 3) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_Quaterniond_Initialize(Wrappers_Quaterniond* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set im */
+	Wrappers_Quaterniond_im_Initialize((&(pVal->im)));
+	/*set re */
+	T_Double_Initialize((&(pVal->re)));
+}
+
+flag Wrappers_Quaterniond_IsConstraintValid(const Wrappers_Quaterniond* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->im.nCount) && (pVal->im.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_QUATERNIOND_IM;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->im.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->im.arr[i1]) && (pVal->im.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_QUATERNIOND_IM_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->re) && (pVal->re <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_QUATERNIOND_RE;
+    }
+
+	return ret;
+}
+
+flag Wrappers_Quaterniond_Encode(const Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_Quaterniond_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode im */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->im.nCount, 1, 3);
+	    	
+	    for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->im.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode re */
+	        ret = T_Double_Encode((&(pVal->re)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_Quaterniond_Decode(Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode im */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM;
+	pVal->im.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->im.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode re */
+	    ret = T_Double_Decode((&(pVal->re)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_Quaterniond_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose_Initialize(Base_Pose* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose_IsConstraintValid(const Base_Pose* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_ORIENTATION_RE;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Pose_Encode(const Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose_Decode(Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TransformWithCovariance_Initialize(Base_TransformWithCovariance* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	Wrappers_Vector3d_Initialize((&(pVal->translation)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TransformWithCovariance_IsConstraintValid(const Base_TransformWithCovariance* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TransformWithCovariance_Encode(const Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TransformWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TransformWithCovariance_Decode(Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = Wrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TransformWithCovariance_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pose_m_Initialize(Base_Pose_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+}
+
+flag Base_Pose_m_IsConstraintValid(const Base_Pose_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_POSITION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_POSITION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_POSE_M_ORIENTATION_RE;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Pose_m_Encode(const Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pose_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pose_m_Decode(Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Pose_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TransformWithCovariance_m_Initialize(Base_TransformWithCovariance_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	Wrappers_Vector3d_Initialize((&(pVal->translation)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov */
+	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
+}
+
+flag Base_TransformWithCovariance_m_IsConstraintValid(const Base_TransformWithCovariance_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TransformWithCovariance_m_Encode(const Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode orientation */
+	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov */
+	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TransformWithCovariance_m_Decode(Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = Wrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode orientation */
+	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov */
+	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_VectorXd_data_Initialize(Wrappers_VectorXd_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_VectorXd_Initialize(Wrappers_VectorXd* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	Wrappers_VectorXd_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_VectorXd_IsConstraintValid(const Wrappers_VectorXd* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTORXD_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_VECTORXD_DATA_ELM;
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_VectorXd_Encode(const Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_VectorXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_VectorXd_Decode(Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode data */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA;
+	pVal->data.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	{
+		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Wrappers_VectorXd_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointState_Initialize(Base_JointState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set position */
+	T_Double_Initialize((&(pVal->position)));
+	/*set speed */
+	T_Float_Initialize((&(pVal->speed)));
+	/*set effort */
+	T_Float_Initialize((&(pVal->effort)));
+	/*set raw */
+	T_Float_Initialize((&(pVal->raw)));
+	/*set acceleration */
+	T_Float_Initialize((&(pVal->acceleration)));
+}
+
+flag Base_JointState_IsConstraintValid(const Base_JointState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->position) && (pVal->position <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_POSITION;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->speed) && (pVal->speed <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_SPEED;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->effort) && (pVal->effort <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_EFFORT;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->raw) && (pVal->raw <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_RAW;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->acceleration) && (pVal->acceleration <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_ACCELERATION;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointState_Encode(const Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode position */
+	    ret = T_Double_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode speed */
+	        ret = T_Float_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode effort */
+	            ret = T_Float_Encode((&(pVal->effort)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode raw */
+	                ret = T_Float_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode acceleration */
+	                    ret = T_Float_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointState_Decode(Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode position */
+	ret = T_Double_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode speed */
+	    ret = T_Float_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode effort */
+	        ret = T_Float_Decode((&(pVal->effort)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode raw */
+	            ret = T_Float_Decode((&(pVal->raw)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode acceleration */
+	                ret = T_Float_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_JointState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTrajectory_Initialize(Base_JointTrajectory* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointState_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Base_JointTrajectory_IsConstraintValid(const Base_JointTrajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_BASE_JOINTTRAJECTORY;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position) && (pVal->arr[i1].position <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_POSITION;
+        	if (ret) {
+        	    ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 3.40282346600000020000E+038));
+        	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_SPEED;
+        	    if (ret) {
+        	        ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].effort) && (pVal->arr[i1].effort <= 3.40282346600000020000E+038));
+        	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_EFFORT;
+        	        if (ret) {
+        	            ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].raw) && (pVal->arr[i1].raw <= 3.40282346600000020000E+038));
+        	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_RAW;
+        	            if (ret) {
+        	                ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].acceleration) && (pVal->arr[i1].acceleration <= 3.40282346600000020000E+038));
+        	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRAJECTORY_ELM_ACCELERATION;
+        	            }
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTrajectory_Encode(const Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointState_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTrajectory_Decode(Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRAJECTORY;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_JointState_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointLimitRange_Initialize(Base_JointLimitRange* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set min */
+	Base_JointState_Initialize((&(pVal->min)));
+	/*set max */
+	Base_JointState_Initialize((&(pVal->max)));
+}
+
+flag Base_JointLimitRange_IsConstraintValid(const Base_JointLimitRange* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->min.position) && (pVal->min.position <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_POSITION;
+    if (ret) {
+        ret = ((-3.40282346600000020000E+038 <= pVal->min.speed) && (pVal->min.speed <= 3.40282346600000020000E+038));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_SPEED;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->min.effort) && (pVal->min.effort <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_EFFORT;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->min.raw) && (pVal->min.raw <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_RAW;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->min.acceleration) && (pVal->min.acceleration <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MIN_ACCELERATION;
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->max.position) && (pVal->max.position <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_POSITION;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->max.speed) && (pVal->max.speed <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_SPEED;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->max.effort) && (pVal->max.effort <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_EFFORT;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->max.raw) && (pVal->max.raw <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_RAW;
+                    if (ret) {
+                        ret = ((-3.40282346600000020000E+038 <= pVal->max.acceleration) && (pVal->max.acceleration <= 3.40282346600000020000E+038));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITRANGE_MAX_ACCELERATION;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointLimitRange_Encode(const Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode min */
+	    ret = Base_JointState_Encode((&(pVal->min)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode max */
+	        ret = Base_JointState_Encode((&(pVal->max)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointLimitRange_Decode(Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode min */
+	ret = Base_JointState_Decode((&(pVal->min)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode max */
+	    ret = Base_JointState_Decode((&(pVal->max)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Pressure_Initialize(Base_Pressure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set pascal */
+	T_Float_Initialize((&(pVal->pascal)));
+}
+
+flag Base_Pressure_IsConstraintValid(const Base_Pressure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_PRESSURE_PASCAL;
+
+	return ret;
+}
+
+flag Base_Pressure_Encode(const Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode pascal */
+	    ret = T_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Pressure_Decode(Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode pascal */
+	ret = T_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);
+
+	return ret  && Base_Pressure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Time_Initialize(Base_Time* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set microseconds */
+	T_Int64_Initialize((&(pVal->microseconds)));
+}
+
+flag Base_Time_IsConstraintValid(const Base_Time* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag Base_Time_Encode(const Base_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode microseconds */
+	    ret = T_Int64_Encode((&(pVal->microseconds)), pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Time_Decode(Base_Time* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode microseconds */
+	ret = T_Int64_Decode((&(pVal->microseconds)), pBitStrm, pErrCode);
+
+	return ret  && Base_Time_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_TimeStamped_Base_commands_Motion2D_Initialize(Base_TimeStamped_Base_commands_Motion2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	T_Double_Initialize((&(pVal->translation)));
+	/*set rotation */
+	T_Double_Initialize((&(pVal->rotation)));
+	/*set heading */
+	Base_Angle_Initialize((&(pVal->heading)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const Base_TimeStamped_Base_commands_Motion2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_RAD;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_TimeStamped_Base_commands_Motion2D_Encode(const Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rotation */
+	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heading */
+	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode time */
+	                ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_TimeStamped_Base_commands_Motion2D_Decode(Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rotation */
+	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heading */
+	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode time */
+	            ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_LinearAngular6DCommand_Initialize(Base_LinearAngular6DCommand* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set linear */
+	Wrappers_Vector3d_Initialize((&(pVal->linear)));
+	/*set angular */
+	Wrappers_Vector3d_Initialize((&(pVal->angular)));
+}
+
+flag Base_LinearAngular6DCommand_IsConstraintValid(const Base_LinearAngular6DCommand* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_LinearAngular6DCommand_Encode(const Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode linear */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode angular */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_LinearAngular6DCommand_Decode(Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode linear */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode angular */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_BodyState_Initialize(Base_samples_BodyState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set pose */
+	Base_TransformWithCovariance_Initialize((&(pVal->pose)));
+	/*set velocity */
+	Base_TwistWithCovariance_Initialize((&(pVal->velocity)));
+}
+
+flag Base_samples_BodyState_IsConstraintValid(const Base_samples_BodyState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_BodyState_Encode(const Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_BodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode pose */
+	        ret = Base_TransformWithCovariance_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode velocity */
+	            ret = Base_TwistWithCovariance_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_BodyState_Decode(Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode pose */
+	    ret = Base_TransformWithCovariance_Decode((&(pVal->pose)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode velocity */
+	        ret = Base_TwistWithCovariance_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_BodyState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_IMUSensors_Initialize(Base_samples_IMUSensors* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acc */
+	Wrappers_Vector3d_Initialize((&(pVal->acc)));
+	/*set gyro */
+	Wrappers_Vector3d_Initialize((&(pVal->gyro)));
+	/*set mag */
+	Wrappers_Vector3d_Initialize((&(pVal->mag)));
+}
+
+flag Base_samples_IMUSensors_IsConstraintValid(const Base_samples_IMUSensors* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_IMUSensors_Encode(const Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_IMUSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acc */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode gyro */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode mag */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_IMUSensors_Decode(Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acc */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode gyro */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode mag */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_IMUSensors_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Motion2D_Initialize(Base_samples_Motion2D* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set translation */
+	T_Double_Initialize((&(pVal->translation)));
+	/*set rotation */
+	T_Double_Initialize((&(pVal->rotation)));
+	/*set heading */
+	Base_Angle_Initialize((&(pVal->heading)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Motion2D_IsConstraintValid(const Base_samples_Motion2D* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_TRANSLATION;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_ROTATION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_MOTION2D_HEADING_RAD;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Motion2D_Encode(const Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode translation */
+	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode rotation */
+	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode heading */
+	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode time */
+	                ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Motion2D_Decode(Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode translation */
+	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode rotation */
+	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode heading */
+	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode time */
+	            ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Motion2D_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Pressure_Initialize(Base_samples_Pressure* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set pascal */
+	T_Float_Initialize((&(pVal->pascal)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Pressure_IsConstraintValid(const Base_samples_Pressure* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_PRESSURE_PASCAL;
+
+	return ret;
+}
+
+flag Base_samples_Pressure_Encode(const Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode pascal */
+	    ret = T_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode time */
+	        ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Pressure_Decode(Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode pascal */
+	ret = T_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode time */
+	    ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_samples_Pressure_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyAcceleration_Initialize(Base_samples_RigidBodyAcceleration* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->acceleration)));
+	/*set cov_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
+	/*set angular_acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
+	/*set cov_angular_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
+}
+
+flag Base_samples_RigidBodyAcceleration_IsConstraintValid(const Base_samples_RigidBodyAcceleration* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_Encode(const Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acceleration */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov_acceleration */
+	            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode angular_acceleration */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_angular_acceleration */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_Decode(Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acceleration */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov_acceleration */
+	        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode angular_acceleration */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_angular_acceleration */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrench_Initialize(Base_samples_Wrench* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrench_IsConstraintValid(const Base_samples_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrench_Encode(const Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrench_Decode(Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Pointcloud_points_Initialize(Base_samples_Pointcloud_points* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector3d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_colors_Initialize(Base_samples_Pointcloud_colors* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_Initialize(Base_samples_Pointcloud* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set points */
+	Base_samples_Pointcloud_points_Initialize((&(pVal->points)));
+	/*set colors */
+	Base_samples_Pointcloud_colors_Initialize((&(pVal->colors)));
+}
+
+flag Base_samples_Pointcloud_IsConstraintValid(const Base_samples_Pointcloud* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_POINTS;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++)
+        {
+        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA_ELM;
+        	    }
+        	}
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_COLORS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA_ELM;
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Pointcloud_Encode(const Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Pointcloud_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode points */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode colors */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	            {
+	            	ret = Wrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Pointcloud_Decode(Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode points */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS;
+	    pVal->points.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	    {
+	    	ret = Wrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode colors */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS;
+	        pVal->colors.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Pointcloud_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_SonarBeam_beam_Initialize(Base_samples_SonarBeam_beam* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 200);
+	pVal->nCount = 1;
+
+}
+void Base_samples_SonarBeam_Initialize(Base_samples_SonarBeam* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set bearing */
+	Base_Angle_Initialize((&(pVal->bearing)));
+	/*set sampling_interval */
+	T_Double_Initialize((&(pVal->sampling_interval)));
+	/*set speed_of_sound */
+	T_Float_Initialize((&(pVal->speed_of_sound)));
+	/*set beamwidth_horizontal */
+	T_Float_Initialize((&(pVal->beamwidth_horizontal)));
+	/*set beamwidth_vertical */
+	T_Float_Initialize((&(pVal->beamwidth_vertical)));
+	/*set beam */
+	Base_samples_SonarBeam_beam_Initialize((&(pVal->beam)));
+}
+
+flag Base_samples_SonarBeam_IsConstraintValid(const Base_samples_SonarBeam* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->bearing.rad) && (pVal->bearing.rad <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEARING_RAD;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_horizontal) && (pVal->beamwidth_horizontal <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_vertical) && (pVal->beamwidth_vertical <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL;
+                    if (ret) {
+                        ret = ((1 <= pVal->beam.nCount) && (pVal->beam.nCount <= 200));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARBEAM_BEAM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_SonarBeam_Encode(const Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_SonarBeam_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode bearing */
+	        ret = Base_Angle_Encode((&(pVal->bearing)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode sampling_interval */
+	            ret = T_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode speed_of_sound */
+	                ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode beamwidth_horizontal */
+	                    ret = T_Float_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode beamwidth_vertical */
+	                        ret = T_Float_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode beam */
+	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->beam.nCount, 1, 200);
+	                            	
+	                            for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++)
+	                            {
+	                            	BitStream_AppendByte0(pBitStrm, pVal->beam.arr[i1]);
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_SonarBeam_Decode(Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode bearing */
+	    ret = Base_Angle_Decode((&(pVal->bearing)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode sampling_interval */
+	        ret = T_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode speed_of_sound */
+	            ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode beamwidth_horizontal */
+	                ret = T_Float_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode beamwidth_vertical */
+	                    ret = T_Float_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode beam */
+	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
+	                        pVal->beam.nCount = (long)nCount;
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++)
+	                        {
+	                        	ret = BitStream_ReadByte(pBitStrm, &(pVal->beam.arr[i1]));
+	                        	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_SonarBeam_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_LinearAngular6DCommand_m_Initialize(Base_commands_LinearAngular6DCommand_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set linear */
+	Wrappers_Vector3d_Initialize((&(pVal->linear)));
+	/*set angular */
+	Wrappers_Vector3d_Initialize((&(pVal->angular)));
+}
+
+flag Base_commands_LinearAngular6DCommand_m_IsConstraintValid(const Base_commands_LinearAngular6DCommand_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_LinearAngular6DCommand_m_Encode(const Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode linear */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode angular */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_LinearAngular6DCommand_m_Decode(Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode linear */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode angular */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_BodyState_m_Initialize(Base_samples_BodyState_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set pose */
+	Base_TransformWithCovariance_m_Initialize((&(pVal->pose)));
+	/*set velocity */
+	Base_TwistWithCovariance_m_Initialize((&(pVal->velocity)));
+}
+
+flag Base_samples_BodyState_m_IsConstraintValid(const Base_samples_BodyState_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_RE;
+        }
+        if (ret) {
+            ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA_ELM;
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_BodyState_m_Encode(const Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_BodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode pose */
+	        ret = Base_TransformWithCovariance_m_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode velocity */
+	            ret = Base_TwistWithCovariance_m_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_BodyState_m_Decode(Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode pose */
+	    ret = Base_TransformWithCovariance_m_Decode((&(pVal->pose)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode velocity */
+	        ret = Base_TwistWithCovariance_m_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_BodyState_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_IMUSensors_m_Initialize(Base_samples_IMUSensors_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acc */
+	Wrappers_Vector3d_Initialize((&(pVal->acc)));
+	/*set gyro */
+	Wrappers_Vector3d_Initialize((&(pVal->gyro)));
+	/*set mag */
+	Wrappers_Vector3d_Initialize((&(pVal->mag)));
+}
+
+flag Base_samples_IMUSensors_m_IsConstraintValid(const Base_samples_IMUSensors_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_IMUSensors_m_Encode(const Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acc */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode gyro */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode mag */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_IMUSensors_m_Decode(Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acc */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode gyro */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode mag */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyAcceleration_m_Initialize(Base_samples_RigidBodyAcceleration_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->acceleration)));
+	/*set cov_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
+	/*set angular_acceleration */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
+	/*set cov_angular_acceleration */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
+}
+
+flag Base_samples_RigidBodyAcceleration_m_IsConstraintValid(const Base_samples_RigidBodyAcceleration_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA_ELM;
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA_ELM;
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_m_Encode(const Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode acceleration */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode cov_acceleration */
+	            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode angular_acceleration */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_angular_acceleration */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyAcceleration_m_Decode(Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode acceleration */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode cov_acceleration */
+	        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode angular_acceleration */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_angular_acceleration */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrench_m_Initialize(Base_samples_Wrench_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set force */
+	Wrappers_Vector3d_Initialize((&(pVal->force)));
+	/*set torque */
+	Wrappers_Vector3d_Initialize((&(pVal->torque)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrench_m_IsConstraintValid(const Base_samples_Wrench_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA_ELM;
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrench_m_Encode(const Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode force */
+	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode torque */
+	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrench_m_Decode(Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode force */
+	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode torque */
+	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrench_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Pointcloud_m_points_Initialize(Base_samples_Pointcloud_m_points* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector3d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_m_colors_Initialize(Base_samples_Pointcloud_m_colors* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Pointcloud_m_Initialize(Base_samples_Pointcloud_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set points */
+	Base_samples_Pointcloud_m_points_Initialize((&(pVal->points)));
+	/*set colors */
+	Base_samples_Pointcloud_m_colors_Initialize((&(pVal->colors)));
+}
+
+flag Base_samples_Pointcloud_m_IsConstraintValid(const Base_samples_Pointcloud_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++)
+        {
+        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA;
+        	if (ret) {
+        	    for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++)
+        	    {
+        	    	ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+        	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA_ELM;
+        	    }
+        	}
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA_ELM;
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Pointcloud_m_Encode(const Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode points */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode colors */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	            {
+	            	ret = Wrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Pointcloud_m_Decode(Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode points */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS;
+	    pVal->points.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++)
+	    {
+	    	ret = Wrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode colors */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS;
+	        pVal->colors.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++)
+	        {
+	        	ret = Wrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_size_t_Initialize(Base_samples_frame_frame_size_t* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set width */
+	T_UInt16_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt16_Initialize((&(pVal->height)));
+}
+
+flag Base_samples_frame_frame_size_t_IsConstraintValid(const Base_samples_frame_frame_size_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->width <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH;
+    if (ret) {
+        ret = (pVal->height <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT;
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_size_t_Encode(const Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode width */
+	    ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode height */
+	        ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_size_t_Decode(Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode width */
+	ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode height */
+	    ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DistanceImage_data_Initialize(Base_samples_DistanceImage_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DistanceImage_Initialize(Base_samples_DistanceImage* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set width */
+	T_UInt16_Initialize((&(pVal->width)));
+	/*set height */
+	T_UInt16_Initialize((&(pVal->height)));
+	/*set scale_x */
+	T_Float_Initialize((&(pVal->scale_x)));
+	/*set scale_y */
+	T_Float_Initialize((&(pVal->scale_y)));
+	/*set center_x */
+	T_Float_Initialize((&(pVal->center_x)));
+	/*set center_y */
+	T_Float_Initialize((&(pVal->center_y)));
+	/*set data */
+	Base_samples_DistanceImage_data_Initialize((&(pVal->data)));
+}
+
+flag Base_samples_DistanceImage_IsConstraintValid(const Base_samples_DistanceImage* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->width <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_WIDTH;
+    if (ret) {
+        ret = (pVal->height <= 65535UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT;
+        if (ret) {
+            ret = ((-3.40282346600000020000E+038 <= pVal->scale_x) && (pVal->scale_x <= 3.40282346600000020000E+038));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X;
+            if (ret) {
+                ret = ((-3.40282346600000020000E+038 <= pVal->scale_y) && (pVal->scale_y <= 3.40282346600000020000E+038));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y;
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->center_x) && (pVal->center_x <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X;
+                    if (ret) {
+                        ret = ((-3.40282346600000020000E+038 <= pVal->center_y) && (pVal->center_y <= 3.40282346600000020000E+038));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y;
+                        if (ret) {
+                            ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+                                {
+                                	ret = ((-3.40282346600000020000E+038 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 3.40282346600000020000E+038));
+                                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_DistanceImage_Encode(const Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_DistanceImage_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode width */
+	        ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode height */
+	            ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode scale_x */
+	                ret = T_Float_Encode((&(pVal->scale_x)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode scale_y */
+	                    ret = T_Float_Encode((&(pVal->scale_y)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode center_x */
+	                        ret = T_Float_Encode((&(pVal->center_x)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode center_y */
+	                            ret = T_Float_Encode((&(pVal->center_y)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode data */
+	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	                                	
+	                                for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	                                {
+	                                	ret = T_Float_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DistanceImage_Decode(Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode width */
+	    ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode height */
+	        ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode scale_x */
+	            ret = T_Float_Decode((&(pVal->scale_x)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode scale_y */
+	                ret = T_Float_Decode((&(pVal->scale_y)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode center_x */
+	                    ret = T_Float_Decode((&(pVal->center_x)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode center_y */
+	                        ret = T_Float_Decode((&(pVal->center_y)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode data */
+	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                            *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA;
+	                            pVal->data.nCount = (long)nCount;
+	                            	
+	                            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	                            {
+	                            	ret = T_Float_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_DistanceImage_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointLimits_names_Initialize(Base_JointLimits_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointLimits_elements_Initialize(Base_JointLimits_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointLimitRange_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointLimits_Initialize(Base_JointLimits* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointLimits_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointLimits_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_JointLimits_IsConstraintValid(const Base_JointLimits* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_POSITION;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_SPEED;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_EFFORT;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_RAW;
+            	                if (ret) {
+            	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
+            	                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_ACCELERATION;
+            	                }
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointLimits_Encode(const Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointLimits_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointLimits_Decode(Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointLimits_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransform_Initialize(Base_JointTransform* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set rotationaxis */
+	Wrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
+}
+
+flag Base_JointTransform_IsConstraintValid(const Base_JointTransform* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransform_Encode(const Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode sourceframe */
+	    ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode targetframe */
+	        ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode rotationaxis */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransform_Decode(Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode sourceframe */
+	ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode targetframe */
+	    ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode rotationaxis */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointTransform_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransformVector_names_Initialize(Base_JointTransformVector_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointTransformVector_elements_Initialize(Base_JointTransformVector_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTransform_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointTransformVector_Initialize(Base_JointTransformVector* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointTransformVector_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointTransformVector_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_JointTransformVector_IsConstraintValid(const Base_JointTransformVector* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransformVector_Encode(const Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointTransformVector_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransformVector_Decode(Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointTransformVector_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointTransform_names_Initialize(Base_NamedVector_Base_JointTransform_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTransform_elements_Initialize(Base_NamedVector_Base_JointTransform_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTransform_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTransform_Initialize(Base_NamedVector_Base_JointTransform* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointTransform_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_JointTransform_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointTransform_IsConstraintValid(const Base_NamedVector_Base_JointTransform* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointTransform_Encode(const Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointTransform_Decode(Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointsTrajectory_names_Initialize(Base_JointsTrajectory_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointsTrajectory_elements_Initialize(Base_JointsTrajectory_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTrajectory_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointsTrajectory_times_val_Initialize(Base_JointsTrajectory_times_val* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointsTrajectory_Initialize(Base_JointsTrajectory* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointsTrajectory_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointsTrajectory_elements_Initialize((&(pVal->elements)));
+	/*set times_val */
+	Base_JointsTrajectory_times_val_Initialize((&(pVal->times_val)));
+}
+
+flag Base_JointsTrajectory_IsConstraintValid(const Base_JointsTrajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
+            	    	if (ret) {
+            	    	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
+            	    	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
+            	    	    if (ret) {
+            	    	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
+            	    	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
+            	    	        if (ret) {
+            	    	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
+            	    	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
+            	    	            if (ret) {
+            	    	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
+            	    	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
+            	    	            }
+            	    	        }
+            	    	    }
+            	    	}
+            	    }
+            	}
+            }
+        }
+        if (ret) {
+            ret = ((1 <= pVal->times_val.nCount) && (pVal->times_val.nCount <= 200));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointsTrajectory_Encode(const Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointsTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode times_val */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->times_val.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++)
+	            {
+	            	ret = Base_Time_Encode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointsTrajectory_Decode(Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode times_val */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL;
+	        pVal->times_val.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Decode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_JointsTrajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointLimitRange_names_Initialize(Base_NamedVector_Base_JointLimitRange_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointLimitRange_elements_Initialize(Base_NamedVector_Base_JointLimitRange_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointLimitRange_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointLimitRange_Initialize(Base_NamedVector_Base_JointLimitRange* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointLimitRange_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_JointLimitRange_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointLimitRange_IsConstraintValid(const Base_NamedVector_Base_JointLimitRange* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_POSITION;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_SPEED;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_EFFORT;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_RAW;
+            	                if (ret) {
+            	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
+            	                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_ACCELERATION;
+            	                }
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointLimitRange_Encode(const Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointLimitRange_Decode(Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointState_names_Initialize(Base_NamedVector_Base_JointState_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointState_Initialize(Base_NamedVector_Base_JointState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointState_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointTrajectory_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointState_IsConstraintValid(const Base_NamedVector_Base_JointState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointState_Encode(const Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Base_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointState_Decode(Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Base_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_Wrench_names_Initialize(Base_NamedVector_Base_Wrench_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_Wrench_elements_Initialize(Base_NamedVector_Base_Wrench_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Wrench_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_Wrench_Initialize(Base_NamedVector_Base_Wrench* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_Wrench_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_Wrench_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_Wrench_IsConstraintValid(const Base_NamedVector_Base_Wrench* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_Wrench_Encode(const Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_Wrench_Decode(Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_Base_JointTrajectory_names_Initialize(Base_NamedVector_Base_JointTrajectory_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTrajectory_elements_Initialize(Base_NamedVector_Base_JointTrajectory_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTrajectory_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_Base_JointTrajectory_Initialize(Base_NamedVector_Base_JointTrajectory* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_Base_JointTrajectory_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_NamedVector_Base_JointTrajectory_elements_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_Base_JointTrajectory_IsConstraintValid(const Base_NamedVector_Base_JointTrajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_POSITION;
+            	    	if (ret) {
+            	    	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
+            	    	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_SPEED;
+            	    	    if (ret) {
+            	    	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
+            	    	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT;
+            	    	        if (ret) {
+            	    	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
+            	    	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_RAW;
+            	    	            if (ret) {
+            	    	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
+            	    	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION;
+            	    	            }
+            	    	        }
+            	    	    }
+            	    	}
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_Base_JointTrajectory_Encode(const Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_Base_JointTrajectory_Decode(Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_commands_Joints_names_Initialize(Base_commands_Joints_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_commands_Joints_Initialize(Base_commands_Joints* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_commands_Joints_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_JointTrajectory_Initialize((&(pVal->elements)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_commands_Joints_IsConstraintValid(const Base_commands_Joints* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_POSITION;
+            	if (ret) {
+            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_SPEED;
+            	    if (ret) {
+            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_EFFORT;
+            	        if (ret) {
+            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
+            	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_RAW;
+            	            if (ret) {
+            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
+            	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_ACCELERATION;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_commands_Joints_Encode(const Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_commands_Joints_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Base_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_commands_Joints_Decode(Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Base_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_commands_Joints_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyState_Initialize(Base_samples_RigidBodyState* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set cov_position */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov_orientation */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
+	/*set velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->velocity)));
+	/*set cov_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
+	/*set angular_velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
+	/*set cov_angular_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
+}
+
+flag Base_samples_RigidBodyState_IsConstraintValid(const Base_samples_RigidBodyState* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_RE;
+                    }
+                    if (ret) {
+                        ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA_ELM;
+                                }
+                            }
+                            if (ret) {
+                                ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++)
+                                    {
+                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA_ELM;
+                                    }
+                                }
+                                if (ret) {
+                                    ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
+                                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA;
+                                    if (ret) {
+                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++)
+                                        {
+                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA_ELM;
+                                        }
+                                    }
+                                    if (ret) {
+                                        ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
+                                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA;
+                                        if (ret) {
+                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++)
+                                            {
+                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA_ELM;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyState_Encode(const Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode sourceframe */
+	        ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode targetframe */
+	            ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode position */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_position */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode orientation */
+	                        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode cov_orientation */
+	                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode velocity */
+	                                ret = Wrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode cov_velocity */
+	                                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode angular_velocity */
+	                                        ret = Wrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode cov_angular_velocity */
+	                                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyState_Decode(Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode sourceframe */
+	    ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode targetframe */
+	        ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode position */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_position */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode orientation */
+	                    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode cov_orientation */
+	                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode velocity */
+	                            ret = Wrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode cov_velocity */
+	                                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode angular_velocity */
+	                                    ret = Wrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode cov_angular_velocity */
+	                                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrenches_names_Initialize(Base_samples_Wrenches_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Wrenches_elements_Initialize(Base_samples_Wrenches_elements* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Wrench_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Wrenches_Initialize(Base_samples_Wrenches* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_samples_Wrenches_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Base_samples_Wrenches_elements_Initialize((&(pVal->elements)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrenches_IsConstraintValid(const Base_samples_Wrenches* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrenches_Encode(const Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Wrenches_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrenches_Decode(Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS;
+	    pVal->elements.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrenches_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_attrib_t_Initialize(Base_samples_frame_frame_attrib_t* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set data */
+	T_String_Initialize((&(pVal->data)));
+	/*set name_val */
+	T_String_Initialize((&(pVal->name_val)));
+}
+
+flag Base_samples_frame_frame_attrib_t_IsConstraintValid(const Base_samples_frame_frame_attrib_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->data.nCount <= 40);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA;
+    if (ret) {
+        ret = (pVal->name_val.nCount <= 40);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL;
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_attrib_t_Encode(const Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode data */
+	    ret = T_String_Encode((&(pVal->data)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode name_val */
+	        ret = T_String_Encode((&(pVal->name_val)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_attrib_t_Decode(Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode data */
+	ret = T_String_Decode((&(pVal->data)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode name_val */
+	    ret = T_String_Decode((&(pVal->name_val)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransform_m_Initialize(Base_JointTransform_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set rotationaxis */
+	Wrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
+}
+
+flag Base_JointTransform_m_IsConstraintValid(const Base_JointTransform_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransform_m_Encode(const Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode sourceframe */
+	    ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode targetframe */
+	        ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode rotationaxis */
+	            ret = Wrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransform_m_Decode(Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode sourceframe */
+	ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode targetframe */
+	    ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode rotationaxis */
+	        ret = Wrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_JointTransform_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = (pVal->arr[i1].sourceframe.nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME;
+        	if (ret) {
+        	    ret = (pVal->arr[i1].targetframe.nCount <= 40);
+        	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME;
+        	    if (ret) {
+        	        ret = ((1 <= pVal->arr[i1].rotationaxis.data.nCount) && (pVal->arr[i1].rotationaxis.data.nCount <= 3));
+        	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA;
+        	        if (ret) {
+        	            for(i2 = 0; ret && i2 < pVal->arr[i1].rotationaxis.data.nCount; i2++)
+        	            {
+        	            	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].rotationaxis.data.arr[i2]) && (pVal->arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+        	            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA_ELM;
+        	            }
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_JointTransform_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_JointTransform_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointTransformVector_m_names_Initialize(Base_JointTransformVector_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_JointTransformVector_m_Initialize(Base_JointTransformVector_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_JointTransformVector_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
+}
+
+flag Base_JointTransformVector_m_IsConstraintValid(const Base_JointTransformVector_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_JointTransformVector_m_Encode(const Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_JointTransformVector_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointTransformVector_m_Decode(Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_JointTransformVector_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_base_JointTransform_m_names_Initialize(Base_NamedVector_base_JointTransform_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_base_JointTransform_m_Initialize(Base_NamedVector_base_JointTransform_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_base_JointTransform_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_base_JointTransform_m_IsConstraintValid(const Base_NamedVector_base_JointTransform_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME;
+            	if (ret) {
+            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME;
+            	    if (ret) {
+            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
+            	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA;
+            	        if (ret) {
+            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++)
+            	            {
+            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
+            	            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM;
+            	            }
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_base_JointTransform_m_Encode(const Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_base_JointTransform_m_Decode(Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_RigidBodyState_m_Initialize(Base_samples_RigidBodyState_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set sourceframe */
+	T_String_Initialize((&(pVal->sourceframe)));
+	/*set targetframe */
+	T_String_Initialize((&(pVal->targetframe)));
+	/*set position */
+	Wrappers_Vector3d_Initialize((&(pVal->position)));
+	/*set cov_position */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_position)));
+	/*set orientation */
+	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
+	/*set cov_orientation */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
+	/*set velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->velocity)));
+	/*set cov_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
+	/*set angular_velocity */
+	Wrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
+	/*set cov_angular_velocity */
+	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
+}
+
+flag Base_samples_RigidBodyState_m_IsConstraintValid(const Base_samples_RigidBodyState_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = (pVal->sourceframe.nCount <= 40);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME;
+    if (ret) {
+        ret = (pVal->targetframe.nCount <= 40);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME;
+        if (ret) {
+            ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA_ELM;
+                }
+            }
+            if (ret) {
+                ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_RE;
+                    }
+                    if (ret) {
+                        ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA_ELM;
+                                }
+                            }
+                            if (ret) {
+                                ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++)
+                                    {
+                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA_ELM;
+                                    }
+                                }
+                                if (ret) {
+                                    ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
+                                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA;
+                                    if (ret) {
+                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++)
+                                        {
+                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA_ELM;
+                                        }
+                                    }
+                                    if (ret) {
+                                        ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
+                                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA;
+                                        if (ret) {
+                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++)
+                                            {
+                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
+                                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA_ELM;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_RigidBodyState_m_Encode(const Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode sourceframe */
+	        ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode targetframe */
+	            ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode position */
+	                ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode cov_position */
+	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode orientation */
+	                        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode cov_orientation */
+	                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode velocity */
+	                                ret = Wrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode cov_velocity */
+	                                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode angular_velocity */
+	                                        ret = Wrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode cov_angular_velocity */
+	                                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_RigidBodyState_m_Decode(Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode sourceframe */
+	    ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode targetframe */
+	        ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode position */
+	            ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode cov_position */
+	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode orientation */
+	                    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode cov_orientation */
+	                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode velocity */
+	                            ret = Wrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode cov_velocity */
+	                                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode angular_velocity */
+	                                    ret = Wrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode cov_angular_velocity */
+	                                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_NamedVector_base_Wrench_m_names_Initialize(Base_NamedVector_base_Wrench_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_NamedVector_base_Wrench_m_Initialize(Base_NamedVector_base_Wrench_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_NamedVector_base_Wrench_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
+}
+
+flag Base_NamedVector_base_Wrench_m_IsConstraintValid(const Base_NamedVector_base_Wrench_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_NamedVector_base_Wrench_m_Encode(const Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_NamedVector_base_Wrench_m_Decode(Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Wrenches_m_names_Initialize(Base_samples_Wrenches_m_names* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_String_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Wrenches_m_Initialize(Base_samples_Wrenches_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set names */
+	Base_samples_Wrenches_m_names_Initialize((&(pVal->names)));
+	/*set elements */
+	Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+}
+
+flag Base_samples_Wrenches_m_IsConstraintValid(const Base_samples_Wrenches_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_NAMES;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++)
+        {
+        	ret = (pVal->names.arr[i1].nCount <= 40);
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_NAMES_ELM;
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++)
+            {
+            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA;
+            	if (ret) {
+            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++)
+            	    {
+            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
+            	    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA_ELM;
+            	    }
+            	}
+            	if (ret) {
+            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA;
+            	    if (ret) {
+            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++)
+            	        {
+            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
+            	        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA_ELM;
+            	        }
+            	    }
+            	}
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Wrenches_m_Encode(const Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode names */
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	    {
+	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+	    if (ret) {
+	        /*Encode elements */
+	        ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode time */
+	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Wrenches_m_Decode(Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode names */
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES;
+	pVal->names.nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++)
+	{
+		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
+	}
+	if (ret) {
+	    /*Decode elements */
+	    ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode time */
+	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	    }
+	}
+
+	return ret  && Base_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_LaserScan_ranges_Initialize(Base_samples_LaserScan_ranges* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_UInt32_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_LaserScan_remission_Initialize(Base_samples_LaserScan_remission* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_LaserScan_Initialize(Base_samples_LaserScan* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set start_angle */
+	T_Double_Initialize((&(pVal->start_angle)));
+	/*set angular_resolution */
+	T_Double_Initialize((&(pVal->angular_resolution)));
+	/*set speed */
+	T_Double_Initialize((&(pVal->speed)));
+	/*set ranges */
+	Base_samples_LaserScan_ranges_Initialize((&(pVal->ranges)));
+	/*set minrange */
+	T_UInt32_Initialize((&(pVal->minrange)));
+	/*set maxrange */
+	T_UInt32_Initialize((&(pVal->maxrange)));
+	/*set remission */
+	Base_samples_LaserScan_remission_Initialize((&(pVal->remission)));
+}
+
+flag Base_samples_LaserScan_IsConstraintValid(const Base_samples_LaserScan* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->start_angle) && (pVal->start_angle <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_START_ANGLE;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution) && (pVal->angular_resolution <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_SPEED;
+            if (ret) {
+                ret = ((1 <= pVal->ranges.nCount) && (pVal->ranges.nCount <= 200));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_RANGES;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->ranges.nCount; i1++)
+                    {
+                    	ret = (pVal->ranges.arr[i1] <= 4294967295UL);
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_RANGES_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = (pVal->minrange <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_MINRANGE;
+                    if (ret) {
+                        ret = (pVal->maxrange <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_MAXRANGE;
+                        if (ret) {
+                            ret = ((1 <= pVal->remission.nCount) && (pVal->remission.nCount <= 200));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_REMISSION;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->remission.nCount; i1++)
+                                {
+                                	ret = ((-3.40282346600000020000E+038 <= pVal->remission.arr[i1]) && (pVal->remission.arr[i1] <= 3.40282346600000020000E+038));
+                                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_LASERSCAN_REMISSION_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_LaserScan_Encode(const Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_LaserScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode start_angle */
+	        ret = T_Double_Encode((&(pVal->start_angle)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode angular_resolution */
+	            ret = T_Double_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode speed */
+	                ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode ranges */
+	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->ranges.nCount, 1, 200);
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_UInt32_Encode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                    }
+	                    if (ret) {
+	                        /*Encode minrange */
+	                        ret = T_UInt32_Encode((&(pVal->minrange)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode maxrange */
+	                            ret = T_UInt32_Encode((&(pVal->maxrange)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode remission */
+	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remission.nCount, 1, 200);
+	                                	
+	                                for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++)
+	                                {
+	                                	ret = T_Float_Encode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_LaserScan_Decode(Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode start_angle */
+	    ret = T_Double_Decode((&(pVal->start_angle)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode angular_resolution */
+	        ret = T_Double_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode speed */
+	            ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode ranges */
+	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES;
+	                pVal->ranges.nCount = (long)nCount;
+	                	
+	                for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++)
+	                {
+	                	ret = T_UInt32_Decode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode);
+	                }
+	                if (ret) {
+	                    /*Decode minrange */
+	                    ret = T_UInt32_Decode((&(pVal->minrange)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode maxrange */
+	                        ret = T_UInt32_Decode((&(pVal->maxrange)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode remission */
+	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                            *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION;
+	                            pVal->remission.nCount = (long)nCount;
+	                            	
+	                            for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++)
+	                            {
+	                            	ret = T_Float_Decode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode);
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_LaserScan_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_Sonar_timestamps_Initialize(Base_samples_Sonar_timestamps* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Sonar_bearings_Initialize(Base_samples_Sonar_bearings* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Angle_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Sonar_bins_Initialize(Base_samples_Sonar_bins* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_Sonar_Initialize(Base_samples_Sonar* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set timestamps */
+	Base_samples_Sonar_timestamps_Initialize((&(pVal->timestamps)));
+	/*set bin_duration */
+	Base_Time_Initialize((&(pVal->bin_duration)));
+	/*set beam_width */
+	Base_Angle_Initialize((&(pVal->beam_width)));
+	/*set beam_height */
+	Base_Angle_Initialize((&(pVal->beam_height)));
+	/*set bearings */
+	Base_samples_Sonar_bearings_Initialize((&(pVal->bearings)));
+	/*set speed_of_sound */
+	T_Float_Initialize((&(pVal->speed_of_sound)));
+	/*set bin_count */
+	T_UInt32_Initialize((&(pVal->bin_count)));
+	/*set beam_count */
+	T_UInt32_Initialize((&(pVal->beam_count)));
+	/*set bins */
+	Base_samples_Sonar_bins_Initialize((&(pVal->bins)));
+}
+
+flag Base_samples_Sonar_IsConstraintValid(const Base_samples_Sonar* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_TIMESTAMPS;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->beam_width.rad) && (pVal->beam_width.rad <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH_RAD;
+        if (ret) {
+            ret = ((-1.79769313486231570000E+308 <= pVal->beam_height.rad) && (pVal->beam_height.rad <= 1.79769313486231570000E+308));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT_RAD;
+            if (ret) {
+                ret = ((1 <= pVal->bearings.nCount) && (pVal->bearings.nCount <= 200));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEARINGS;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->bearings.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->bearings.arr[i1].rad) && (pVal->bearings.arr[i1].rad <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM_RAD;
+                    }
+                }
+                if (ret) {
+                    ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_SPEED_OF_SOUND;
+                    if (ret) {
+                        ret = (pVal->bin_count <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BIN_COUNT;
+                        if (ret) {
+                            ret = (pVal->beam_count <= 4294967295UL);
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BEAM_COUNT;
+                            if (ret) {
+                                ret = ((1 <= pVal->bins.nCount) && (pVal->bins.nCount <= 200));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BINS;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->bins.nCount; i1++)
+                                    {
+                                    	ret = ((-3.40282346600000020000E+038 <= pVal->bins.arr[i1]) && (pVal->bins.arr[i1] <= 3.40282346600000020000E+038));
+                                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONAR_BINS_ELM;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_Sonar_Encode(const Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_Sonar_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode timestamps */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode bin_duration */
+	            ret = Base_Time_Encode((&(pVal->bin_duration)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode beam_width */
+	                ret = Base_Angle_Encode((&(pVal->beam_width)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode beam_height */
+	                    ret = Base_Angle_Encode((&(pVal->beam_height)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode bearings */
+	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bearings.nCount, 1, 200);
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++)
+	                        {
+	                        	ret = Base_Angle_Encode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                        }
+	                        if (ret) {
+	                            /*Encode speed_of_sound */
+	                            ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode bin_count */
+	                                ret = T_UInt32_Encode((&(pVal->bin_count)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode beam_count */
+	                                    ret = T_UInt32_Encode((&(pVal->beam_count)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode bins */
+	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bins.nCount, 1, 200);
+	                                        	
+	                                        for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++)
+	                                        {
+	                                        	ret = T_Float_Encode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_Sonar_Decode(Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode timestamps */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS;
+	    pVal->timestamps.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode bin_duration */
+	        ret = Base_Time_Decode((&(pVal->bin_duration)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode beam_width */
+	            ret = Base_Angle_Decode((&(pVal->beam_width)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode beam_height */
+	                ret = Base_Angle_Decode((&(pVal->beam_height)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode bearings */
+	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS;
+	                    pVal->bearings.nCount = (long)nCount;
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++)
+	                    {
+	                    	ret = Base_Angle_Decode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode);
+	                    }
+	                    if (ret) {
+	                        /*Decode speed_of_sound */
+	                        ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode bin_count */
+	                            ret = T_UInt32_Decode((&(pVal->bin_count)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode beam_count */
+	                                ret = T_UInt32_Decode((&(pVal->beam_count)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode bins */
+	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                                    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS;
+	                                    pVal->bins.nCount = (long)nCount;
+	                                    	
+	                                    for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++)
+	                                    {
+	                                    	ret = T_Float_Decode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_Sonar_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_SonarScan_data_Initialize(Base_samples_SonarScan_data* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 200);
+	pVal->nCount = 1;
+
+}
+void Base_samples_SonarScan_time_beams_Initialize(Base_samples_SonarScan_time_beams* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_SonarScan_Initialize(Base_samples_SonarScan* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set data */
+	Base_samples_SonarScan_data_Initialize((&(pVal->data)));
+	/*set time_beams */
+	Base_samples_SonarScan_time_beams_Initialize((&(pVal->time_beams)));
+	/*set number_of_beams */
+	T_UInt16_Initialize((&(pVal->number_of_beams)));
+	/*set number_of_bins */
+	T_UInt16_Initialize((&(pVal->number_of_bins)));
+	/*set start_bearing */
+	Base_Angle_Initialize((&(pVal->start_bearing)));
+	/*set angular_resolution */
+	Base_Angle_Initialize((&(pVal->angular_resolution)));
+	/*set sampling_interval */
+	T_Double_Initialize((&(pVal->sampling_interval)));
+	/*set speed_of_sound */
+	T_Float_Initialize((&(pVal->speed_of_sound)));
+	/*set beamwidth_horizontal */
+	Base_Angle_Initialize((&(pVal->beamwidth_horizontal)));
+	/*set beamwidth_vertical */
+	Base_Angle_Initialize((&(pVal->beamwidth_vertical)));
+	/*set memory_layout_column */
+	T_Boolean_Initialize((&(pVal->memory_layout_column)));
+	/*set polar_coordinates */
+	T_Boolean_Initialize((&(pVal->polar_coordinates)));
+}
+
+flag Base_samples_SonarScan_IsConstraintValid(const Base_samples_SonarScan* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_DATA;
+    if (ret) {
+        ret = ((1 <= pVal->time_beams.nCount) && (pVal->time_beams.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
+        if (ret) {
+            ret = (pVal->number_of_beams <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS;
+            if (ret) {
+                ret = (pVal->number_of_bins <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS;
+                if (ret) {
+                    ret = ((-1.79769313486231570000E+308 <= pVal->start_bearing.rad) && (pVal->start_bearing.rad <= 1.79769313486231570000E+308));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_START_BEARING_RAD;
+                    if (ret) {
+                        ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution.rad) && (pVal->angular_resolution.rad <= 1.79769313486231570000E+308));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_RAD;
+                        if (ret) {
+                            ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL;
+                            if (ret) {
+                                ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND;
+                                if (ret) {
+                                    ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_horizontal.rad) && (pVal->beamwidth_horizontal.rad <= 1.79769313486231570000E+308));
+                                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_RAD;
+                                    if (ret) {
+                                        ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_vertical.rad) && (pVal->beamwidth_vertical.rad <= 1.79769313486231570000E+308));
+                                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_RAD;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_SonarScan_Encode(const Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_SonarScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode data */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	        {
+	        	BitStream_AppendByte0(pBitStrm, pVal->data.arr[i1]);
+	        }
+	        if (ret) {
+	            /*Encode time_beams */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time_beams.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++)
+	            {
+	            	ret = Base_Time_Encode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	            if (ret) {
+	                /*Encode number_of_beams */
+	                ret = T_UInt16_Encode((&(pVal->number_of_beams)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode number_of_bins */
+	                    ret = T_UInt16_Encode((&(pVal->number_of_bins)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode start_bearing */
+	                        ret = Base_Angle_Encode((&(pVal->start_bearing)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode angular_resolution */
+	                            ret = Base_Angle_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode sampling_interval */
+	                                ret = T_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode speed_of_sound */
+	                                    ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode beamwidth_horizontal */
+	                                        ret = Base_Angle_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
+	                                        if (ret) {
+	                                            /*Encode beamwidth_vertical */
+	                                            ret = Base_Angle_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
+	                                            if (ret) {
+	                                                /*Encode memory_layout_column */
+	                                                ret = T_Boolean_Encode((&(pVal->memory_layout_column)), pBitStrm, pErrCode, FALSE);
+	                                                if (ret) {
+	                                                    /*Encode polar_coordinates */
+	                                                    ret = T_Boolean_Encode((&(pVal->polar_coordinates)), pBitStrm, pErrCode, FALSE);
+	                                                }
+	                                            }
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_SonarScan_Decode(Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode data */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
+	    pVal->data.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	    {
+	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->data.arr[i1]));
+	    	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
+	    }
+	    if (ret) {
+	        /*Decode time_beams */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
+	        pVal->time_beams.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Decode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode);
+	        }
+	        if (ret) {
+	            /*Decode number_of_beams */
+	            ret = T_UInt16_Decode((&(pVal->number_of_beams)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode number_of_bins */
+	                ret = T_UInt16_Decode((&(pVal->number_of_bins)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode start_bearing */
+	                    ret = Base_Angle_Decode((&(pVal->start_bearing)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode angular_resolution */
+	                        ret = Base_Angle_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode sampling_interval */
+	                            ret = T_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode speed_of_sound */
+	                                ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode beamwidth_horizontal */
+	                                    ret = Base_Angle_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
+	                                    if (ret) {
+	                                        /*Decode beamwidth_vertical */
+	                                        ret = Base_Angle_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
+	                                        if (ret) {
+	                                            /*Decode memory_layout_column */
+	                                            ret = T_Boolean_Decode((&(pVal->memory_layout_column)), pBitStrm, pErrCode);
+	                                            if (ret) {
+	                                                /*Decode polar_coordinates */
+	                                                ret = T_Boolean_Decode((&(pVal->polar_coordinates)), pBitStrm, pErrCode);
+	                                            }
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_SonarScan_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_MatrixXd_data_Initialize(Wrappers_MatrixXd_data* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_MatrixXd_Initialize(Wrappers_MatrixXd* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set rows */
+	T_Int32_Initialize((&(pVal->rows)));
+	/*set cols */
+	T_Int32_Initialize((&(pVal->cols)));
+	/*set data */
+	Wrappers_MatrixXd_data_Initialize((&(pVal->data)));
+}
+
+flag Wrappers_MatrixXd_IsConstraintValid(const Wrappers_MatrixXd* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-2147483648LL <= pVal->rows) && (pVal->rows <= 2147483647LL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_ROWS;
+    if (ret) {
+        ret = ((-2147483648LL <= pVal->cols) && (pVal->cols <= 2147483647LL));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_COLS;
+        if (ret) {
+            ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_DATA;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->data.nCount; i1++)
+                {
+                	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_MATRIXXD_DATA_ELM;
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_MatrixXd_Encode(const Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_MatrixXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode rows */
+	    ret = T_Int32_Encode((&(pVal->rows)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode cols */
+	        ret = T_Int32_Encode((&(pVal->cols)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode data */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	            {
+	            	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_MatrixXd_Decode(Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode rows */
+	ret = T_Int32_Decode((&(pVal->rows)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode cols */
+	    ret = T_Int32_Decode((&(pVal->cols)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode data */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA;
+	        pVal->data.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++)
+	        {
+	        	ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Wrappers_MatrixXd_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Dummy2Base_T_Initialize(Dummy2Base_T* pVal)
+{
+	(void)pVal;
+
+
+	DummyBase_T_Initialize(pVal);
+}
+
+flag Dummy2Base_T_IsConstraintValid(const Dummy2Base_T* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_DUMMY2BASE_T;
+
+	return ret;
+}
+
+flag Dummy2Base_T_Encode(const Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Dummy2Base_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = DummyBase_T_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Dummy2Base_T_Decode(Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = DummyBase_T_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && Dummy2Base_T_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_JointState_MODE_Initialize(Base_JointState_MODE* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_jointstate_mode_acceleration;
+}
+
+flag Base_JointState_MODE_IsConstraintValid(const Base_JointState_MODE* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((*(pVal)) == base_jointstate_mode_acceleration)) || (((*(pVal)) == base_jointstate_mode_effort)))) || (((*(pVal)) == base_jointstate_mode_position)))) || (((*(pVal)) == base_jointstate_mode_raw)))) || (((*(pVal)) == base_jointstate_mode_speed)))) || (((*(pVal)) == base_jointstate_mode_unset)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_JOINTSTATE_MODE;
+
+	return ret;
+}
+
+flag Base_JointState_MODE_Encode(const Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_JointState_MODE_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_jointstate_mode_acceleration:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
+	        	break;
+	        case base_jointstate_mode_effort:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
+	        	break;
+	        case base_jointstate_mode_position:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
+	        	break;
+	        case base_jointstate_mode_raw:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
+	        	break;
+	        case base_jointstate_mode_speed:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
+	        	break;
+	        case base_jointstate_mode_unset:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_JOINTSTATE_MODE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_JointState_MODE_Decode(Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_jointstate_mode_acceleration;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_jointstate_mode_effort;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_jointstate_mode_position;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_jointstate_mode_raw;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_jointstate_mode_speed;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_jointstate_mode_unset;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_jointstate_mode_acceleration;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_JointState_MODE_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Time_Resolution_Initialize(Base_Time_Resolution* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_time_resolution_microseconds;
+}
+
+flag Base_Time_Resolution_IsConstraintValid(const Base_Time_Resolution* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == base_time_resolution_microseconds)) || (((*(pVal)) == base_time_resolution_milliseconds)))) || (((*(pVal)) == base_time_resolution_seconds)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_TIME_RESOLUTION;
+
+	return ret;
+}
+
+flag Base_Time_Resolution_Encode(const Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Time_Resolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_time_resolution_microseconds:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case base_time_resolution_milliseconds:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case base_time_resolution_seconds:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_TIME_RESOLUTION; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Time_Resolution_Decode(Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIME_RESOLUTION;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_time_resolution_microseconds;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_time_resolution_milliseconds;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_time_resolution_seconds;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_TIME_RESOLUTION;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_time_resolution_microseconds;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_Time_Resolution_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_geometry_SplineBase_CoordinateType_Initialize(Base_geometry_SplineBase_CoordinateType* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;
+}
+
+flag Base_geometry_SplineBase_CoordinateType_IsConstraintValid(const Base_geometry_SplineBase_CoordinateType* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((((*(pVal)) == base_geometry_splinebase_coordinatetype_derivative_to_next)) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_derivative_to_prior)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_knuckle_point)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_ordinary_point)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_second_derivative_to_next)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_second_derivative_to_prior)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_tangent_point_for_next)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_tangent_point_for_prior)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;
+
+	return ret;
+}
+
+flag Base_geometry_SplineBase_CoordinateType_Encode(const Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_geometry_splinebase_coordinatetype_derivative_to_next:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_derivative_to_prior:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_knuckle_point:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_ordinary_point:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_second_derivative_to_next:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_second_derivative_to_prior:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_tangent_point_for_next:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
+	        	break;
+	        case base_geometry_splinebase_coordinatetype_tangent_point_for_prior:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_geometry_SplineBase_CoordinateType_Decode(Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_prior;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_knuckle_point;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_ordinary_point;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_second_derivative_to_next;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_second_derivative_to_prior;
+	                break;
+	            case 6:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_tangent_point_for_next;
+	                break;
+	            case 7:
+	                (*(pVal)) = base_geometry_splinebase_coordinatetype_tangent_point_for_prior;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;
+}
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((*(pVal)) == base_samples_depthmap_depth_measurement_state_measurement_error)) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_too_far)))) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_too_near)))) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_valid_measurement)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Encode(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_depthmap_depth_measurement_state_measurement_error:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
+	        	break;
+	        case base_samples_depthmap_depth_measurement_state_too_far:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
+	        	break;
+	        case base_samples_depthmap_depth_measurement_state_too_near:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
+	        	break;
+	        case base_samples_depthmap_depth_measurement_state_valid_measurement:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Decode(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_too_far;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_too_near;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_valid_measurement;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_PROJECTION_TYPE_Initialize(Base_samples_DepthMap_PROJECTION_TYPE* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_depthmap_projection_type_planar;
+}
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((*(pVal)) == base_samples_depthmap_projection_type_planar)) || (((*(pVal)) == base_samples_depthmap_projection_type_polar)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_Encode(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_depthmap_projection_type_planar:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
+	        	break;
+	        case base_samples_depthmap_projection_type_polar:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_PROJECTION_TYPE_Decode(Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_depthmap_projection_type_planar;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_depthmap_projection_type_polar;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_depthmap_projection_type_planar;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_timestamps_Initialize(Base_samples_DepthMap_timestamps* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Time_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_vertical_interval_Initialize(Base_samples_DepthMap_vertical_interval* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_horizontal_interval_Initialize(Base_samples_DepthMap_horizontal_interval* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_distances_Initialize(Base_samples_DepthMap_distances* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_remissions_Initialize(Base_samples_DepthMap_remissions* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Float_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_DepthMap_Initialize(Base_samples_DepthMap* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set timestamps */
+	Base_samples_DepthMap_timestamps_Initialize((&(pVal->timestamps)));
+	/*set vertical_projection */
+	Base_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->vertical_projection)));
+	/*set horizontal_projection */
+	Base_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->horizontal_projection)));
+	/*set vertical_interval */
+	Base_samples_DepthMap_vertical_interval_Initialize((&(pVal->vertical_interval)));
+	/*set horizontal_interval */
+	Base_samples_DepthMap_horizontal_interval_Initialize((&(pVal->horizontal_interval)));
+	/*set vertical_size */
+	T_UInt32_Initialize((&(pVal->vertical_size)));
+	/*set horizontal_size */
+	T_UInt32_Initialize((&(pVal->horizontal_size)));
+	/*set distances */
+	Base_samples_DepthMap_distances_Initialize((&(pVal->distances)));
+	/*set remissions */
+	Base_samples_DepthMap_remissions_Initialize((&(pVal->remissions)));
+}
+
+flag Base_samples_DepthMap_IsConstraintValid(const Base_samples_DepthMap* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
+    if (ret) {
+        ret = (((pVal->vertical_projection == base_samples_depthmap_projection_type_planar)) || ((pVal->vertical_projection == base_samples_depthmap_projection_type_polar)));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION;
+        if (ret) {
+            ret = (((pVal->horizontal_projection == base_samples_depthmap_projection_type_planar)) || ((pVal->horizontal_projection == base_samples_depthmap_projection_type_polar)));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION;
+            if (ret) {
+                ret = ((1 <= pVal->vertical_interval.nCount) && (pVal->vertical_interval.nCount <= 200));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
+                if (ret) {
+                    for(i1 = 0; ret && i1 < pVal->vertical_interval.nCount; i1++)
+                    {
+                    	ret = ((-1.79769313486231570000E+308 <= pVal->vertical_interval.arr[i1]) && (pVal->vertical_interval.arr[i1] <= 1.79769313486231570000E+308));
+                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM;
+                    }
+                }
+                if (ret) {
+                    ret = ((1 <= pVal->horizontal_interval.nCount) && (pVal->horizontal_interval.nCount <= 200));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->horizontal_interval.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->horizontal_interval.arr[i1]) && (pVal->horizontal_interval.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = (pVal->vertical_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE;
+                        if (ret) {
+                            ret = (pVal->horizontal_size <= 4294967295UL);
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE;
+                            if (ret) {
+                                ret = ((1 <= pVal->distances.nCount) && (pVal->distances.nCount <= 200));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES;
+                                if (ret) {
+                                    for(i1 = 0; ret && i1 < pVal->distances.nCount; i1++)
+                                    {
+                                    	ret = ((-3.40282346600000020000E+038 <= pVal->distances.arr[i1]) && (pVal->distances.arr[i1] <= 3.40282346600000020000E+038));
+                                    	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM;
+                                    }
+                                }
+                                if (ret) {
+                                    ret = ((1 <= pVal->remissions.nCount) && (pVal->remissions.nCount <= 200));
+                                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
+                                    if (ret) {
+                                        for(i1 = 0; ret && i1 < pVal->remissions.nCount; i1++)
+                                        {
+                                        	ret = ((-3.40282346600000020000E+038 <= pVal->remissions.arr[i1]) && (pVal->remissions.arr[i1] <= 3.40282346600000020000E+038));
+                                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_Encode(const Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_DepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode timestamps */
+	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
+	        	
+	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	        {
+	        	ret = Base_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
+	        }
+	        if (ret) {
+	            /*Encode vertical_projection */
+	            ret = Base_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->vertical_projection)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode horizontal_projection */
+	                ret = Base_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->horizontal_projection)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode vertical_interval */
+	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertical_interval.nCount, 1, 200);
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Encode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                    }
+	                    if (ret) {
+	                        /*Encode horizontal_interval */
+	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->horizontal_interval.nCount, 1, 200);
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++)
+	                        {
+	                        	ret = T_Double_Encode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                        }
+	                        if (ret) {
+	                            /*Encode vertical_size */
+	                            ret = T_UInt32_Encode((&(pVal->vertical_size)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode horizontal_size */
+	                                ret = T_UInt32_Encode((&(pVal->horizontal_size)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode distances */
+	                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->distances.nCount, 1, 200);
+	                                    	
+	                                    for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++)
+	                                    {
+	                                    	ret = T_Float_Encode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                    }
+	                                    if (ret) {
+	                                        /*Encode remissions */
+	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remissions.nCount, 1, 200);
+	                                        	
+	                                        for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++)
+	                                        {
+	                                        	ret = T_Float_Encode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                                        }
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_Decode(Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode timestamps */
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
+	    pVal->timestamps.nCount = (long)nCount;
+	    	
+	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++)
+	    {
+	    	ret = Base_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
+	    }
+	    if (ret) {
+	        /*Decode vertical_projection */
+	        ret = Base_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->vertical_projection)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode horizontal_projection */
+	            ret = Base_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->horizontal_projection)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode vertical_interval */
+	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
+	                pVal->vertical_interval.nCount = (long)nCount;
+	                	
+	                for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++)
+	                {
+	                	ret = T_Double_Decode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode);
+	                }
+	                if (ret) {
+	                    /*Decode horizontal_interval */
+	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
+	                    pVal->horizontal_interval.nCount = (long)nCount;
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Decode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode);
+	                    }
+	                    if (ret) {
+	                        /*Decode vertical_size */
+	                        ret = T_UInt32_Decode((&(pVal->vertical_size)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode horizontal_size */
+	                            ret = T_UInt32_Decode((&(pVal->horizontal_size)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode distances */
+	                                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                                *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES;
+	                                pVal->distances.nCount = (long)nCount;
+	                                	
+	                                for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++)
+	                                {
+	                                	ret = T_Float_Decode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode);
+	                                }
+	                                if (ret) {
+	                                    /*Decode remissions */
+	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                                    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
+	                                    pVal->remissions.nCount = (long)nCount;
+	                                    	
+	                                    for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++)
+	                                    {
+	                                    	ret = T_Float_Decode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_DepthMap_UNIT_AXIS_Initialize(Base_samples_DepthMap_UNIT_AXIS* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_depthmap_unit_axis_unit_x;
+}
+
+flag Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const Base_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == base_samples_depthmap_unit_axis_unit_x)) || (((*(pVal)) == base_samples_depthmap_unit_axis_unit_y)))) || (((*(pVal)) == base_samples_depthmap_unit_axis_unit_z)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;
+
+	return ret;
+}
+
+flag Base_samples_DepthMap_UNIT_AXIS_Encode(const Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_depthmap_unit_axis_unit_x:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case base_samples_depthmap_unit_axis_unit_y:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case base_samples_depthmap_unit_axis_unit_z:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_DepthMap_UNIT_AXIS_Decode(Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_x;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_y;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_z;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_depthmap_unit_axis_unit_x;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_LASER_RANGE_ERRORS_Initialize(Base_samples_LASER_RANGE_ERRORS* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;
+}
+
+flag Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(const Base_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((*(pVal)) == base_samples_laser_range_errors_end_laser_range_errors)) || (((*(pVal)) == base_samples_laser_range_errors_max_range_error)))) || (((*(pVal)) == base_samples_laser_range_errors_measurement_error)))) || (((*(pVal)) == base_samples_laser_range_errors_other_range_errors)))) || (((*(pVal)) == base_samples_laser_range_errors_too_far)))) || (((*(pVal)) == base_samples_laser_range_errors_too_near)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_BASE_SAMPLES_LASER_RANGE_ERRORS;
+
+	return ret;
+}
+
+flag Base_samples_LASER_RANGE_ERRORS_Encode(const Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_laser_range_errors_end_laser_range_errors:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_max_range_error:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_measurement_error:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_other_range_errors:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_too_far:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
+	        	break;
+	        case base_samples_laser_range_errors_too_near:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_LASER_RANGE_ERRORS; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_LASER_RANGE_ERRORS_Decode(Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
+	    *pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_laser_range_errors_max_range_error;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_laser_range_errors_measurement_error;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_samples_laser_range_errors_other_range_errors;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_samples_laser_range_errors_too_far;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_samples_laser_range_errors_too_near;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_mode_t_Initialize(Base_samples_frame_frame_mode_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;
+}
+
+flag Base_samples_frame_frame_mode_t_IsConstraintValid(const Base_samples_frame_frame_mode_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((((((((((((((((((((((((*(pVal)) == base_samples_frame_frame_mode_t_compressed_modes)) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bgr)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_grayscale)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_jpeg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_pjpg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_png)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_rgb)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_rgb32)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_undefined)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_uyvy)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_raw_modes)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_MODE_T;
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_mode_t_Encode(const Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_frame_frame_mode_t_compressed_modes:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_bggr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_gbrg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_grbg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bayer_rggb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_bgr:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_grayscale:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_jpeg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_pjpg:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_png:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_rgb:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_rgb32:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_undefined:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_mode_uyvy:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 15);
+	        	break;
+	        case base_samples_frame_frame_mode_t_raw_modes:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 15);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_MODE_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_mode_t_Decode(Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 15);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_bggr;
+	                break;
+	            case 3:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_gbrg;
+	                break;
+	            case 4:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_grbg;
+	                break;
+	            case 5:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_rggb;
+	                break;
+	            case 6:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bgr;
+	                break;
+	            case 7:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_grayscale;
+	                break;
+	            case 8:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_jpeg;
+	                break;
+	            case 9:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_pjpg;
+	                break;
+	            case 10:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_png;
+	                break;
+	            case 11:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_rgb;
+	                break;
+	            case 12:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_rgb32;
+	                break;
+	            case 13:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_undefined;
+	                break;
+	            case 14:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_uyvy;
+	                break;
+	            case 15:
+	                (*(pVal)) = base_samples_frame_frame_mode_t_raw_modes;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_frame_status_t_Initialize(Base_samples_frame_frame_status_t* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = base_samples_frame_frame_status_t_status_empty;
+}
+
+flag Base_samples_frame_frame_status_t_IsConstraintValid(const Base_samples_frame_frame_status_t* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((*(pVal)) == base_samples_frame_frame_status_t_status_empty)) || (((*(pVal)) == base_samples_frame_frame_status_t_status_invalid)))) || (((*(pVal)) == base_samples_frame_frame_status_t_status_valid)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_STATUS_T;
+
+	return ret;
+}
+
+flag Base_samples_frame_frame_status_t_Encode(const Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case base_samples_frame_frame_status_t_status_empty:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
+	        	break;
+	        case base_samples_frame_frame_status_t_status_invalid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
+	        	break;
+	        case base_samples_frame_frame_status_t_status_valid:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_frame_status_t_Decode(Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = base_samples_frame_frame_status_t_status_empty;
+	                break;
+	            case 1:
+	                (*(pVal)) = base_samples_frame_frame_status_t_status_invalid;
+	                break;
+	            case 2:
+	                (*(pVal)) = base_samples_frame_frame_status_t_status_valid;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = base_samples_frame_frame_status_t_status_empty;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Base_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_Frame_image_Initialize(Base_samples_frame_Frame_image* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 200);
+	pVal->nCount = 1;
+
+}
+void Base_samples_frame_Frame_attributes_Initialize(Base_samples_frame_Frame_attributes* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_samples_frame_frame_attrib_t_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Base_samples_frame_Frame_Initialize(Base_samples_frame_Frame* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set received_time */
+	Base_Time_Initialize((&(pVal->received_time)));
+	/*set image */
+	Base_samples_frame_Frame_image_Initialize((&(pVal->image)));
+	/*set attributes */
+	Base_samples_frame_Frame_attributes_Initialize((&(pVal->attributes)));
+	/*set size_val */
+	Base_samples_frame_frame_size_t_Initialize((&(pVal->size_val)));
+	/*set data_depth */
+	T_UInt32_Initialize((&(pVal->data_depth)));
+	/*set pixel_size */
+	T_UInt32_Initialize((&(pVal->pixel_size)));
+	/*set row_size */
+	T_UInt32_Initialize((&(pVal->row_size)));
+	/*set frame_mode */
+	Base_samples_frame_frame_mode_t_Initialize((&(pVal->frame_mode)));
+	/*set frame_status */
+	Base_samples_frame_frame_status_t_Initialize((&(pVal->frame_status)));
+}
+
+flag Base_samples_frame_Frame_IsConstraintValid(const Base_samples_frame_Frame* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->image.nCount) && (pVal->image.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_IMAGE;
+    if (ret) {
+        ret = ((1 <= pVal->attributes.nCount) && (pVal->attributes.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->attributes.nCount; i1++)
+            {
+            	ret = (pVal->attributes.arr[i1].data.nCount <= 40);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA;
+            	if (ret) {
+            	    ret = (pVal->attributes.arr[i1].name_val.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL;
+            	}
+            }
+        }
+        if (ret) {
+            ret = (pVal->size_val.width <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_WIDTH;
+            if (ret) {
+                ret = (pVal->size_val.height <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_HEIGHT;
+            }
+            if (ret) {
+                ret = (pVal->data_depth <= 4294967295UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH;
+                if (ret) {
+                    ret = (pVal->pixel_size <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE;
+                    if (ret) {
+                        ret = (pVal->row_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE;
+                        if (ret) {
+                            ret = (((((((((((((((((((((((((((((((pVal->frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE;
+                            if (ret) {
+                                ret = (((((pVal->frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->frame_status == base_samples_frame_frame_status_t_status_valid)));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_Frame_Encode(const Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Base_samples_frame_Frame_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode received_time */
+	        ret = Base_Time_Encode((&(pVal->received_time)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode image */
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->image.nCount, 1, 200);
+	            	
+	            for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++)
+	            {
+	            	BitStream_AppendByte0(pBitStrm, pVal->image.arr[i1]);
+	            }
+	            if (ret) {
+	                /*Encode attributes */
+	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 1, 200);
+	                	
+	                for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	                {
+	                	ret = Base_samples_frame_frame_attrib_t_Encode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                }
+	                if (ret) {
+	                    /*Encode size_val */
+	                    ret = Base_samples_frame_frame_size_t_Encode((&(pVal->size_val)), pBitStrm, pErrCode, FALSE);
+	                    if (ret) {
+	                        /*Encode data_depth */
+	                        ret = T_UInt32_Encode((&(pVal->data_depth)), pBitStrm, pErrCode, FALSE);
+	                        if (ret) {
+	                            /*Encode pixel_size */
+	                            ret = T_UInt32_Encode((&(pVal->pixel_size)), pBitStrm, pErrCode, FALSE);
+	                            if (ret) {
+	                                /*Encode row_size */
+	                                ret = T_UInt32_Encode((&(pVal->row_size)), pBitStrm, pErrCode, FALSE);
+	                                if (ret) {
+	                                    /*Encode frame_mode */
+	                                    ret = Base_samples_frame_frame_mode_t_Encode((&(pVal->frame_mode)), pBitStrm, pErrCode, FALSE);
+	                                    if (ret) {
+	                                        /*Encode frame_status */
+	                                        ret = Base_samples_frame_frame_status_t_Encode((&(pVal->frame_status)), pBitStrm, pErrCode, FALSE);
+	                                    }
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_Frame_Decode(Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode received_time */
+	    ret = Base_Time_Decode((&(pVal->received_time)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode image */
+	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	        *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
+	        pVal->image.nCount = (long)nCount;
+	        	
+	        for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++)
+	        {
+	        	ret = BitStream_ReadByte(pBitStrm, &(pVal->image.arr[i1]));
+	        	*pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
+	        }
+	        if (ret) {
+	            /*Decode attributes */
+	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	            *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
+	            pVal->attributes.nCount = (long)nCount;
+	            	
+	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++)
+	            {
+	            	ret = Base_samples_frame_frame_attrib_t_Decode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode);
+	            }
+	            if (ret) {
+	                /*Decode size_val */
+	                ret = Base_samples_frame_frame_size_t_Decode((&(pVal->size_val)), pBitStrm, pErrCode);
+	                if (ret) {
+	                    /*Decode data_depth */
+	                    ret = T_UInt32_Decode((&(pVal->data_depth)), pBitStrm, pErrCode);
+	                    if (ret) {
+	                        /*Decode pixel_size */
+	                        ret = T_UInt32_Decode((&(pVal->pixel_size)), pBitStrm, pErrCode);
+	                        if (ret) {
+	                            /*Decode row_size */
+	                            ret = T_UInt32_Decode((&(pVal->row_size)), pBitStrm, pErrCode);
+	                            if (ret) {
+	                                /*Decode frame_mode */
+	                                ret = Base_samples_frame_frame_mode_t_Decode((&(pVal->frame_mode)), pBitStrm, pErrCode);
+	                                if (ret) {
+	                                    /*Decode frame_status */
+	                                    ret = Base_samples_frame_frame_status_t_Decode((&(pVal->frame_status)), pBitStrm, pErrCode);
+	                                }
+	                            }
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_frame_Frame_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_samples_frame_FramePair_Initialize(Base_samples_frame_FramePair* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set time */
+	Base_Time_Initialize((&(pVal->time)));
+	/*set first */
+	Base_samples_frame_Frame_Initialize((&(pVal->first)));
+	/*set second */
+	Base_samples_frame_Frame_Initialize((&(pVal->second)));
+	/*set id */
+	T_UInt32_Initialize((&(pVal->id)));
+}
+
+flag Base_samples_frame_FramePair_IsConstraintValid(const Base_samples_frame_FramePair* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->first.image.nCount) && (pVal->first.image.nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE;
+    if (ret) {
+        ret = ((1 <= pVal->first.attributes.nCount) && (pVal->first.attributes.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES;
+        if (ret) {
+            for(i1 = 0; ret && i1 < pVal->first.attributes.nCount; i1++)
+            {
+            	ret = (pVal->first.attributes.arr[i1].data.nCount <= 40);
+            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA;
+            	if (ret) {
+            	    ret = (pVal->first.attributes.arr[i1].name_val.nCount <= 40);
+            	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL;
+            	}
+            }
+        }
+        if (ret) {
+            ret = (pVal->first.size_val.width <= 65535UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_WIDTH;
+            if (ret) {
+                ret = (pVal->first.size_val.height <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_HEIGHT;
+            }
+            if (ret) {
+                ret = (pVal->first.data_depth <= 4294967295UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_DATA_DEPTH;
+                if (ret) {
+                    ret = (pVal->first.pixel_size <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_PIXEL_SIZE;
+                    if (ret) {
+                        ret = (pVal->first.row_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ROW_SIZE;
+                        if (ret) {
+                            ret = (((((((((((((((((((((((((((((((pVal->first.frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE;
+                            if (ret) {
+                                ret = (((((pVal->first.frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->first.frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->first.frame_status == base_samples_frame_frame_status_t_status_valid)));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    if (ret) {
+        ret = ((1 <= pVal->second.image.nCount) && (pVal->second.image.nCount <= 200));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE;
+        if (ret) {
+            ret = ((1 <= pVal->second.attributes.nCount) && (pVal->second.attributes.nCount <= 200));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES;
+            if (ret) {
+                for(i1 = 0; ret && i1 < pVal->second.attributes.nCount; i1++)
+                {
+                	ret = (pVal->second.attributes.arr[i1].data.nCount <= 40);
+                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA;
+                	if (ret) {
+                	    ret = (pVal->second.attributes.arr[i1].name_val.nCount <= 40);
+                	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL;
+                	}
+                }
+            }
+            if (ret) {
+                ret = (pVal->second.size_val.width <= 65535UL);
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_WIDTH;
+                if (ret) {
+                    ret = (pVal->second.size_val.height <= 65535UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_HEIGHT;
+                }
+                if (ret) {
+                    ret = (pVal->second.data_depth <= 4294967295UL);
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_DATA_DEPTH;
+                    if (ret) {
+                        ret = (pVal->second.pixel_size <= 4294967295UL);
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_PIXEL_SIZE;
+                        if (ret) {
+                            ret = (pVal->second.row_size <= 4294967295UL);
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ROW_SIZE;
+                            if (ret) {
+                                ret = (((((((((((((((((((((((((((((((pVal->second.frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
+                                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE;
+                                if (ret) {
+                                    ret = (((((pVal->second.frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->second.frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->second.frame_status == base_samples_frame_frame_status_t_status_valid)));
+                                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (ret) {
+            ret = (pVal->id <= 4294967295UL);
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_ID;
+        }
+    }
+
+	return ret;
+}
+
+flag Base_samples_frame_FramePair_Encode(const Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode time */
+	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode first */
+	        ret = Base_samples_frame_Frame_Encode((&(pVal->first)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode second */
+	            ret = Base_samples_frame_Frame_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode id */
+	                ret = T_UInt32_Encode((&(pVal->id)), pBitStrm, pErrCode, FALSE);
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_samples_frame_FramePair_Decode(Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode time */
+	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode first */
+	    ret = Base_samples_frame_Frame_Decode((&(pVal->first)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode second */
+	        ret = Base_samples_frame_Frame_Decode((&(pVal->second)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode id */
+	            ret = T_UInt32_Decode((&(pVal->id)), pBitStrm, pErrCode);
+	        }
+	    }
+	}
+
+	return ret  && Base_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_geometry_SplineType_Initialize(Wrappers_geometry_SplineType* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = wrappers_geometry_splinetype_degenerate;
+}
+
+flag Wrappers_geometry_SplineType_IsConstraintValid(const Wrappers_geometry_SplineType* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((((((((((*(pVal)) == wrappers_geometry_splinetype_degenerate)) || (((*(pVal)) == wrappers_geometry_splinetype_polynomial_bezier)))) || (((*(pVal)) == wrappers_geometry_splinetype_polynomial_bspline)))) || (((*(pVal)) == wrappers_geometry_splinetype_rational_bezier)))) || (((*(pVal)) == wrappers_geometry_splinetype_rational_bspline)));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINETYPE;
+
+	return ret;
+}
+
+flag Wrappers_geometry_SplineType_Encode(const Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Wrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    switch((*(pVal)))
+	    {
+	        case wrappers_geometry_splinetype_degenerate:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_polynomial_bezier:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_polynomial_bspline:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_rational_bezier:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
+	        	break;
+	        case wrappers_geometry_splinetype_rational_bspline:
+	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
+	        	break;
+	        default:                    /*COVERAGE_IGNORE*/
+	    	    *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINETYPE; /*COVERAGE_IGNORE*/
+	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_geometry_SplineType_Decode(Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	{
+	    asn1SccSint enumIndex;
+	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
+	    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;
+	    if (ret) {
+	        switch(enumIndex)
+	        {
+	            case 0:
+	                (*(pVal)) = wrappers_geometry_splinetype_degenerate;
+	                break;
+	            case 1:
+	                (*(pVal)) = wrappers_geometry_splinetype_polynomial_bezier;
+	                break;
+	            case 2:
+	                (*(pVal)) = wrappers_geometry_splinetype_polynomial_bspline;
+	                break;
+	            case 3:
+	                (*(pVal)) = wrappers_geometry_splinetype_rational_bezier;
+	                break;
+	            case 4:
+	                (*(pVal)) = wrappers_geometry_splinetype_rational_bspline;
+	                break;
+	            default:                        /*COVERAGE_IGNORE*/
+		            *pErrCode = i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;     /*COVERAGE_IGNORE*/
+		            ret = FALSE;                /*COVERAGE_IGNORE*/
+	        }
+	    } else {
+	        (*(pVal)) = wrappers_geometry_splinetype_degenerate;             /*COVERAGE_IGNORE*/
+	    }
+	}
+
+	return ret  && Wrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Wrappers_geometry_Spline_knots_Initialize(Wrappers_geometry_Spline_knots* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_geometry_Spline_vertices_Initialize(Wrappers_geometry_Spline_vertices* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    T_Double_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+void Wrappers_geometry_Spline_Initialize(Wrappers_geometry_Spline* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set geometric_resolution */
+	T_Double_Initialize((&(pVal->geometric_resolution)));
+	/*set dimension */
+	T_Int32_Initialize((&(pVal->dimension)));
+	/*set curve_order */
+	T_Int32_Initialize((&(pVal->curve_order)));
+	/*set kind */
+	Wrappers_geometry_SplineType_Initialize((&(pVal->kind)));
+	/*set knots */
+	Wrappers_geometry_Spline_knots_Initialize((&(pVal->knots)));
+	/*set vertices */
+	Wrappers_geometry_Spline_vertices_Initialize((&(pVal->vertices)));
+}
+
+flag Wrappers_geometry_Spline_IsConstraintValid(const Wrappers_geometry_Spline* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->geometric_resolution) && (pVal->geometric_resolution <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION;
+    if (ret) {
+        ret = ((-2147483648LL <= pVal->dimension) && (pVal->dimension <= 2147483647LL));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_DIMENSION;
+        if (ret) {
+            ret = ((-2147483648LL <= pVal->curve_order) && (pVal->curve_order <= 2147483647LL));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER;
+            if (ret) {
+                ret = (((((((((pVal->kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->kind == wrappers_geometry_splinetype_rational_bspline)));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_KIND;
+                if (ret) {
+                    ret = ((1 <= pVal->knots.nCount) && (pVal->knots.nCount <= 200));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
+                    if (ret) {
+                        for(i1 = 0; ret && i1 < pVal->knots.nCount; i1++)
+                        {
+                        	ret = ((-1.79769313486231570000E+308 <= pVal->knots.arr[i1]) && (pVal->knots.arr[i1] <= 1.79769313486231570000E+308));
+                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM;
+                        }
+                    }
+                    if (ret) {
+                        ret = ((1 <= pVal->vertices.nCount) && (pVal->vertices.nCount <= 200));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->vertices.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->vertices.arr[i1]) && (pVal->vertices.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Wrappers_geometry_Spline_Encode(const Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Wrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode geometric_resolution */
+	    ret = T_Double_Encode((&(pVal->geometric_resolution)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode dimension */
+	        ret = T_Int32_Encode((&(pVal->dimension)), pBitStrm, pErrCode, FALSE);
+	        if (ret) {
+	            /*Encode curve_order */
+	            ret = T_Int32_Encode((&(pVal->curve_order)), pBitStrm, pErrCode, FALSE);
+	            if (ret) {
+	                /*Encode kind */
+	                ret = Wrappers_geometry_SplineType_Encode((&(pVal->kind)), pBitStrm, pErrCode, FALSE);
+	                if (ret) {
+	                    /*Encode knots */
+	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->knots.nCount, 1, 200);
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Encode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                    }
+	                    if (ret) {
+	                        /*Encode vertices */
+	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertices.nCount, 1, 200);
+	                        	
+	                        for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++)
+	                        {
+	                        	ret = T_Double_Encode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode, FALSE);
+	                        }
+	                    }
+	                }
+	            }
+	        }
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Wrappers_geometry_Spline_Decode(Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	/*Decode geometric_resolution */
+	ret = T_Double_Decode((&(pVal->geometric_resolution)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode dimension */
+	    ret = T_Int32_Decode((&(pVal->dimension)), pBitStrm, pErrCode);
+	    if (ret) {
+	        /*Decode curve_order */
+	        ret = T_Int32_Decode((&(pVal->curve_order)), pBitStrm, pErrCode);
+	        if (ret) {
+	            /*Decode kind */
+	            ret = Wrappers_geometry_SplineType_Decode((&(pVal->kind)), pBitStrm, pErrCode);
+	            if (ret) {
+	                /*Decode knots */
+	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
+	                pVal->knots.nCount = (long)nCount;
+	                	
+	                for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++)
+	                {
+	                	ret = T_Double_Decode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode);
+	                }
+	                if (ret) {
+	                    /*Decode vertices */
+	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	                    *pErrCode = ret ? 0 : i3ds_asn1_i3ds_asn1_ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
+	                    pVal->vertices.nCount = (long)nCount;
+	                    	
+	                    for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++)
+	                    {
+	                    	ret = T_Double_Decode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode);
+	                    }
+	                }
+	            }
+	        }
+	    }
+	}
+
+	return ret  && Wrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Trajectory_Initialize(Base_Trajectory* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set speed */
+	T_Double_Initialize((&(pVal->speed)));
+	/*set spline */
+	Wrappers_geometry_Spline_Initialize((&(pVal->spline)));
+}
+
+flag Base_Trajectory_IsConstraintValid(const Base_Trajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPEED;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_GEOMETRIC_RESOLUTION;
+        if (ret) {
+            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_DIMENSION;
+            if (ret) {
+                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_CURVE_ORDER;
+                if (ret) {
+                    ret = (((((((((pVal->spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bspline)));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_KIND;
+                    if (ret) {
+                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_KNOTS;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_KNOTS_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_VERTICES;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_SPLINE_VERTICES_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Trajectory_Encode(const Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode speed */
+	    ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode spline */
+	        ret = Wrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Trajectory_Decode(Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode speed */
+	ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode spline */
+	    ret = Wrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Trajectory_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Base_Trajectory_m_Initialize(Base_Trajectory_m* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set speed */
+	T_Double_Initialize((&(pVal->speed)));
+	/*set spline */
+	Wrappers_geometry_Spline_Initialize((&(pVal->spline)));
+}
+
+flag Base_Trajectory_m_IsConstraintValid(const Base_Trajectory_m* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPEED;
+    if (ret) {
+        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_GEOMETRIC_RESOLUTION;
+        if (ret) {
+            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
+            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_DIMENSION;
+            if (ret) {
+                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
+                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_CURVE_ORDER;
+                if (ret) {
+                    ret = (((((((((pVal->spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bspline)));
+                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_KIND;
+                    if (ret) {
+                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
+                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS;
+                        if (ret) {
+                            for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++)
+                            {
+                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
+                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS_ELM;
+                            }
+                        }
+                        if (ret) {
+                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
+                            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES;
+                            if (ret) {
+                                for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++)
+                                {
+                                	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
+                                	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES_ELM;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+	return ret;
+}
+
+flag Base_Trajectory_m_Encode(const Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? Base_Trajectory_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode speed */
+	    ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode spline */
+	        ret = Wrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Base_Trajectory_m_Decode(Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode speed */
+	ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode spline */
+	    ret = Wrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
+	}
+
+	return ret  && Base_Trajectory_m_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void Std_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal)
+{
+	(void)pVal;
+
+    int i1;
+
+	i1 = 0;
+	while (i1< 200) {
+	    Base_Trajectory_m_Initialize((&(pVal->arr[i1])));
+	    i1 = i1 + 1;
+	}
+	pVal->nCount = 1;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+    int i1;
+    int i2;
+	(void)pVal;
+	
+    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
+    if (ret) {
+        for(i1 = 0; ret && i1 < pVal->nCount; i1++)
+        {
+        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 1.79769313486231570000E+308));
+        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPEED;
+        	if (ret) {
+        	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.geometric_resolution) && (pVal->arr[i1].spline.geometric_resolution <= 1.79769313486231570000E+308));
+        	    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_GEOMETRIC_RESOLUTION;
+        	    if (ret) {
+        	        ret = ((-2147483648LL <= pVal->arr[i1].spline.dimension) && (pVal->arr[i1].spline.dimension <= 2147483647LL));
+        	        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_DIMENSION;
+        	        if (ret) {
+        	            ret = ((-2147483648LL <= pVal->arr[i1].spline.curve_order) && (pVal->arr[i1].spline.curve_order <= 2147483647LL));
+        	            *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_CURVE_ORDER;
+        	            if (ret) {
+        	                ret = (((((((((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_rational_bspline)));
+        	                *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND;
+        	                if (ret) {
+        	                    ret = ((1 <= pVal->arr[i1].spline.knots.nCount) && (pVal->arr[i1].spline.knots.nCount <= 200));
+        	                    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS;
+        	                    if (ret) {
+        	                        for(i2 = 0; ret && i2 < pVal->arr[i1].spline.knots.nCount; i2++)
+        	                        {
+        	                        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.knots.arr[i2]) && (pVal->arr[i1].spline.knots.arr[i2] <= 1.79769313486231570000E+308));
+        	                        	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS_ELM;
+        	                        }
+        	                    }
+        	                    if (ret) {
+        	                        ret = ((1 <= pVal->arr[i1].spline.vertices.nCount) && (pVal->arr[i1].spline.vertices.nCount <= 200));
+        	                        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES;
+        	                        if (ret) {
+        	                            for(i2 = 0; ret && i2 < pVal->arr[i1].spline.vertices.nCount; i2++)
+        	                            {
+        	                            	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.vertices.arr[i2]) && (pVal->arr[i1].spline.vertices.arr[i2] <= 1.79769313486231570000E+308));
+        	                            	*pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_i3ds_asn1_ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES_ELM;
+        	                            }
+        	                        }
+        	                    }
+        	                }
+        	            }
+        	        }
+        	    }
+        	}
+        }
+    }
+
+	return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Encode(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	ret = Base_Trajectory_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Decode(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = Base_Trajectory_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
+	}
+
+	return ret  && Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/taste-extended.cpp b/generated/src/taste-extended.cpp
new file mode 100644
index 0000000..dc34317
--- /dev/null
+++ b/generated/src/taste-extended.cpp
@@ -0,0 +1,458 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+const T_UInt32 numT_String = 40;
+
+
+void T_Time_Initialize(T_Time* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set secs */
+	T_UInt32_Initialize((&(pVal->secs)));
+	/*set nsecs */
+	T_UInt32_Initialize((&(pVal->nsecs)));
+}
+
+flag T_Time_IsConstraintValid(const T_Time* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->secs <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_T_TIME_SECS;
+    if (ret) {
+        ret = (pVal->nsecs <= 4294967295UL);
+        *pErrCode = ret ? 0 :  i3ds_asn1_i3ds_asn1_ERR_T_TIME_NSECS;
+    }
+
+	return ret;
+}
+
+flag T_Time_Encode(const T_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode secs */
+	    ret = T_UInt32_Encode((&(pVal->secs)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode nsecs */
+	        ret = T_UInt32_Encode((&(pVal->nsecs)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Time_Decode(T_Time* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode secs */
+	ret = T_UInt32_Decode((&(pVal->secs)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode nsecs */
+	    ret = T_UInt32_Decode((&(pVal->nsecs)), pBitStrm, pErrCode);
+	}
+
+	return ret  && T_Time_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Double_Initialize(T_Double* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0.00000000000000000000E+000;
+}
+
+flag T_Double_IsConstraintValid(const T_Double* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= (*(pVal))) && ((*(pVal)) <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_DOUBLE;
+
+	return ret;
+}
+
+flag T_Double_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Double_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeReal(pBitStrm, pVal);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_DOUBLE;
+
+	return ret  && T_Double_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Float_Initialize(T_Float* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0.00000000000000000000E+000;
+}
+
+flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_FLOAT;
+
+	return ret;
+}
+
+flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeReal(pBitStrm, pVal);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_FLOAT;
+
+	return ret  && T_Float_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Int16_Initialize(T_Int16* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int16_IsConstraintValid(const T_Int16* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_INT16;
+
+	return ret;
+}
+
+flag T_Int16_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int16_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_INT16;
+
+	return ret  && T_Int16_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt16_Initialize(T_UInt16* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 65535UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_UINT16;
+
+	return ret;
+}
+
+flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_UINT16;
+
+	return ret  && T_UInt16_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt64_Initialize(T_UInt64* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_UINT64;
+
+	return ret  && T_UInt64_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Int64_Initialize(T_Int64* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int64_IsConstraintValid(const T_Int64* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag T_Int64_Encode(const T_Int64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int64_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), LLONG_MIN, 9223372036854775807LL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int64_Decode(T_Int64* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, LLONG_MIN, 9223372036854775807LL);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_INT64;
+
+	return ret  && T_Int64_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_String_Initialize(T_String* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 40);
+	pVal->nCount = 0;
+
+}
+
+flag T_String_IsConstraintValid(const T_String* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->nCount <= 40);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_STRING;
+
+	return ret;
+}
+
+flag T_String_Encode(const T_String* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? T_String_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 40);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_String_Decode(T_String* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_STRING;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1]));
+		*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_STRING;
+	}
+
+	return ret  && T_String_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/taste-types.cpp b/generated/src/taste-types.cpp
new file mode 100644
index 0000000..61f6aa5
--- /dev/null
+++ b/generated/src/taste-types.cpp
@@ -0,0 +1,270 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+
+
+void T_Int32_Initialize(T_Int32* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_INT32;
+
+	return ret;
+}
+
+flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_INT32;
+
+	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt32_Initialize(T_UInt32* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_UINT32;
+
+	return ret;
+}
+
+flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_UINT32;
+
+	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Int8_Initialize(T_Int8* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_INT8;
+
+	return ret;
+}
+
+flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_INT8;
+
+	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt8_Initialize(T_UInt8* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_T_UINT8;
+
+	return ret;
+}
+
+flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_UINT8;
+
+	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Boolean_Initialize(T_Boolean* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = FALSE;
+}
+
+flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_AppendBit(pBitStrm,(*(pVal)));
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_ReadBit(pBitStrm, pVal);
+	*pErrCode = ret ? 0 : i3ds_asn1_ERR_UPER_DECODE_T_BOOLEAN;
+
+	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/src/userdefs-base.cpp b/generated/src/userdefs-base.cpp
new file mode 100644
index 0000000..61d96c3
--- /dev/null
+++ b/generated/src/userdefs-base.cpp
@@ -0,0 +1,118 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/userdefs-base.hpp>
+namespace i3ds_asn1 {
+
+const T_UInt32 numBase_JointTrajectory = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_JointTransform = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Waypoint = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Wrench = 200;
+const T_UInt32 numStd_vector_Wrappers_Vector4d = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Trajectory = 200;
+const T_UInt32 numBase_JointLimits_names = 200;
+const T_UInt32 numBase_JointLimits_elements = 200;
+const T_UInt32 numBase_JointsTrajectory_names = 200;
+const T_UInt32 numBase_JointsTrajectory_elements = 200;
+const T_UInt32 numBase_JointsTrajectory_times_val = 200;
+const T_UInt32 numBase_NamedVector_Base_JointLimitRange_names = 200;
+const T_UInt32 numBase_NamedVector_Base_JointLimitRange_elements = 200;
+const T_UInt32 numBase_NamedVector_Base_JointState_names = 200;
+const T_UInt32 numBase_NamedVector_Base_Wrench_names = 200;
+const T_UInt32 numBase_NamedVector_Base_Wrench_elements = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTrajectory_names = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTrajectory_elements = 200;
+const T_UInt32 numBase_samples_DepthMap_timestamps = 200;
+const T_UInt32 numBase_samples_DepthMap_vertical_interval = 200;
+const T_UInt32 numBase_samples_DepthMap_horizontal_interval = 200;
+const T_UInt32 numBase_samples_DepthMap_distances = 200;
+const T_UInt32 numBase_samples_DepthMap_remissions = 200;
+const T_UInt32 numBase_samples_DistanceImage_data = 200;
+const T_UInt32 numBase_commands_Joints_names = 200;
+const T_UInt32 numBase_samples_LaserScan_ranges = 200;
+const T_UInt32 numBase_samples_LaserScan_remission = 200;
+const T_UInt32 numBase_samples_Pointcloud_points = 200;
+const T_UInt32 numBase_samples_Pointcloud_colors = 200;
+const T_UInt32 numBase_samples_Sonar_timestamps = 200;
+const T_UInt32 numBase_samples_Sonar_bearings = 200;
+const T_UInt32 numBase_samples_Sonar_bins = 200;
+const T_UInt32 numBase_samples_SonarBeam_beam = 200;
+const T_UInt32 numBase_samples_SonarScan_data = 200;
+const T_UInt32 numBase_samples_SonarScan_time_beams = 200;
+const T_UInt32 numBase_samples_Wrenches_names = 200;
+const T_UInt32 numBase_samples_Wrenches_elements = 200;
+const T_UInt32 numBase_JointTransformVector_names = 200;
+const T_UInt32 numBase_JointTransformVector_elements = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTransform_names = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTransform_elements = 200;
+const T_UInt32 numBase_samples_frame_Frame_image = 200;
+const T_UInt32 numBase_samples_frame_Frame_attributes = 200;
+const T_UInt32 numWrappers_MatrixXd_data = 200;
+const T_UInt32 numWrappers_VectorXd_data = 200;
+const T_UInt32 numBase_JointTransformVector_m_names = 200;
+const T_UInt32 numBase_NamedVector_base_JointTransform_m_names = 200;
+const T_UInt32 numBase_NamedVector_base_Wrench_m_names = 200;
+const T_UInt32 numBase_samples_Pointcloud_m_points = 200;
+const T_UInt32 numBase_samples_Pointcloud_m_colors = 200;
+const T_UInt32 numBase_samples_Wrenches_m_names = 200;
+const T_UInt32 numWrappers_geometry_Spline_knots = 200;
+const T_UInt32 numWrappers_geometry_Spline_vertices = 200;
+
+
+void DummyBase_T_Initialize(DummyBase_T* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag DummyBase_T_IsConstraintValid(const DummyBase_T* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  i3ds_asn1_ERR_DUMMYBASE_T;
+
+	return ret;
+}
+
+flag DummyBase_T_Encode(const DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? DummyBase_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag DummyBase_T_Decode(DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && DummyBase_T_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/taste-extended.c b/generated/taste-extended.c
new file mode 100644
index 0000000..fe80e33
--- /dev/null
+++ b/generated/taste-extended.c
@@ -0,0 +1,458 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/taste-extended.hpp>
+namespace i3ds_asn1 {
+
+const T_UInt32 numT_String = 40;
+
+
+void T_Time_Initialize(T_Time* pVal)
+{
+	(void)pVal;
+
+
+
+	/*set secs */
+	T_UInt32_Initialize((&(pVal->secs)));
+	/*set nsecs */
+	T_UInt32_Initialize((&(pVal->nsecs)));
+}
+
+flag T_Time_IsConstraintValid(const T_Time* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->secs <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_T_TIME_SECS;
+    if (ret) {
+        ret = (pVal->nsecs <= 4294967295UL);
+        *pErrCode = ret ? 0 :  ERR_T_TIME_NSECS;
+    }
+
+	return ret;
+}
+
+flag T_Time_Encode(const T_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    /*Encode secs */
+	    ret = T_UInt32_Encode((&(pVal->secs)), pBitStrm, pErrCode, FALSE);
+	    if (ret) {
+	        /*Encode nsecs */
+	        ret = T_UInt32_Encode((&(pVal->nsecs)), pBitStrm, pErrCode, FALSE);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Time_Decode(T_Time* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	/*Decode secs */
+	ret = T_UInt32_Decode((&(pVal->secs)), pBitStrm, pErrCode);
+	if (ret) {
+	    /*Decode nsecs */
+	    ret = T_UInt32_Decode((&(pVal->nsecs)), pBitStrm, pErrCode);
+	}
+
+	return ret  && T_Time_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Double_Initialize(T_Double* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0.00000000000000000000E+000;
+}
+
+flag T_Double_IsConstraintValid(const T_Double* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-1.79769313486231570000E+308 <= (*(pVal))) && ((*(pVal)) <= 1.79769313486231570000E+308));
+    *pErrCode = ret ? 0 :  ERR_T_DOUBLE;
+
+	return ret;
+}
+
+flag T_Double_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Double_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeReal(pBitStrm, pVal);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_DOUBLE;
+
+	return ret  && T_Double_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Float_Initialize(T_Float* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0.00000000000000000000E+000;
+}
+
+flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-3.40282346600000020000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40282346600000020000E+038));
+    *pErrCode = ret ? 0 :  ERR_T_FLOAT;
+
+	return ret;
+}
+
+flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeReal(pBitStrm, pVal);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;
+
+	return ret  && T_Float_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Int16_Initialize(T_Int16* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int16_IsConstraintValid(const T_Int16* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
+    *pErrCode = ret ? 0 :  ERR_T_INT16;
+
+	return ret;
+}
+
+flag T_Int16_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int16_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT16;
+
+	return ret  && T_Int16_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt16_Initialize(T_UInt16* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 65535UL);
+    *pErrCode = ret ? 0 :  ERR_T_UINT16;
+
+	return ret;
+}
+
+flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;
+
+	return ret  && T_UInt16_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt64_Initialize(T_UInt64* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;
+
+	return ret  && T_UInt64_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Int64_Initialize(T_Int64* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int64_IsConstraintValid(const T_Int64* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag T_Int64_Encode(const T_Int64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int64_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), LLONG_MIN, 9223372036854775807LL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int64_Decode(T_Int64* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, LLONG_MIN, 9223372036854775807LL);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT64;
+
+	return ret  && T_Int64_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_String_Initialize(T_String* pVal)
+{
+	(void)pVal;
+
+
+	memset(pVal->arr, 0x0, 40);
+	pVal->nCount = 0;
+
+}
+
+flag T_String_IsConstraintValid(const T_String* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = (pVal->nCount <= 40);
+    *pErrCode = ret ? 0 :  ERR_T_STRING;
+
+	return ret;
+}
+
+flag T_String_Encode(const T_String* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	int i1;
+	ret = bCheckConstraints ? T_String_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 40);
+	    	
+	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	    {
+	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
+	    }
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_String_Decode(T_String* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+	int i1;
+	asn1SccSint nCount;
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING;
+	pVal->nCount = (long)nCount;
+		
+	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
+	{
+		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1]));
+		*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING;
+	}
+
+	return ret  && T_String_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/taste-extended.h b/generated/taste-extended.h
new file mode 100644
index 0000000..0c1c2b9
--- /dev/null
+++ b/generated/taste-extended.h
@@ -0,0 +1,176 @@
+#ifndef GENERATED_ASN1SCC_taste_extended_H
+#define GENERATED_ASN1SCC_taste_extended_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+/*-- T_Time --------------------------------------------*/
+typedef struct {
+    T_UInt32 secs;
+    T_UInt32 nsecs;
+
+} T_Time;
+
+void T_Time_Initialize(T_Time* pVal);
+
+#define ERR_T_TIME		8291  /**/
+#define ERR_T_TIME_SECS		8269  /**/
+#define ERR_T_TIME_NSECS		8280  /**/
+flag T_Time_IsConstraintValid(const T_Time* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_TIME		8292  /**/
+#define ERR_UPER_ENCODE_T_TIME_SECS_2		8276  /**/
+#define ERR_UPER_ENCODE_T_TIME_NSECS_2		8287  /**/
+#define T_Time_REQUIRED_BYTES_FOR_ENCODING       8
+#define T_Time_REQUIRED_BITS_FOR_ENCODING        64
+
+flag T_Time_Encode(const T_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_TIME		8293  /**/
+#define ERR_UPER_DECODE_T_TIME_SECS_2		8277  /**/
+#define ERR_UPER_DECODE_T_TIME_NSECS_2		8288  /**/
+flag T_Time_Decode(T_Time* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1Real T_Double;
+
+
+void T_Double_Initialize(T_Double* pVal);
+
+#define ERR_T_DOUBLE		8220  /**/
+flag T_Double_IsConstraintValid(const T_Double* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_DOUBLE		8221  /**/
+#define T_Double_REQUIRED_BYTES_FOR_ENCODING       13
+#define T_Double_REQUIRED_BITS_FOR_ENCODING        104
+
+flag T_Double_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_DOUBLE		8222  /**/
+flag T_Double_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1Real T_Float;
+
+
+void T_Float_Initialize(T_Float* pVal);
+
+#define ERR_T_FLOAT		8227  /**/
+flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_FLOAT		8228  /**/
+#define T_Float_REQUIRED_BYTES_FOR_ENCODING       13
+#define T_Float_REQUIRED_BITS_FOR_ENCODING        104
+
+flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_FLOAT		8229  /**/
+flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccSint T_Int16;
+
+
+void T_Int16_Initialize(T_Int16* pVal);
+
+#define ERR_T_INT16		8234  /**/
+flag T_Int16_IsConstraintValid(const T_Int16* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_INT16		8235  /**/
+#define T_Int16_REQUIRED_BYTES_FOR_ENCODING       2
+#define T_Int16_REQUIRED_BITS_FOR_ENCODING        16
+
+flag T_Int16_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_INT16		8236  /**/
+flag T_Int16_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt16;
+
+
+void T_UInt16_Initialize(T_UInt16* pVal);
+
+#define ERR_T_UINT16		8241  /**/
+flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_UINT16		8242  /**/
+#define T_UInt16_REQUIRED_BYTES_FOR_ENCODING       2
+#define T_UInt16_REQUIRED_BITS_FOR_ENCODING        16
+
+flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_UINT16		8243  /**/
+flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt64;
+
+
+void T_UInt64_Initialize(T_UInt64* pVal);
+
+#define ERR_T_UINT64		8248  /**/
+flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_UINT64		8249  /**/
+#define T_UInt64_REQUIRED_BYTES_FOR_ENCODING       8
+#define T_UInt64_REQUIRED_BITS_FOR_ENCODING        64
+
+flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_UINT64		8250  /**/
+flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccSint T_Int64;
+
+
+void T_Int64_Initialize(T_Int64* pVal);
+
+#define ERR_T_INT64		8255  /**/
+flag T_Int64_IsConstraintValid(const T_Int64* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_INT64		8256  /**/
+#define T_Int64_REQUIRED_BYTES_FOR_ENCODING       8
+#define T_Int64_REQUIRED_BITS_FOR_ENCODING        64
+
+flag T_Int64_Encode(const T_Int64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_INT64		8257  /**/
+flag T_Int64_Decode(T_Int64* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef struct {
+    int nCount;
+
+    byte arr[40];
+} T_String;
+
+
+void T_String_Initialize(T_String* pVal);
+
+#define ERR_T_STRING		8262  /**/
+flag T_String_IsConstraintValid(const T_String* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_STRING		8263  /**/
+#define T_String_REQUIRED_BYTES_FOR_ENCODING       41
+#define T_String_REQUIRED_BITS_FOR_ENCODING        326
+
+flag T_String_Encode(const T_String* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_STRING		8264  /**/
+flag T_String_Decode(T_String* pVal, BitStream* pBitStrm, int* pErrCode);
+
+extern const T_UInt32 numT_String;
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/taste-types.c b/generated/taste-types.c
new file mode 100644
index 0000000..0f6c3a8
--- /dev/null
+++ b/generated/taste-types.c
@@ -0,0 +1,270 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+
+
+void T_Int32_Initialize(T_Int32* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
+    *pErrCode = ret ? 0 :  ERR_T_INT32;
+
+	return ret;
+}
+
+flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;
+
+	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt32_Initialize(T_UInt32* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_T_UINT32;
+
+	return ret;
+}
+
+flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;
+
+	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Int8_Initialize(T_Int8* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
+    *pErrCode = ret ? 0 :  ERR_T_INT8;
+
+	return ret;
+}
+
+flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;
+
+	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_UInt8_Initialize(T_UInt8* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = 0;
+}
+
+flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 255UL);
+    *pErrCode = ret ? 0 :  ERR_T_UINT8;
+
+	return ret;
+}
+
+flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;
+
+	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
+}
+
+
+
+void T_Boolean_Initialize(T_Boolean* pVal)
+{
+	(void)pVal;
+
+
+	(*(pVal)) = FALSE;
+}
+
+flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = TRUE;
+    *pErrCode = 0;
+
+	return ret;
+}
+
+flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    BitStream_AppendBit(pBitStrm,(*(pVal)));
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = BitStream_ReadBit(pBitStrm, pVal);
+	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;
+
+	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/taste-types.h b/generated/taste-types.h
new file mode 100644
index 0000000..1ae0ebc
--- /dev/null
+++ b/generated/taste-types.h
@@ -0,0 +1,113 @@
+#ifndef GENERATED_ASN1SCC_taste_types_H
+#define GENERATED_ASN1SCC_taste_types_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+namespace i3ds_asn1 {
+
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef asn1SccSint T_Int32;
+
+
+void T_Int32_Initialize(T_Int32* pVal);
+
+#define ERR_T_INT32		8298  /**/
+flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_INT32		8299  /**/
+#define T_Int32_REQUIRED_BYTES_FOR_ENCODING       4
+#define T_Int32_REQUIRED_BITS_FOR_ENCODING        32
+
+flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_INT32		8300  /**/
+flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt32;
+
+
+void T_UInt32_Initialize(T_UInt32* pVal);
+
+#define ERR_T_UINT32		8305  /**/
+flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_UINT32		8306  /**/
+#define T_UInt32_REQUIRED_BYTES_FOR_ENCODING       4
+#define T_UInt32_REQUIRED_BITS_FOR_ENCODING        32
+
+flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_UINT32		8307  /**/
+flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccSint T_Int8;
+
+
+void T_Int8_Initialize(T_Int8* pVal);
+
+#define ERR_T_INT8		8312  /**/
+flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_INT8		8313  /**/
+#define T_Int8_REQUIRED_BYTES_FOR_ENCODING       1
+#define T_Int8_REQUIRED_BITS_FOR_ENCODING        8
+
+flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_INT8		8314  /**/
+flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef asn1SccUint T_UInt8;
+
+
+void T_UInt8_Initialize(T_UInt8* pVal);
+
+#define ERR_T_UINT8		8319  /**/
+flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_UINT8		8320  /**/
+#define T_UInt8_REQUIRED_BYTES_FOR_ENCODING       1
+#define T_UInt8_REQUIRED_BITS_FOR_ENCODING        8
+
+flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_UINT8		8321  /**/
+flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode);
+typedef flag T_Boolean;
+
+
+void T_Boolean_Initialize(T_Boolean* pVal);
+
+#define ERR_T_BOOLEAN		8326  /**/
+flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_T_BOOLEAN		8327  /**/
+#define T_Boolean_REQUIRED_BYTES_FOR_ENCODING       1
+#define T_Boolean_REQUIRED_BITS_FOR_ENCODING        1
+
+flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_T_BOOLEAN		8328  /**/
+flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode);
+
+
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/generated/userdefs-base.c b/generated/userdefs-base.c
new file mode 100644
index 0000000..0a94d90
--- /dev/null
+++ b/generated/userdefs-base.c
@@ -0,0 +1,118 @@
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <limits.h>
+#include <string.h>
+#include <math.h>
+
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+#include <i3ds_asn1/asn1crt_encoding_uper.hpp>
+#include <i3ds_asn1/asn1crt_encoding_acn.hpp>
+
+#include <i3ds_asn1/userdefs-base.hpp>
+namespace i3ds_asn1 {
+
+const T_UInt32 numBase_JointTrajectory = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_JointTransform = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Waypoint = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Wrench = 200;
+const T_UInt32 numStd_vector_Wrappers_Vector4d = 200;
+const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Trajectory = 200;
+const T_UInt32 numBase_JointLimits_names = 200;
+const T_UInt32 numBase_JointLimits_elements = 200;
+const T_UInt32 numBase_JointsTrajectory_names = 200;
+const T_UInt32 numBase_JointsTrajectory_elements = 200;
+const T_UInt32 numBase_JointsTrajectory_times_val = 200;
+const T_UInt32 numBase_NamedVector_Base_JointLimitRange_names = 200;
+const T_UInt32 numBase_NamedVector_Base_JointLimitRange_elements = 200;
+const T_UInt32 numBase_NamedVector_Base_JointState_names = 200;
+const T_UInt32 numBase_NamedVector_Base_Wrench_names = 200;
+const T_UInt32 numBase_NamedVector_Base_Wrench_elements = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTrajectory_names = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTrajectory_elements = 200;
+const T_UInt32 numBase_samples_DepthMap_timestamps = 200;
+const T_UInt32 numBase_samples_DepthMap_vertical_interval = 200;
+const T_UInt32 numBase_samples_DepthMap_horizontal_interval = 200;
+const T_UInt32 numBase_samples_DepthMap_distances = 200;
+const T_UInt32 numBase_samples_DepthMap_remissions = 200;
+const T_UInt32 numBase_samples_DistanceImage_data = 200;
+const T_UInt32 numBase_commands_Joints_names = 200;
+const T_UInt32 numBase_samples_LaserScan_ranges = 200;
+const T_UInt32 numBase_samples_LaserScan_remission = 200;
+const T_UInt32 numBase_samples_Pointcloud_points = 200;
+const T_UInt32 numBase_samples_Pointcloud_colors = 200;
+const T_UInt32 numBase_samples_Sonar_timestamps = 200;
+const T_UInt32 numBase_samples_Sonar_bearings = 200;
+const T_UInt32 numBase_samples_Sonar_bins = 200;
+const T_UInt32 numBase_samples_SonarBeam_beam = 200;
+const T_UInt32 numBase_samples_SonarScan_data = 200;
+const T_UInt32 numBase_samples_SonarScan_time_beams = 200;
+const T_UInt32 numBase_samples_Wrenches_names = 200;
+const T_UInt32 numBase_samples_Wrenches_elements = 200;
+const T_UInt32 numBase_JointTransformVector_names = 200;
+const T_UInt32 numBase_JointTransformVector_elements = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTransform_names = 200;
+const T_UInt32 numBase_NamedVector_Base_JointTransform_elements = 200;
+const T_UInt32 numBase_samples_frame_Frame_image = 200;
+const T_UInt32 numBase_samples_frame_Frame_attributes = 200;
+const T_UInt32 numWrappers_MatrixXd_data = 200;
+const T_UInt32 numWrappers_VectorXd_data = 200;
+const T_UInt32 numBase_JointTransformVector_m_names = 200;
+const T_UInt32 numBase_NamedVector_base_JointTransform_m_names = 200;
+const T_UInt32 numBase_NamedVector_base_Wrench_m_names = 200;
+const T_UInt32 numBase_samples_Pointcloud_m_points = 200;
+const T_UInt32 numBase_samples_Pointcloud_m_colors = 200;
+const T_UInt32 numBase_samples_Wrenches_m_names = 200;
+const T_UInt32 numWrappers_geometry_Spline_knots = 200;
+const T_UInt32 numWrappers_geometry_Spline_vertices = 200;
+
+
+void DummyBase_T_Initialize(DummyBase_T* pVal)
+{
+	(void)pVal;
+
+
+	T_UInt32_Initialize(pVal);
+}
+
+flag DummyBase_T_IsConstraintValid(const DummyBase_T* pVal, int* pErrCode)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	
+    ret = ((*(pVal)) <= 4294967295UL);
+    *pErrCode = ret ? 0 :  ERR_DUMMYBASE_T;
+
+	return ret;
+}
+
+flag DummyBase_T_Encode(const DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
+{
+    flag ret = TRUE;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = bCheckConstraints ? DummyBase_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
+	if (ret) {
+	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
+    } /*COVERAGE_IGNORE*/
+
+	
+    return ret;
+}
+
+flag DummyBase_T_Decode(DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode)
+{
+    flag ret = TRUE;
+	*pErrCode = 0;
+	(void)pVal;
+	(void)pBitStrm;
+
+
+	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);
+
+	return ret  && DummyBase_T_IsConstraintValid(pVal, pErrCode);
+}
+} // namespace i3ds_asn1
+
diff --git a/generated/userdefs-base.h b/generated/userdefs-base.h
new file mode 100644
index 0000000..bab8c72
--- /dev/null
+++ b/generated/userdefs-base.h
@@ -0,0 +1,102 @@
+#ifndef GENERATED_ASN1SCC_userdefs_base_H
+#define GENERATED_ASN1SCC_userdefs_base_H
+/*
+Code automatically generated by asn1scc tool
+*/
+#include <i3ds_asn1/asn1crt.hpp>
+#include <i3ds_asn1/asn1crt_encoding.hpp>
+
+#include <i3ds_asn1/taste-types.hpp>
+namespace i3ds_asn1 {
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+typedef T_UInt32 DummyBase_T;
+
+
+void DummyBase_T_Initialize(DummyBase_T* pVal);
+
+#define ERR_DUMMYBASE_T		8333  /**/
+flag DummyBase_T_IsConstraintValid(const DummyBase_T* pVal, int* pErrCode);
+
+#define ERR_UPER_ENCODE_DUMMYBASE_T_2		8340  /**/
+#define DummyBase_T_REQUIRED_BYTES_FOR_ENCODING       4
+#define DummyBase_T_REQUIRED_BITS_FOR_ENCODING        32
+
+flag DummyBase_T_Encode(const DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
+
+#define ERR_UPER_DECODE_DUMMYBASE_T_2		8341  /**/
+flag DummyBase_T_Decode(DummyBase_T* pVal, BitStream* pBitStrm, int* pErrCode);
+
+extern const T_UInt32 numBase_JointTrajectory;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_JointTransform;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Waypoint;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Wrench;
+extern const T_UInt32 numStd_vector_Wrappers_Vector4d;
+extern const T_UInt32 numStd_orogen_typekits_mtype_std_vector_base_Trajectory;
+extern const T_UInt32 numBase_JointLimits_names;
+extern const T_UInt32 numBase_JointLimits_elements;
+extern const T_UInt32 numBase_JointsTrajectory_names;
+extern const T_UInt32 numBase_JointsTrajectory_elements;
+extern const T_UInt32 numBase_JointsTrajectory_times_val;
+extern const T_UInt32 numBase_NamedVector_Base_JointLimitRange_names;
+extern const T_UInt32 numBase_NamedVector_Base_JointLimitRange_elements;
+extern const T_UInt32 numBase_NamedVector_Base_JointState_names;
+extern const T_UInt32 numBase_NamedVector_Base_Wrench_names;
+extern const T_UInt32 numBase_NamedVector_Base_Wrench_elements;
+extern const T_UInt32 numBase_NamedVector_Base_JointTrajectory_names;
+extern const T_UInt32 numBase_NamedVector_Base_JointTrajectory_elements;
+extern const T_UInt32 numBase_samples_DepthMap_timestamps;
+extern const T_UInt32 numBase_samples_DepthMap_vertical_interval;
+extern const T_UInt32 numBase_samples_DepthMap_horizontal_interval;
+extern const T_UInt32 numBase_samples_DepthMap_distances;
+extern const T_UInt32 numBase_samples_DepthMap_remissions;
+extern const T_UInt32 numBase_samples_DistanceImage_data;
+extern const T_UInt32 numBase_commands_Joints_names;
+extern const T_UInt32 numBase_samples_LaserScan_ranges;
+extern const T_UInt32 numBase_samples_LaserScan_remission;
+extern const T_UInt32 numBase_samples_Pointcloud_points;
+extern const T_UInt32 numBase_samples_Pointcloud_colors;
+extern const T_UInt32 numBase_samples_Sonar_timestamps;
+extern const T_UInt32 numBase_samples_Sonar_bearings;
+extern const T_UInt32 numBase_samples_Sonar_bins;
+extern const T_UInt32 numBase_samples_SonarBeam_beam;
+extern const T_UInt32 numBase_samples_SonarScan_data;
+extern const T_UInt32 numBase_samples_SonarScan_time_beams;
+extern const T_UInt32 numBase_samples_Wrenches_names;
+extern const T_UInt32 numBase_samples_Wrenches_elements;
+extern const T_UInt32 numBase_JointTransformVector_names;
+extern const T_UInt32 numBase_JointTransformVector_elements;
+extern const T_UInt32 numBase_NamedVector_Base_JointTransform_names;
+extern const T_UInt32 numBase_NamedVector_Base_JointTransform_elements;
+extern const T_UInt32 numBase_samples_frame_Frame_image;
+extern const T_UInt32 numBase_samples_frame_Frame_attributes;
+extern const T_UInt32 numWrappers_MatrixXd_data;
+extern const T_UInt32 numWrappers_VectorXd_data;
+extern const T_UInt32 numBase_JointTransformVector_m_names;
+extern const T_UInt32 numBase_NamedVector_base_JointTransform_m_names;
+extern const T_UInt32 numBase_NamedVector_base_Wrench_m_names;
+extern const T_UInt32 numBase_samples_Pointcloud_m_points;
+extern const T_UInt32 numBase_samples_Pointcloud_m_colors;
+extern const T_UInt32 numBase_samples_Wrenches_m_names;
+extern const T_UInt32 numWrappers_geometry_Spline_knots;
+extern const T_UInt32 numWrappers_geometry_Spline_vertices;
+
+/* ================= Encoding/Decoding function prototypes =================
+ * These functions are placed at the end of the file to make sure all types
+ * have been declared first, in case of parameterized ACN encodings
+ * ========================================================================= */
+
+
+
+
+#ifdef  __cplusplus
+}
+
+#endif
+
+} // namespace i3ds_asn1
+#endif
diff --git a/petamake_gmv.sh b/petamake_gmv.sh
new file mode 100755
index 0000000..44d8f92
--- /dev/null
+++ b/petamake_gmv.sh
@@ -0,0 +1,28 @@
+
+#!/bin/bash
+set -e
+#source /opt/petalinux/settings.sh
+source /tools/Xilinx/SDK/2019.1/settings64.sh
+BUILDPATH="petalinux_build"
+
+BSP_NAME=xilinx-zcu102-2019.2
+#BSP_ROOT=/home/peraspera/$BSP_NAME/build/tmp/sysroots/plnx_aarch64
+BSP_ROOT=/home/peraspera/$BSP_NAME/images/linux/sdk/sysroots/aarch64-xilinx-linux/
+
+mkdir -p ${BUILDPATH}
+cd ${BUILDPATH}
+cmake .. -DCMAKE_C_COMPILER="aarch64-linux-gnu-gcc" \
+      -DCMAKE_CXX_COMPILER="aarch64-linux-gnu-c++" \
+      -DCMAKE_FIND_ROOT_PATH="$BSP_ROOT" \
+      -DBUILD_EMBEDDED=ON \
+      -DBUILD_DEBUG=OFF \
+      -DBUILD_TOOLS=ON \
+      -DBUILD_TESTS=OFF \
+      -DBUILD_BINDINGS=OFF \
+      -DGENERATE_ASN=OFF \
+
+test -z ${NUM_CPUS} && NUM_CPUS=$(grep ^cpu\ MHz /proc/cpuinfo | wc -l)
+make -j${NUM_CPUS}
+make DESTDIR=/home/peraspera/usr_plnx/ install
+cp -r /home/peraspera/usr_plnx/usr/local/include/i3ds_asn1 ${BSP_ROOT}/usr/include
+cp /home/peraspera/usr_plnx/usr/local/lib/libi3ds_asn1.so* ${BSP_ROOT}/usr/lib
